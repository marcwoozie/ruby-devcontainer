# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def deconstruct(); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end

  def test_order(); end

  def test_order=(val); end

  def test_parallelization_threshold(); end

  def test_parallelization_threshold=(val); end
end

module ActiveSupport::ActionableError
end

module ActiveSupport::ActionableError::ClassMethods
  def action(name, &block); end
end

module ActiveSupport::ActionableError::ClassMethods
end

class ActiveSupport::ActionableError::NonActionable
end

class ActiveSupport::ActionableError::NonActionable
end

module ActiveSupport::ActionableError
  extend ::ActiveSupport::Concern
  def self.actions(error); end

  def self.dispatch(error, name); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

module ActiveSupport::Autoload
  def autoload(const_name, path=T.unsafe(nil)); end

  def autoload_at(path); end

  def autoload_under(path); end

  def eager_autoload(); end

  def eager_load!(); end
end

module ActiveSupport::Autoload
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean_frame(frame, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Benchmark
end

module ActiveSupport::Benchmark
  def self.realtime(unit=T.unsafe(nil), &block); end
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module ActiveSupport::Benchmarkable
end

class ActiveSupport::BroadcastLogger
  include ::ActiveSupport::LoggerSilence
  include ::ActiveSupport::LoggerThreadSafeLevel
  def <<(message); end

  def add(*arg, **arg1, &arg2); end

  def broadcast_to(*loggers); end

  def broadcasts(); end

  def close(); end

  def debug(*arg, **arg1, &arg2); end

  def debug!(); end

  def debug?(); end

  def error(*arg, **arg1, &arg2); end

  def error!(); end

  def error?(); end

  def fatal(*arg, **arg1, &arg2); end

  def fatal!(); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(*arg, **arg1, &arg2); end

  def info!(); end

  def info?(); end

  def initialize(*loggers); end

  def level=(level); end

  def log(*arg, **arg1, &arg2); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold=(level); end

  def silencer(); end

  def silencer=(val); end

  def stop_broadcasting_to(logger); end

  def unknown(*arg, **arg1, &arg2); end

  def warn(*arg, **arg1, &arg2); end

  def warn!(); end

  def warn?(); end
end

class ActiveSupport::BroadcastLogger
  def self.silencer(); end

  def self.silencer=(val); end
end

module ActiveSupport::Cache
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
  OPTION_ALIASES = ::T.let(nil, ::T.untyped)
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Coder
  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def initialize(serializer, compressor, legacy_serializer: T.unsafe(nil)); end

  def load(dumped); end
  COMPRESSED_FLAG = ::T.let(nil, ::T.untyped)
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  OBJECT_DUMP_TYPE = ::T.let(nil, ::T.untyped)
  PACKED_EXPIRES_AT_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_TYPE_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_VERSION_INDEX = ::T.let(nil, ::T.untyped)
  PACKED_VERSION_LENGTH_TEMPLATE = ::T.let(nil, ::T.untyped)
  SIGNATURE = ::T.let(nil, ::T.untyped)
  STRING_DESERIALIZERS = ::T.let(nil, ::T.untyped)
  STRING_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Coder::LazyEntry
  def initialize(serializer, compressor, payload, **options); end
end

class ActiveSupport::Cache::Coder::LazyEntry
end

class ActiveSupport::Cache::Coder::StringDeserializer
  def initialize(encoding); end

  def load(payload); end
end

class ActiveSupport::Cache::Coder::StringDeserializer
end

class ActiveSupport::Cache::Coder
end

class ActiveSupport::Cache::DeserializationError
end

class ActiveSupport::Cache::DeserializationError
end

class ActiveSupport::Cache::Entry
  def bytesize(); end

  def compressed(compress_threshold); end

  def compressed?(); end

  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compressed: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), expires_at: T.unsafe(nil), **arg); end

  def local?(); end

  def mismatched?(version); end

  def pack(); end

  def value(); end

  def version(); end
end

class ActiveSupport::Cache::Entry
  def self.unpack(members); end
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, **options); end
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def load(entry); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  extend ::ActiveSupport::Cache::MemoryStore::DupCoder
end

class ActiveSupport::Cache::MemoryStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

module ActiveSupport::Cache::SerializerWithFallback
  def load(dumped); end
  SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(marked); end

  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def dumped?(dumped); end
  MARK_COMPRESSED = ::T.let(nil, ::T.untyped)
  MARK_UNCOMPRESSED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(dumped); end

  def dump(value); end

  def dumped?(dumped); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(dumped); end

  def dump(value); end

  def dumped?(dumped); end
end

module ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  include ::ActiveSupport::Cache::SerializerWithFallback
  def _load(entry); end

  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def dumped?(dumped); end
end

module ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  extend ::ActiveSupport::Cache::SerializerWithFallback
end

module ActiveSupport::Cache::SerializerWithFallback
  def self.[](format); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def delete_multi(names, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil), &block); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(val); end

  def mute(); end

  def new_entry(value, options=T.unsafe(nil)); end

  def options(); end

  def raise_on_invalid_cache_expiration_time(); end

  def raise_on_invalid_cache_expiration_time=(val); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(val); end

  def self.raise_on_invalid_cache_expiration_time(); end

  def self.raise_on_invalid_cache_expiration_time=(val); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(&block); end
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

class ActiveSupport::Cache::WriteOptions
  def expires_at(); end

  def expires_at=(expires_at); end

  def expires_in(); end

  def expires_in=(expires_in); end

  def initialize(options); end

  def version(); end

  def version=(version); end
end

class ActiveSupport::Cache::WriteOptions
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.format_version(); end

  def self.format_version=(format_version); end

  def self.lookup_store(store=T.unsafe(nil), *parameters); end
end

module ActiveSupport::Callbacks
  def run_callbacks(kind, type=T.unsafe(nil)); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks::CallTemplate
end

class ActiveSupport::Callbacks::CallTemplate::InstanceExec0
  def expand(target, value, block); end

  def initialize(block); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate::InstanceExec0
end

class ActiveSupport::Callbacks::CallTemplate::InstanceExec1
  def expand(target, value, block); end

  def initialize(block); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate::InstanceExec1
end

class ActiveSupport::Callbacks::CallTemplate::InstanceExec2
  def expand(target, value, block); end

  def initialize(block); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate::InstanceExec2
end

class ActiveSupport::Callbacks::CallTemplate::MethodCall
  def expand(target, value, block); end

  def initialize(method); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate::MethodCall
end

class ActiveSupport::Callbacks::CallTemplate::ObjectCall
  def expand(target, value, block); end

  def initialize(target, method); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate::ObjectCall
end

class ActiveSupport::Callbacks::CallTemplate::ProcCall
  def expand(target, value, block); end

  def initialize(target); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate::ProcCall
end

module ActiveSupport::Callbacks::CallTemplate
  def self.build(filter, callback); end
end

class ActiveSupport::Callbacks::Callback
  def apply(callback_sequence); end

  def chain_config(); end

  def compiled(); end

  def current_scopes(); end

  def duplicates?(other); end

  def filter(); end

  def initialize(name, filter, kind, options, chain_config); end

  def kind(); end

  def kind=(kind); end

  def matches?(_kind, _filter); end

  def merge_conditional_options(chain, if_option:, unless_option:); end

  def name(); end

  def name=(name); end
end

class ActiveSupport::Callbacks::Callback
  def self.build(chain, filter, kind, options); end
end

class ActiveSupport::Callbacks::CallbackChain
  include ::Enumerable
  def append(*callbacks); end

  def chain(); end

  def clear(); end

  def compile(type); end

  def config(); end

  def delete(o); end

  def each(&block); end

  def empty?(); end

  def index(o); end

  def initialize(name, config); end

  def insert(index, o); end

  def name(); end

  def prepend(*callbacks); end
end

class ActiveSupport::Callbacks::CallbackChain
end

class ActiveSupport::Callbacks::CallbackSequence
  def after(after); end

  def around(call_template, user_conditions); end

  def before(before); end

  def expand_call_template(arg, block); end

  def final?(); end

  def initialize(nested=T.unsafe(nil), call_template=T.unsafe(nil), user_conditions=T.unsafe(nil)); end

  def invoke_after(arg); end

  def invoke_before(arg); end

  def nested(); end

  def skip?(arg); end
end

class ActiveSupport::Callbacks::CallbackSequence
end

module ActiveSupport::Callbacks::ClassMethods
  def __update_callbacks(name); end

  def define_callbacks(*names); end

  def get_callbacks(name); end

  def normalize_callback_params(filters, block); end

  def reset_callbacks(name); end

  def set_callback(name, *filter_list, &block); end

  def set_callbacks(name, callbacks); end

  def skip_callback(name, *filter_list, &block); end
end

module ActiveSupport::Callbacks::Conditionals
end

class ActiveSupport::Callbacks::Conditionals::Value
  def call(target, value); end

  def initialize(&block); end
end

class ActiveSupport::Callbacks::Conditionals::Value
end

module ActiveSupport::Callbacks::Conditionals
end

module ActiveSupport::Callbacks::Filters
end

class ActiveSupport::Callbacks::Filters::After
  def apply(callback_sequence); end

  def call(env); end

  def halting(); end

  def initialize(user_callback, user_conditions, chain_config); end

  def user_callback(); end

  def user_conditions(); end
end

class ActiveSupport::Callbacks::Filters::After
end

class ActiveSupport::Callbacks::Filters::Around
  def apply(callback_sequence); end

  def initialize(user_callback, user_conditions); end
end

class ActiveSupport::Callbacks::Filters::Around
end

class ActiveSupport::Callbacks::Filters::Before
  def apply(callback_sequence); end

  def call(env); end

  def filter(); end

  def halted_lambda(); end

  def initialize(user_callback, user_conditions, chain_config, filter, name); end

  def name(); end

  def user_callback(); end

  def user_conditions(); end
end

class ActiveSupport::Callbacks::Filters::Before
end

class ActiveSupport::Callbacks::Filters::Environment
  def halted(); end

  def halted=(_); end

  def target(); end

  def target=(_); end

  def value(); end

  def value=(_); end
end

class ActiveSupport::Callbacks::Filters::Environment
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveSupport::Callbacks::Filters
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::ClassAttribute
end

module ActiveSupport::ClassAttribute
  def self.redefine(owner, name, namespaced_name, value); end

  def self.redefine_method(owner, name, private: T.unsafe(nil), &block); end
end

class ActiveSupport::CodeGenerator
  def class_eval(); end

  def define_cached_method(canonical_name, namespace:, as: T.unsafe(nil), &block); end

  def execute(); end

  def initialize(owner, path, line); end
end

class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end

  def define_cached_method(canonical_name, as: T.unsafe(nil)); end

  def initialize(namespace); end
  METHOD_CACHES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator::MethodSet
end

class ActiveSupport::CodeGenerator
  def self.batch(owner, path, line); end
end

module ActiveSupport::Concern
  def append_features(base); end

  def class_methods(&class_methods_module_definition); end

  def included(base=T.unsafe(nil), &block); end

  def prepend_features(base); end

  def prepended(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
end

class ActiveSupport::Concern::MultiplePrependBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultiplePrependBlocks
end

module ActiveSupport::Concern
  def self.extended(base); end
end

module ActiveSupport::Concurrency
end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

class ActiveSupport::Concurrency::ShareLock
end

module ActiveSupport::Concurrency
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable::ClassMethods
  def config(); end

  def configure(); end
end

class ActiveSupport::Configurable::Configuration
  def compile_methods!(); end
end

class ActiveSupport::Configurable::Configuration
  def self.compile_methods!(keys); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::ConfigurationFile
  def initialize(content_path); end

  def parse(context: T.unsafe(nil), **options); end
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile
  def self.parse(content_path, **options); end
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def defaults(); end

  def defaults?(); end

  def reset(); end

  def set(attributes, &block); end
  INVALID_ATTRIBUTE_NAMES = ::T.let(nil, ::T.untyped)
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(*methods, &block); end

  def self.attribute(*names, default: T.unsafe(nil)); end

  def self.before_reset(*methods, &block); end

  def self.clear_all(); end

  def self.defaults(); end

  def self.defaults=(value); end

  def self.defaults?(); end

  def self.instance(); end

  def self.reset(*arg, **arg1, &arg2); end

  def self.reset_all(); end

  def self.resets(*methods, &block); end

  def self.set(*arg, **arg1, &arg2); end
end

module ActiveSupport::DeepMergeable
  def deep_merge(other, &block); end

  def deep_merge!(other, &block); end

  def deep_merge?(other); end
end

module ActiveSupport::DeepMergeable
end

module ActiveSupport::Delegation
  RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Delegation
  def self.generate(owner, methods, location: T.unsafe(nil), to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), nilable: T.unsafe(nil), private: T.unsafe(nil), as: T.unsafe(nil), signature: T.unsafe(nil)); end

  def self.generate_method_missing(owner, target, allow_nil: T.unsafe(nil)); end
end

class ActiveSupport::DelegationError
end

class ActiveSupport::DelegationError
  def self.nil_target(method_name, target); end
end

module ActiveSupport::Dependencies
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(&block); end

  def permit_concurrent_loads(&block); end

  def raw_state(&block); end

  def running(&block); end

  def start_running(); end

  def start_unloading(); end

  def unloading(&block); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::RequireDependency
  def require_dependency(filename); end
end

module ActiveSupport::Dependencies::RequireDependency
end

module ActiveSupport::Dependencies
  def self._autoloaded_tracked_classes(); end

  def self._autoloaded_tracked_classes=(_autoloaded_tracked_classes); end

  def self._eager_load_paths(); end

  def self._eager_load_paths=(_eager_load_paths); end

  def self.autoload_once_paths(); end

  def self.autoload_once_paths=(autoload_once_paths); end

  def self.autoload_paths(); end

  def self.autoload_paths=(autoload_paths); end

  def self.autoloader(); end

  def self.autoloader=(autoloader); end

  def self.clear(); end

  def self.eager_load?(path); end

  def self.interlock(); end

  def self.interlock=(interlock); end

  def self.load_interlock(&block); end

  def self.run_interlock(&block); end

  def self.search_for_file(relpath); end

  def self.unload_interlock(&block); end
end

class ActiveSupport::Deprecation
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::Disallowed
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end

  def disallowed_behavior(); end

  def disallowed_behavior=(behavior); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def append_features(base); end

  def extended(base); end

  def hash(*arg, **arg1, &arg2); end

  def initialize(old_const, new_const, deprecator, message: T.unsafe(nil)); end

  def instance_methods(*arg, **arg1, &arg2); end

  def name(*arg, **arg1, &arg2); end

  def prepend_features(base); end

  def respond_to?(*arg, **arg1, &arg2); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, **options, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator:); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, **kwargs, &block); end
end

class ActiveSupport::Deprecation::Deprecators
  def [](name); end

  def []=(name, deprecator); end

  def behavior=(behavior); end

  def debug=(debug); end

  def disallowed_behavior=(disallowed_behavior); end

  def disallowed_warnings=(disallowed_warnings); end

  def each(&block); end

  def silence(&block); end

  def silenced=(silenced); end
end

class ActiveSupport::Deprecation::Deprecators
end

module ActiveSupport::Deprecation::Disallowed
  def disallowed_warnings(); end

  def disallowed_warnings=(disallowed_warnings); end
end

module ActiveSupport::Deprecation::Disallowed
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def allow(allowed_warnings=T.unsafe(nil), if: T.unsafe(nil), &block); end

  def begin_silence(); end

  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def end_silence(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(&block); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
  LIB_DIR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Deprecation
  def self._instance(); end
end

module ActiveSupport::DescendantsTracker
  def descendants(); end
end

module ActiveSupport::DescendantsTracker::ReloadedClassesFiltering
  def descendants(); end

  def subclasses(); end
end

module ActiveSupport::DescendantsTracker::ReloadedClassesFiltering
end

class ActiveSupport::DescendantsTracker::WeakSet
  def <<(object); end

  def to_a(); end
end

class ActiveSupport::DescendantsTracker::WeakSet
end

module ActiveSupport::DescendantsTracker
  def self.clear(classes); end

  def self.descendants(klass); end

  def self.disable_clear!(); end

  def self.reject!(classes); end

  def self.subclasses(klass); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  def +@(); end

  def -@(); end

  def _parts(); end

  def abs(&arg); end

  def after(time=T.unsafe(nil)); end

  def before(time=T.unsafe(nil)); end

  def coerce(other); end

  def encode_with(coder); end

  def in_days(); end

  def in_hours(); end

  def in_minutes(); end

  def in_months(); end

  def in_seconds(); end

  def in_weeks(); end

  def in_years(); end

  def init_with(coder); end

  def initialize(value, parts, variable=T.unsafe(nil)); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def negative?(&arg); end

  def parts(); end

  def positive?(&arg); end

  def since(time=T.unsafe(nil)); end

  def until(time=T.unsafe(nil)); end

  def variable?(); end

  def zero?(&arg); end
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
  VARIABLE_PARTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::Duration::Scalar
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce(other); end

  def initialize(value); end

  def to_f(*arg, **arg1, &arg2); end

  def to_i(*arg, **arg1, &arg2); end

  def to_s(*arg, **arg1, &arg2); end

  def value(); end

  def variable?(); end
end

class ActiveSupport::Duration::Scalar
end

class ActiveSupport::Duration
  def self.===(other); end

  def self.days(value); end

  def self.hours(value); end

  def self.minutes(value); end

  def self.months(value); end

  def self.seconds(value); end

  def self.weeks(value); end

  def self.years(value); end
end

module ActiveSupport::EnumerableCoreExt
end

module ActiveSupport::EnumerableCoreExt::Constants
end

module ActiveSupport::EnumerableCoreExt::Constants
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

module ActiveSupport::EnumerableCoreExt
end

class ActiveSupport::EnvironmentInquirer
  def development?(); end

  def initialize(env); end

  def local?(); end

  def production?(); end

  def test?(); end
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
  LOCAL_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnvironmentInquirer
end

class ActiveSupport::ErrorReporter
  def debug_mode(); end

  def debug_mode=(debug_mode); end

  def disable(subscriber); end

  def handle(*error_classes, severity: T.unsafe(nil), context: T.unsafe(nil), fallback: T.unsafe(nil), source: T.unsafe(nil)); end

  def initialize(*subscribers, logger: T.unsafe(nil)); end

  def logger(); end

  def logger=(logger); end

  def record(*error_classes, severity: T.unsafe(nil), context: T.unsafe(nil), source: T.unsafe(nil)); end

  def report(error, handled: T.unsafe(nil), severity: T.unsafe(nil), context: T.unsafe(nil), source: T.unsafe(nil)); end

  def set_context(*arg, **arg1, &arg2); end

  def subscribe(subscriber); end

  def unexpected(error, severity: T.unsafe(nil), context: T.unsafe(nil), source: T.unsafe(nil)); end

  def unsubscribe(subscriber); end
  DEFAULT_RESCUE = ::T.let(nil, ::T.untyped)
  DEFAULT_SOURCE = ::T.let(nil, ::T.untyped)
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ErrorReporter::UnexpectedError
end

class ActiveSupport::ErrorReporter::UnexpectedError
end

class ActiveSupport::ErrorReporter
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::Core
  def changed(modified, added, removed); end

  def common_path(paths); end

  def directories_to_watch(); end

  def files(); end

  def finalizer(); end

  def initialize(files, dirs); end

  def normalize_dirs!(); end

  def restart(); end

  def restart?(); end

  def start(); end

  def stop(); end

  def thread_safely(); end

  def updated(); end

  def watching?(file); end
end

class ActiveSupport::EventedFileUpdateChecker::Core
end

class ActiveSupport::EventedFileUpdateChecker
end

module ActiveSupport::ExecutionContext
end

module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end

  def self.after_change(&block); end

  def self.clear(); end

  def self.set(**options); end

  def self.to_h(); end
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete(); end

  def complete!(); end

  def run(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active?(); end

  def self.active_key(); end

  def self.error_reporter(); end

  def self.perform(); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(reset: T.unsafe(nil)); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(source: T.unsafe(nil)); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::ForkTracker
end

module ActiveSupport::ForkTracker::CoreExt
  def _fork(); end
end

module ActiveSupport::ForkTracker::CoreExt
end

module ActiveSupport::ForkTracker
  def self.after_fork(&block); end

  def self.after_fork_callback(); end

  def self.hook!(); end

  def self.unregister(callback); end
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
  def initialize(*arg); end
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

module ActiveSupport::Inflector
  def downcase_first(string); end
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end

  def self.instance_or_fallback(locale); end
end

class ActiveSupport::InheritableOptions
  def ==(other); end

  def each(&block); end

  def key?(key); end

  def overridden?(key); end

  def pretty_print(pp); end
end

module ActiveSupport::IsolatedExecutionState
end

module ActiveSupport::IsolatedExecutionState
  def self.[](key); end

  def self.[]=(key, value); end

  def self.clear(); end

  def self.context(); end

  def self.delete(key); end

  def self.isolation_level(); end

  def self.isolation_level=(level); end

  def self.key?(key); end

  def self.scope(); end

  def self.share_with(other); end

  def self.unique_id(); end
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.dump(value, options=T.unsafe(nil)); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.load(json); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def self.extended(base); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(val); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def event_levels=(event_levels); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def silenced?(event); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  LEVEL_CHECKS = ::T.let(nil, ::T.untyped)
  MODES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.attach_to(*arg, **arg1, &arg2); end

  def self.colorize_logging(); end

  def self.colorize_logging=(val); end

  def self.flush_all!(); end

  def self.log_levels(); end

  def self.log_levels=(value); end

  def self.log_levels?(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerSilence
  include ::ActiveSupport::LoggerThreadSafeLevel
  def initialize(*args, **kwargs); end

  def silencer(); end

  def silencer=(val); end
end

class ActiveSupport::Logger::SimpleFormatter
  def call(severity, timestamp, progname, msg); end
end

class ActiveSupport::Logger::SimpleFormatter
end

class ActiveSupport::Logger
  def self.logger_outputs_to?(logger, *sources); end

  def self.normalize_sources(sources); end

  def self.silencer(); end

  def self.silencer=(val); end
end

module ActiveSupport::LoggerSilence
  def silence(severity=T.unsafe(nil)); end
end

module ActiveSupport::LoggerSilence
  extend ::ActiveSupport::Concern
end

module ActiveSupport::LoggerThreadSafeLevel
  def level(); end

  def local_level(); end

  def local_level=(level); end

  def log_at(level); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator
  def create_message(value, **options); end

  def decrypt_and_verify(message, **options); end

  def encrypt_and_sign(value, **options); end
  AUTH_TAG_LENGTH = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActiveSupport::MessageEncryptor::OpenSSLCipherError
end

class ActiveSupport::MessageEncryptor::OpenSSLCipherError
end

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(val); end
end

class ActiveSupport::MessageEncryptors
end

class ActiveSupport::MessageEncryptors
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator
  def create_message(value, **options); end

  def generate(value, **options); end

  def valid_message?(message); end

  def verified(message, **options); end

  def verify(message, **options); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

class ActiveSupport::MessageVerifiers
end

class ActiveSupport::MessageVerifiers
end

class ActiveSupport::Messages::Codec
  include ::ActiveSupport::Messages::Metadata
  def initialize(**options); end
end

class ActiveSupport::Messages::Codec
  def self.default_serializer(); end

  def self.default_serializer=(value); end
end

module ActiveSupport::Messages::Metadata
  ENVELOPE_SERIALIZERS = ::T.let(nil, ::T.untyped)
  TIMESTAMP_SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Messages::Metadata
  def self.use_message_serializer_for_metadata(); end

  def self.use_message_serializer_for_metadata=(use_message_serializer_for_metadata); end
end

class ActiveSupport::Messages::RotationCoordinator
  def [](salt); end

  def []=(salt, codec); end

  def clear_rotations(); end

  def initialize(&secret_generator); end

  def on_rotation(&callback); end

  def rotate(**options, &block); end

  def rotate_defaults(); end

  def transitional(); end

  def transitional=(transitional); end
end

class ActiveSupport::Messages::RotationCoordinator
end

module ActiveSupport::Messages::Rotator
  def fall_back_to(fallback); end

  def initialize(*args, on_rotation: T.unsafe(nil), **options); end

  def read_message(message, on_rotation: T.unsafe(nil), **options); end

  def rotate(*args, **options); end
end

module ActiveSupport::Messages::Rotator
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*arg, **arg1, &arg2); end

  def acts_like_string?(*arg, **arg1, &arg2); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def match?(*arg, **arg1, &arg2); end

  def method_missing(method, *arg, **arg1, &arg2); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::Multibyte
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def allocations(); end

  def cpu_time(); end

  def duration(); end

  def end(); end

  def finish!(); end

  def gc_time(); end

  def idle_time(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def payload(); end

  def payload=(payload); end

  def record(); end

  def start!(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::ActiveSupport::Notifications::FanoutIteration
  def all_listeners_for(name); end

  def build_handle(name, id, payload); end

  def clear_cache(key=T.unsafe(nil)); end

  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def groups_for(name); end

  def listeners_for(name); end

  def listening?(name); end

  def publish(name, *args); end

  def publish_event(event); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

class ActiveSupport::Notifications::Fanout::BaseGroup
  include ::ActiveSupport::Notifications::FanoutIteration
  def each(&block); end

  def initialize(listeners, name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::BaseGroup
end

class ActiveSupport::Notifications::Fanout::BaseTimeGroup
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::BaseTimeGroup
end

class ActiveSupport::Notifications::Fanout::EventObjectGroup
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::EventObjectGroup
end

class ActiveSupport::Notifications::Fanout::EventedGroup
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

class ActiveSupport::Notifications::Fanout::EventedGroup
end

class ActiveSupport::Notifications::Fanout::Handle
  include ::ActiveSupport::Notifications::FanoutIteration
  def finish(); end

  def finish_with_values(name, id, payload); end

  def initialize(notifier, name, id, payload); end

  def start(); end
end

class ActiveSupport::Notifications::Fanout::Handle
end

class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup
end

class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def delegate(); end

  def group_class(); end

  def initialize(pattern, delegate); end

  def pattern(); end

  def publish(name, *args); end

  def publish_event(event); end

  def silenceable(); end

  def silenced?(name); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
  def ===(name); end

  def unsubscribe!(*arg); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener, monotonic); end
end

class ActiveSupport::Notifications::Fanout::TimedGroup
end

class ActiveSupport::Notifications::Fanout::TimedGroup
end

class ActiveSupport::Notifications::Fanout
end

module ActiveSupport::Notifications::FanoutIteration
end

module ActiveSupport::Notifications::FanoutIteration
end

class ActiveSupport::Notifications::InstrumentationSubscriberError
  def exceptions(); end

  def initialize(exceptions); end
end

class ActiveSupport::Notifications::InstrumentationSubscriberError
end

class ActiveSupport::Notifications::Instrumenter
  def build_handle(name, payload); end

  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def new_event(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle
  def finish(); end

  def initialize(notifier, name, id, payload); end

  def start(); end
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
  def build_handle(name, id, payload); end

  def finish(*arg, **arg1, &arg2); end

  def initialize(notifier); end

  def start(*arg, **arg1, &arg2); end
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
end

class ActiveSupport::Notifications::Instrumenter::LegacyHandle
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.monotonic_subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.publish_event(event); end

  def self.subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end

  def self.subscribed(callback, pattern=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def self.unsubscribe(subscriber_or_name); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def nested_under_indifferent_access(); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(arg); end

  def dig(key, *identifiers); end

  def method_missing(method, *args); end
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(check); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(executor); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(value); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(value); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end

  def self.wrap(**kwargs); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable::ClassMethods
  def handler_for_rescue(exception, object: T.unsafe(nil)); end

  def rescue_with_handler(exception, object: T.unsafe(nil), visited_exceptions: T.unsafe(nil)); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(arg1, arg2, arg3=T.unsafe(nil)); end

  def bytesplice(*args, value); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def scrub(*args, &block); end

  def scrub!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
  def initialize(); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  def initialize(value, on_rotation: T.unsafe(nil)); end

  def rotate(previous_value); end

  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def call(event); end

  def patterns(); end

  def publish_event(event); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil), inherit_all: T.unsafe(nil)); end

  def self.detach_from(namespace, notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.subscribers(); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::ErrorReporterAssertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::ConstantStubbing
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  include ::ActiveSupport::Testing::TestsWithoutAssertions
  def __callbacks(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
  RE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TestCase::Assertion
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil), threshold: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end

  def assert_raise(*exp, match: T.unsafe(nil), &block); end

  def assert_raises(*exp, match: T.unsafe(nil), &block); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantStubbing
  def stub_const(mod, constant, new_value, exists: T.unsafe(nil)); end
end

module ActiveSupport::Testing::ConstantStubbing
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator, &block); end

  def collect_deprecations(deprecator); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::ErrorReporterAssertions
  def assert_error_reported(error_class=T.unsafe(nil), &block); end

  def assert_no_error_reported(&block); end
end

module ActiveSupport::Testing::ErrorReporterAssertions
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TestsWithoutAssertions
  def after_teardown(); end
end

module ActiveSupport::Testing::TestsWithoutAssertions
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(with_usec: T.unsafe(nil), &block); end

  def travel(duration, with_usec: T.unsafe(nil), &block); end

  def travel_back(); end

  def travel_to(date_or_time, with_usec: T.unsafe(nil)); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def acts_like_time?(); end

  def after?(arg); end

  def before?(arg); end

  def comparable_time(); end

  def encode_with(coder); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def in(other); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def method_missing(*arg, **arg1, &arg2); end

  def next_day?(); end

  def prev_day?(); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def rfc822(); end

  def since(other); end

  def time_zone(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_fs(format=T.unsafe(nil)); end

  def tomorrow?(); end

  def tv_sec(); end

  def yesterday?(); end
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def abbr(time); end

  def at(*args); end

  def dst?(time); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def match?(re); end

  def name(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.clear(); end

  def self.create(*arg, **arg1); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::Tryable
  def try(*args, **arg, &block); end

  def try!(*args, **arg, &block); end
end

module ActiveSupport::Tryable
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*arg, **arg1, &arg2); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload
  def self.cache_format_version(); end

  def self.cache_format_version=(value); end

  def self.deprecator(); end

  def self.error_reporter(); end

  def self.error_reporter=(error_reporter); end

  def self.escape_html_entities_in_json(*arg, **arg1, &arg2); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*arg, **arg1, &arg2); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.test_order(); end

  def self.test_order=(val); end

  def self.test_parallelization_threshold(); end

  def self.test_parallelization_threshold=(val); end

  def self.time_precision(*arg, **arg1, &arg2); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*arg, **arg1, &arg2); end

  def self.use_standard_json_time_format=(arg); end

  def self.utc_to_local_returns_utc_offset_times(); end

  def self.utc_to_local_returns_utc_offset_times=(value); end

  def self.version(); end
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def compact_blank!(); end

  def deconstruct(); end

  def to_csv(**options); end

  def to_fs(format=T.unsafe(nil)); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class Binding
  def clone(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::CLI
  def add(*gems); end

  def binstubs(*gems); end

  def cache(); end

  def check(); end

  def clean(); end

  def cli_help(); end

  def config(*args); end

  def console(group=T.unsafe(nil)); end

  def doctor(); end

  def env(); end

  def exec(*args); end

  def fund(); end

  def help(cli=T.unsafe(nil)); end

  def info(gem_name); end

  def init(); end

  def initialize(*args); end

  def inject(name, version); end

  def install(); end

  def issue(); end

  def licenses(); end

  def list(); end

  def lock(); end

  def open(name); end

  def outdated(*gems); end

  def platform(); end

  def plugin(*args); end

  def pristine(*gems); end

  def remove(*gems); end

  def show(gem_name=T.unsafe(nil)); end

  def update(*gems); end

  def version(); end

  def viz(); end
  AUTO_INSTALL_CMDS = ::T.let(nil, ::T.untyped)
  COMMAND_ALIASES = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  PARSEABLE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Bundler::CLI::Common
end

module Bundler::CLI::Common
  def self.ask_for_spec_from(specs); end

  def self.clean_after_install?(); end

  def self.configure_gem_version_promoter(definition, options); end

  def self.default_gem_spec(name); end

  def self.ensure_all_gems_in_lockfile!(names, locked_gems=T.unsafe(nil)); end

  def self.gem_not_found_message(missing_gem_name, alternatives); end

  def self.output_fund_metadata_summary(); end

  def self.output_post_install_messages(messages); end

  def self.output_without_groups_message(command); end

  def self.patch_level_options(options); end

  def self.print_post_install_message(name, msg); end

  def self.select_spec(name, regex_match=T.unsafe(nil)); end

  def self.verbalize_groups(groups); end

  def self.without_groups_message(command); end
end

class Bundler::CLI::Config
  def base(name=T.unsafe(nil), *value); end

  def get(name); end

  def list(); end

  def set(name, value, *value_); end

  def unset(name); end
end

class Bundler::CLI::Config::Base
  def confirm(name); end

  def confirm_all(); end

  def explicit_scope?(); end

  def initialize(options, name, value, thor); end

  def message(); end

  def name(); end

  def new_value(); end

  def options(); end

  def run(); end

  def scope(); end

  def show_pretty_values_for(setting); end

  def thor(); end

  def validate_scope!(); end

  def value(); end

  def warn_unused_scope(msg); end
end

class Bundler::CLI::Config::Base
end

class Bundler::CLI::Config
end

class Bundler::CLI::Install
  def initialize(options); end

  def options(); end

  def run(); end
end

class Bundler::CLI::Install
end

class Bundler::CLI::Plugin
  def install(*plugins); end

  def list(); end

  def uninstall(*plugins); end
end

class Bundler::CLI::Plugin
end

class Bundler::CLI
  def self.aliases_for(command_name); end

  def self.all_aliases(); end

  def self.check_deprecated_ext_option(arguments); end

  def self.deprecated_ext_value?(arguments); end

  def self.dispatch(*arg); end

  def self.reformatted_help_args(args); end

  def self.source_root(); end

  def self.start(*arg); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def merge!(other); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::CompactIndexClient
  def available?(); end

  def dependencies(names); end

  def info(name); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def latest_version(name); end

  def names(); end

  def reset!(); end

  def versions(); end
  DEBUG_MUTEX = ::T.let(nil, ::T.untyped)
  INFO_DEPS = ::T.let(nil, ::T.untyped)
  INFO_NAME = ::T.let(nil, ::T.untyped)
  INFO_PLATFORM = ::T.let(nil, ::T.untyped)
  INFO_REQS = ::T.let(nil, ::T.untyped)
  INFO_VERSION = ::T.let(nil, ::T.untyped)
  SUPPORTED_DIGESTS = ::T.let(nil, ::T.untyped)
end

class Bundler::CompactIndexClient::Cache
  def directory(); end

  def info(name, remote_checksum=T.unsafe(nil)); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def names(); end

  def reset!(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Cache
end

class Bundler::CompactIndexClient::CacheFile
  def append(data); end

  def close(); end

  def commit(); end

  def commit!(); end

  def digests=(expected_digests); end

  def digests?(); end

  def initialize(original_path, &block); end

  def initialize_digests(keys=T.unsafe(nil)); end

  def md5(); end

  def open(write_mode=T.unsafe(nil), perm=T.unsafe(nil), &block); end

  def original_path(); end

  def path(); end

  def reset_digests(); end

  def size(); end

  def verify(); end

  def write(data); end
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
  def initialize(digests, expected_digests); end
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile
  def self.copy(path, &block); end

  def self.write(path, data, digests=T.unsafe(nil)); end
end

class Bundler::CompactIndexClient::Error
end

class Bundler::CompactIndexClient::Error
end

Bundler::CompactIndexClient::GemParser = Gem::Resolver::APISet::GemParser

class Bundler::CompactIndexClient::Parser
  def available?(); end

  def info(name); end

  def initialize(compact_index); end

  def names(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Parser
end

class Bundler::CompactIndexClient::Updater
  def initialize(fetcher); end

  def update(remote_path, local_path, etag_path); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
  def initialize(path, message); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
end

class Bundler::CompactIndexClient::Updater
end

class Bundler::CompactIndexClient
  def self.debug(); end
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CorruptBundlerInstallError
  def initialize(loaded_spec); end

  def status_code(); end
end

class Bundler::CorruptBundlerInstallError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def bundler_version_to_lock(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def prefer_local!(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end

  def source_requirements=(source_requirements); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def glob(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
  def default_force_ruby_platform(); end
end

module Bundler::ForcePlatform
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.generic_local_platform_is_ruby?(); end

  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.select_best_local_platform_match(specs, force_ruby: T.unsafe(nil)); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(name, path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::InvalidArgumentError
  def status_code(); end
end

class Bundler::InvalidArgumentError
end

class Bundler::LazySpecification
  include ::Bundler::MatchMetadata
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def lock_name(); end

  def materialize_for_installation(); end

  def name_tuple(); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def runtime_dependencies(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def include_remote_specs(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def specs_compatible_with(result); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def initialize(version, group: T.unsafe(nil), priority: T.unsafe(nil)); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def consider_remote_versions!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), prefer_local: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platform_specs(specs); end

  def platforms(); end

  def prefer_local?(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def merge(other); end

  def sorted_spec_names(); end

  def specs(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def installed_specs(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  FALLBACK_TIMEOUT_URI_OPTION = ::T.let(nil, ::T.untyped)
  REMEMBERED_KEYS = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Path
  def to_gemfile(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def default_specs(); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def remotes=(remotes); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local!(); end

  def local_mode?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def missing_specs(); end

  def names(); end

  def specs_compatible_with(other); end

  def valid?(s); end

  def validate_deps(s); end
end

class Bundler::StubSpecification
  def activated?(); end

  def base_dir=(path); end

  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def ignored?(); end

  def manually_installed?(); end

  def require_paths(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(msg); end

  def output_stream(); end

  def output_stream=(symbol); end

  def progress(&blk); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
  OUTPUT_STREAMS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def output_stream(); end

  def output_stream=(_symbol); end

  def progress(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.auto_install(); end

  def self.auto_switch(); end

  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundle_env!(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

class CGI::Cookie
  DOMAIN_VALUE_RE = ::T.let(nil, ::T.untyped)
  PATH_VALUE_RE = ::T.let(nil, ::T.untyped)
  TOKEN_RE = ::T.let(nil, ::T.untyped)
end

module CGI::Escape
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescapeURIComponent(*arg); end

  def unescape_uri_component(*arg); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::Util
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescapeURIComponent(*arg); end

  def unescape_uri_component(*arg); end
end

class CSV
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno, quoted_fields=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
  NO_QUOTED_FIELDS = ::T.let(nil, ::T.untyped)
end

class CSV::FieldsConverter
end

module CSV::InputRecordSeparator
end

module CSV::InputRecordSeparator
  def self.value(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def max_field_size(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
  STRING_SCANNER_SCAN_ACCEPT_STRING = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def check(pattern); end

  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, row_separator, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(arg); end
end

class CSV::Parser::Scanner
end

class CSV::Parser::UnexpectedError
end

class CSV::Parser::UnexpectedError
end

class CSV::Parser::UnoptimizedStringIO
  def each_line(*args, &block); end

  def eof?(); end

  def gets(*args); end

  def initialize(string); end
end

class CSV::Parser::UnoptimizedStringIO
end

class CSV::Parser
end

class CSV::Row
  def deconstruct(); end

  def deconstruct_keys(keys); end

  def dig(index_or_header, *indexes); end

  def each_pair(&block); end

  def empty?(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def to_ary(*arg); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def table(); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class Class
  def class_attribute(*attrs, instance_accessor: T.unsafe(nil), instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_predicate: T.unsafe(nil), default: T.unsafe(nil)); end

  def json_creatable?(); end
end

class Complex
  def to_d(*args); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def kill(); end

  def name(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  extend ::Concurrent::Synchronization::SafeInitialization
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CRubySet
  def &(*args); end

  def +(*args); end

  def -(*args); end

  def <(*args); end

  def <<(*args); end

  def <=(*args); end

  def ==(*args); end

  def ===(*args); end

  def >(*args); end

  def >=(*args); end

  def ^(*args); end

  def add(*args); end

  def add?(*args); end

  def classify(*args); end

  def clear(*args); end

  def collect!(*args); end

  def compare_by_identity(*args); end

  def compare_by_identity?(*args); end

  def delete(*args); end

  def delete?(*args); end

  def delete_if(*args); end

  def difference(*args); end

  def disjoint?(*args); end

  def divide(*args); end

  def each(*args, &blk); end

  def empty?(*args); end

  def eql?(*args); end

  def filter!(*args); end

  def flatten(*args); end

  def flatten!(*args); end

  def flatten_merge(*args); end

  def freeze(*args); end

  def hash(*args); end

  def include?(*args); end

  def initialize(*args, &block); end

  def inspect(*args); end

  def intersect?(*args); end

  def intersection(*args); end

  def join(*args); end

  def keep_if(*args); end

  def length(*args); end

  def map!(*args); end

  def member?(*args); end

  def merge(*args); end

  def pretty_print(*args); end

  def pretty_print_cycle(*args); end

  def proper_subset?(*args); end

  def proper_superset?(*args); end

  def reject!(*args); end

  def replace(*args); end

  def reset(*args); end

  def select!(*args); end

  def size(*args); end

  def subset?(*args); end

  def subtract(*args); end

  def superset?(*args); end

  def to_a(*args); end

  def to_s(*args); end

  def to_set(*args); end

  def union(*args); end

  def |(*args); end
end

class Concurrent::CRubySet
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil), &default_proc); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
end

module Concurrent::Concern
end

module Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def deprecated(message, strip=T.unsafe(nil)); end

  def deprecated_method(old_name, new_name); end
end

module Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
end

module Concurrent::Concern
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
end

class Concurrent::FiberLocalVar
  def bind(value); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
  LOCALS = ::T.let(nil, ::T.untyped)
end

class Concurrent::FiberLocalVar
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*arg, **arg1); end
end

class Concurrent::LockFreeStack
  extend ::Concurrent::Synchronization::SafeInitialization
  def self.of1(value); end

  def self.of2(value1, value2); end
end

Concurrent::LockLocalVar = Concurrent::FiberLocalVar

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::Map
  def each(&blk); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  extend ::Concurrent::Synchronization::SafeInitialization
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def synchronize(); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def synchronize(); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def swap(new_value); end

  def synchronize(); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::RubyExecutorService
  def initialize(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadPoolExecutor
  def active_count(); end

  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def prune_pool(); end

  def queue_length(); end

  def ready_worker(worker, last_message); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def synchronous(); end

  def worker_died(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_initialize_copy(); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::MonitorLockableObject
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::MutexLockableObject
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::Synchronization::Object
  include ::Concurrent::Synchronization::Volatile
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::SafeInitialization
  def new(*args, &block); end
end

module Concurrent::Synchronization::SafeInitialization
end

module Concurrent::Synchronization::Volatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::Volatile
  def self.included(base); end
end

module Concurrent::Synchronization
  def self.full_memory_barrier(); end
end

class Concurrent::SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SynchronizedDelegator
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  extend ::Concurrent::Synchronization::SafeInitialization
end

class Concurrent::ThreadLocalVar
  def bind(value); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
  LOCALS = ::T.let(nil, ::T.untyped)
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  def self.make_synchronized_on_cruby(klass); end

  def self.make_synchronized_on_truffleruby(klass); end
end

module Concurrent::ThreadSafe
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def interval_type(); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  DEFAULT_INTERVAL_TYPE = ::T.let(nil, ::T.untyped)
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  FIXED_DELAY = ::T.let(nil, ::T.untyped)
  FIXED_RATE = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def open(tvar); end

  def read(tvar); end

  def unlock(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::OpenEntry
  def modified(); end

  def modified=(_); end

  def value(); end

  def value=(_); end
end

class Concurrent::Transaction::OpenEntry
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
end

class Concurrent::Utility::ProcessorCounter
  def available_processor_count(); end

  def cpu_quota(); end

  def cpu_shares(); end

  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.available_processor_count(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.cpu_quota(); end

  def self.cpu_shares(); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(unit=T.unsafe(nil)); end

  def self.mutex_owned_per_thread?(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

class Date
  include ::DateAndTime::Zones
  def ago(seconds); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(arg); end

  def deconstruct_keys(arg); end

  def default_inspect(); end

  def in(seconds); end

  def infinite?(); end

  def minus_with_duration(other); end

  def minus_without_duration(arg); end

  def plus_with_duration(other); end

  def plus_without_duration(arg); end

  def readable_inspect(); end

  def since(seconds); end

  def to_fs(format=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.find_beginning_of_week!(week_start); end
end

module DateAndTime::Calculations
  def next_day?(); end

  def prev_day?(); end

  def quarter(); end

  def tomorrow?(); end

  def yesterday?(); end
end

module DateAndTime::Compatibility
  def preserve_timezone(); end

  def utc_to_local_returns_utc_offset_times(); end
end

module DateAndTime::Compatibility
  def self.preserve_timezone(); end

  def self.preserve_timezone=(val); end

  def self.utc_to_local_returns_utc_offset_times(); end

  def self.utc_to_local_returns_utc_offset_times=(val); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

class DateTime
  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end

  def self.new(*arg); end
end

class Delegator
  include ::ActiveSupport::Tryable
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def chdir(); end

  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.fchdir(arg); end

  def self.for_fd(arg); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def compact(); end

  def compact_blank(); end

  def excluding(*elements); end

  def in_order_of(key, series, filter: T.unsafe(nil)); end

  def including(*elements); end

  def maximum(key); end

  def minimum(key); end

  def pick(*keys); end

  def sole(); end

  def without(*elements); end
end

module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class Fiber
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end

  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def kill(); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

class File
  def self.absolute_path?(arg); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Find
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  FLATTENS_REQUIRED_PATHS = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  VALIDATES_FOR_RESOLUTION = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  SINCE_FAST_PATH = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  def self.build_message(gem); end

  def self.find_gem(path); end

  def self.replace_require(specs); end

  def self.uplevel(); end

  def self.warning?(name, specs: T.unsafe(nil)); end
end

class Gem::BasicSpecification
  def base_dir_priority(gem_path); end

  def default_gem_priority(); end

  def full_name_with_location(); end

  def ignored?(); end

  def plugins(); end
end

module Gem::BetterPermissionError
  def data(); end
end

module Gem::BetterPermissionError
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.deep_transform_config_keys!(config); end

  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Gem::Molinillo::CircularDependencyError
end

module Gem::Molinillo::Delegates
end

module Gem::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Gem::Molinillo::Delegates::ResolutionState
end

module Gem::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::Delegates::SpecificationProvider
end

module Gem::Molinillo::Delegates
end

class Gem::Molinillo::DependencyGraph
  include ::Enumerable
  include ::Gem::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(arg); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Molinillo::DependencyGraph::AddVertex
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Molinillo::DependencyGraph::Edge
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Molinillo::DependencyGraph::SetPayload
end

class Gem::Molinillo::DependencyGraph::Tag
  def initialize(tag); end

  def tag(); end
end

class Gem::Molinillo::DependencyGraph::Tag
end

class Gem::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Molinillo::DependencyGraph::Vertex
end

class Gem::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Molinillo::DependencyState
end

class Gem::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Molinillo::NoSuchDependencyError
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Molinillo::ResolutionState
  def self.[](*arg); end

  def self.empty(); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Molinillo::Resolver::Resolution
  include ::Gem::Molinillo::Delegates::ResolutionState
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution
end

class Gem::Molinillo::Resolver
end

class Gem::Molinillo::ResolverError
end

class Gem::Molinillo::ResolverError
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::Molinillo::VersionConflict
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Molinillo::VersionConflict
end

module Gem::Molinillo
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

Gem::Net::HTTP::ProxyMod = Gem::Net::HTTP::ProxyDelta

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_user(); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPClientError::EXCEPTION_TYPE = Gem::Net::HTTPClientException

class Gem::Net::HTTPClientError
end

Gem::Net::HTTPClientErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

Gem::Net::HTTPFatalErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPInformation::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

Gem::Net::HTTPInformationCode = Gem::Net::HTTPInformation

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPRedirection::EXCEPTION_TYPE = Gem::Net::HTTPRetriableError

class Gem::Net::HTTPRedirection
end

Gem::Net::HTTPRedirectionCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

Gem::Net::HTTPResponceReceiver = Gem::Net::HTTPResponse

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

Gem::Net::HTTPResponseReceiver = Gem::Net::HTTPResponse

Gem::Net::HTTPRetriableCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPServerError::EXCEPTION_TYPE = Gem::Net::HTTPFatalError

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerErrorCode = Gem::Net::HTTPServerError

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPSuccess::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

Gem::Net::HTTPSuccessCode = Gem::Net::HTTPSuccess

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::HTTPRequest = Gem::Net::HTTPRequest

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::Package
  def copy_stream(src, dst); end

  def gem(); end

  def limit_read(io, name, limit); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::SymlinkError
  def initialize(name, destination, destination_dir); end
end

class Gem::Package::SymlinkError
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def pos=(new_pos); end

  def read(maxlen=T.unsafe(nil)); end

  def readpartial(maxlen, outbuf=T.unsafe(nil)); end

  def rewind(); end

  def seek(offset, whence=T.unsafe(nil)); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
  def self.open(header, io, &block); end
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

module Gem::Random
end

module Gem::Random::Formatter
  def alphanumeric(n=T.unsafe(nil), chars: T.unsafe(nil)); end

  def base64(n=T.unsafe(nil)); end

  def hex(n=T.unsafe(nil)); end

  def random_bytes(n=T.unsafe(nil)); end

  def urlsafe_base64(n=T.unsafe(nil), padding=T.unsafe(nil)); end

  def uuid(); end

  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

module Gem::Random::Formatter
end

module Gem::Random
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CAA
  def critical?(); end

  def flags(); end

  def initialize(flags, tag, value); end

  def tag(); end

  def value(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CAA
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

class Gem::Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::ANY
end

class Gem::Resolv::DNS::Resource::IN::CAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CAA
end

class Gem::Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CNAME
end

class Gem::Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HINFO
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

class Gem::Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::LOC
end

class Gem::Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MINFO
end

class Gem::Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MX
end

class Gem::Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::NS
end

class Gem::Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::PTR
end

class Gem::Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SOA
end

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Gem::Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::TXT
end

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::SecureRandom
  VERSION = ::T.let(nil, ::T.untyped)
end

module Gem::SecureRandom
  extend ::Gem::Random::Formatter
  def self.bytes(n); end
end

module Gem::Security
  DEFAULT_KEY_ALGORITHM = ::T.let(nil, ::T.untyped)
  EC_NAME = ::T.let(nil, ::T.untyped)
  RSA_DSA_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_digest(algorithm=T.unsafe(nil)); end

  def self.create_key(algorithm); end

  def self.email_to_name(email_address); end

  def self.get_public_key(key); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end

  def validate_for_resolution(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.find_by_full_name(full_name); end

  def self.gemspec_stubs_in(dir, pattern); end

  def self.latest_spec_for(name); end

  def self.remove_spec(spec); end

  def self.specification_record(); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_for_resolution(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_metadata!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::SpecificationRecord
  include ::Enumerable
  def add_spec(spec); end

  def all(); end

  def all=(specs); end

  def all_names(); end

  def each(&blk); end

  def find_active_stub_by_path(path); end

  def find_all_by_name(name, *requirements); end

  def find_by_path(path); end

  def find_inactive_by_path(path); end

  def initialize(dirs); end

  def latest_spec_for(name); end

  def latest_specs(prerelease); end

  def remove_spec(spec); end

  def stubs(); end

  def stubs_for(name); end

  def stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationRecord
  def self.dirs_from(paths); end

  def self.from_path(path); end
end

class Gem::StubSpecification
  include ::Gem::BetterPermissionError
  def ==(other); end

  def build_extensions(); end

  def eql?(other); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def sort_obj(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::TSort::Cyclic
end

class Gem::TSort::Cyclic
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC2396_PARSER = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC2396_Parser

Gem::URI::REGEXP = Gem::URI::RFC2396_REGEXP

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.freebsd_platform?(); end

  def self.load_safe_marshal(); end

  def self.open_file(path, flags, &block); end

  def self.open_file_with_flock(path, &block); end

  def self.open_file_with_lock(path, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.state_file(); end

  def self.state_home(); end
end

class Hash
  include ::ActiveSupport::DeepMergeable
  def assert_valid_keys(*valid_keys); end

  def compact_blank!(); end

  def deconstruct_keys(arg); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def slice!(*keys); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key, options=T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(token); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

class I18n::Backend::LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  def initialized_locales(); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
end

class I18n::Backend::LazyLoadable
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
  MUTEX = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def eager_load!(); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, _locale=T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def interpolation_keys(key, **options); end

  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(key=T.unsafe(nil), throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def t!(key, **options); end

  def translate(key=T.unsafe(nil), throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def translate!(key, **options); end

  def transliterate(key, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def interpolation_patterns(); end

  def interpolation_patterns=(interpolation_patterns); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Config
end

class I18n::Disabled
  def initialize(method); end
end

class I18n::Disabled
end

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

class I18n::InvalidFilenames
  def initialize(file_errors); end
  NUMBER_OF_ERRORS_SHOWN = ::T.let(nil, ::T.untyped)
end

class I18n::InvalidFilenames
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(*args, &block); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def normalized_option(key); end

  def options(); end

  def to_exception(); end

  def to_s(); end
  PERMITTED_KEYS = ::T.let(nil, ::T.untyped)
end

module I18n::MissingTranslation::Base
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

class I18n::UnsupportedMethod
  def backend_klass(); end

  def initialize(method, backend_klass, msg); end

  def method(); end

  def msg(); end
end

class I18n::UnsupportedMethod
end

module I18n::Utils
end

module I18n::Utils
  def self.deep_merge(hash, other_hash, &block); end

  def self.deep_merge!(hash, other_hash, &block); end

  def self.deep_symbolize_keys(hash); end

  def self.except(hash, *keys); end
end

module I18n
  extend ::I18n::Base
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end

  def self.reserve_key(key); end

  def self.reserved_keys_pattern(); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(arg); end

  def cursor_left(arg); end

  def cursor_right(arg); end

  def cursor_up(arg); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(arg); end

  def erase_screen(arg); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(arg, arg1); end

  def goto_column(arg); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def path(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def scroll_backward(arg); end

  def scroll_forward(arg); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(*arg); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def private?(); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end

  def self.string(arg); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*arg); end

  def raw!(*arg); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO::TimeoutError
end

class IO::TimeoutError
end

class IO
  def self.console(*arg); end

  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def begin_addr(); end

  def end_addr(); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def ceildiv(other); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def allow_nan=(allow_nan); end

  def ascii_only=(ascii_only); end

  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end

  def self.generate(arg, arg1, arg2); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

class JSON::Ext::Parser
  def self.parse(arg, arg1); end
end

class JSON::GeneratorError
  def detailed_message(*arg, **arg1, &arg2); end

  def initialize(message, invalid_object=T.unsafe(nil)); end

  def invalid_object(); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end

  def self.unsafe_load(source, proc=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load_default_options(); end

  def self.unsafe_load_default_options=(unsafe_load_default_options); end
end

module Kernel
  def Namespace(name); end

  def TypeName(string); end

  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.no_warning_require(arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module LanguageServer::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant
end

module LanguageServer::Protocol::Constant::CodeActionKind
  EMPTY = ::T.let(nil, ::T.untyped)
  QUICK_FIX = ::T.let(nil, ::T.untyped)
  REFACTOR = ::T.let(nil, ::T.untyped)
  REFACTOR_EXTRACT = ::T.let(nil, ::T.untyped)
  REFACTOR_INLINE = ::T.let(nil, ::T.untyped)
  REFACTOR_REWRITE = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SOURCE_FIX_ALL = ::T.let(nil, ::T.untyped)
  SOURCE_ORGANIZE_IMPORTS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionKind
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
  AUTOMATIC = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
end

module LanguageServer::Protocol::Constant::CompletionItemKind
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemKind
end

module LanguageServer::Protocol::Constant::CompletionItemTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemTag
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
  TRIGGER_FOR_INCOMPLETE_COMPLETIONS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
end

module LanguageServer::Protocol::Constant::DiagnosticTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
  UNNECESSARY = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticTag
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
  FULL = ::T.let(nil, ::T.untyped)
  UNCHANGED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
  READ = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
end

module LanguageServer::Protocol::Constant::ErrorCodes
  CONTENT_MODIFIED = ::T.let(nil, ::T.untyped)
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  REQUEST_FAILED = ::T.let(nil, ::T.untyped)
  SERVER_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ErrorCodes
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
  ABORT = ::T.let(nil, ::T.untyped)
  TEXT_ONLY_TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  UNDO = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
end

module LanguageServer::Protocol::Constant::FileChangeType
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileChangeType
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
  COMMENT = ::T.let(nil, ::T.untyped)
  IMPORTS = ::T.let(nil, ::T.untyped)
  REGION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
  UNKNOWN_PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
end

module LanguageServer::Protocol::Constant::InlayHintKind
  PARAMETER = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InlayHintKind
end

module LanguageServer::Protocol::Constant::InsertTextFormat
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextFormat
end

module LanguageServer::Protocol::Constant::InsertTextMode
  ADJUST_INDENTATION = ::T.let(nil, ::T.untyped)
  AS_IS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextMode
end

module LanguageServer::Protocol::Constant::MarkupKind
  MARKDOWN = ::T.let(nil, ::T.untyped)
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MarkupKind
end

module LanguageServer::Protocol::Constant::MessageType
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MessageType
end

module LanguageServer::Protocol::Constant::MonikerKind
  EXPORT = ::T.let(nil, ::T.untyped)
  IMPORT = ::T.let(nil, ::T.untyped)
  LOCAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MonikerKind
end

module LanguageServer::Protocol::Constant::NotebookCellKind
  CODE = ::T.let(nil, ::T.untyped)
  MARKUP = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::NotebookCellKind
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
  IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  RENAME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
  ABSTRACT = ::T.let(nil, ::T.untyped)
  ASYNC = ::T.let(nil, ::T.untyped)
  DECLARATION = ::T.let(nil, ::T.untyped)
  DEFAULT_LIBRARY = ::T.let(nil, ::T.untyped)
  DEFINITION = ::T.let(nil, ::T.untyped)
  DEPRECATED = ::T.let(nil, ::T.untyped)
  DOCUMENTATION = ::T.let(nil, ::T.untyped)
  MODIFICATION = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  STATIC = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
  CLASS = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DECORATOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  MACRO = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
  CONTENT_CHANGE = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
end

module LanguageServer::Protocol::Constant::SymbolKind
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolKind
end

module LanguageServer::Protocol::Constant::SymbolTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolTag
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
  AFTER_DELAY = ::T.let(nil, ::T.untyped)
  FOCUS_OUT = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
  FULL = ::T.let(nil, ::T.untyped)
  INCREMENTAL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
end

module LanguageServer::Protocol::Constant::TokenFormat
  RELATIVE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TokenFormat
end

module LanguageServer::Protocol::Constant::UniquenessLevel
  DOCUMENT = ::T.let(nil, ::T.untyped)
  GLOBAL = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  PROJECT = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::UniquenessLevel
end

module LanguageServer::Protocol::Constant::WatchKind
  CHANGE = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::WatchKind
end

module LanguageServer::Protocol::Constant
end

module LanguageServer::Protocol::Interface
end

class LanguageServer::Protocol::Interface::AnnotatedTextEdit
  def annotation_id(); end

  def attributes(); end

  def initialize(range:, new_text:, annotation_id:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::AnnotatedTextEdit
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
  def attributes(); end

  def edit(); end

  def initialize(edit:, label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResult
  def applied(); end

  def attributes(); end

  def failed_change(); end

  def failure_reason(); end

  def initialize(applied:, failure_reason: T.unsafe(nil), failed_change: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResult
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
  def attributes(); end

  def from(); end

  def from_ranges(); end

  def initialize(from:, from_ranges:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
  def attributes(); end

  def from_ranges(); end

  def initialize(to:, from_ranges:); end

  def to(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
end

class LanguageServer::Protocol::Interface::CancelParams
  def attributes(); end

  def id(); end

  def initialize(id:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CancelParams
end

class LanguageServer::Protocol::Interface::ChangeAnnotation
  def attributes(); end

  def description(); end

  def initialize(label:, needs_confirmation: T.unsafe(nil), description: T.unsafe(nil)); end

  def label(); end

  def needs_confirmation(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ChangeAnnotation
end

class LanguageServer::Protocol::Interface::ClientCapabilities
  def attributes(); end

  def experimental(); end

  def general(); end

  def initialize(workspace: T.unsafe(nil), text_document: T.unsafe(nil), notebook_document: T.unsafe(nil), window: T.unsafe(nil), general: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def notebook_document(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def window(); end

  def workspace(); end
end

class LanguageServer::Protocol::Interface::ClientCapabilities
end

class LanguageServer::Protocol::Interface::CodeAction
  def attributes(); end

  def command(); end

  def data(); end

  def diagnostics(); end

  def disabled(); end

  def edit(); end

  def initialize(title:, kind: T.unsafe(nil), diagnostics: T.unsafe(nil), is_preferred: T.unsafe(nil), disabled: T.unsafe(nil), edit: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def is_preferred(); end

  def kind(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeAction
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
  def attributes(); end

  def code_action_literal_support(); end

  def data_support(); end

  def disabled_support(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), code_action_literal_support: T.unsafe(nil), is_preferred_support: T.unsafe(nil), disabled_support: T.unsafe(nil), data_support: T.unsafe(nil), resolve_support: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def is_preferred_support(); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
end

class LanguageServer::Protocol::Interface::CodeActionContext
  def attributes(); end

  def diagnostics(); end

  def initialize(diagnostics:, only: T.unsafe(nil), trigger_kind: T.unsafe(nil)); end

  def only(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CodeActionContext
end

class LanguageServer::Protocol::Interface::CodeActionOptions
  def attributes(); end

  def code_action_kinds(); end

  def initialize(work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeActionOptions
end

class LanguageServer::Protocol::Interface::CodeActionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeActionParams
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
  def attributes(); end

  def code_action_kinds(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
end

class LanguageServer::Protocol::Interface::CodeDescription
  def attributes(); end

  def href(); end

  def initialize(href:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeDescription
end

class LanguageServer::Protocol::Interface::CodeLens
  def attributes(); end

  def command(); end

  def data(); end

  def initialize(range:, command: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLens
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
end

class LanguageServer::Protocol::Interface::CodeLensOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensOptions
end

class LanguageServer::Protocol::Interface::CodeLensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeLensParams
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::Color
  def alpha(); end

  def attributes(); end

  def blue(); end

  def green(); end

  def initialize(red:, green:, blue:, alpha:); end

  def red(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Color
end

class LanguageServer::Protocol::Interface::ColorInformation
  def attributes(); end

  def color(); end

  def initialize(range:, color:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorInformation
end

class LanguageServer::Protocol::Interface::ColorPresentation
  def additional_text_edits(); end

  def attributes(); end

  def initialize(label:, text_edit: T.unsafe(nil), additional_text_edits: T.unsafe(nil)); end

  def label(); end

  def text_edit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentation
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
  def attributes(); end

  def color(); end

  def initialize(text_document:, color:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
end

class LanguageServer::Protocol::Interface::Command
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(title:, command:, arguments: T.unsafe(nil)); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Command
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
  def attributes(); end

  def completion_item(); end

  def completion_item_kind(); end

  def completion_list(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), completion_item: T.unsafe(nil), completion_item_kind: T.unsafe(nil), context_support: T.unsafe(nil), insert_text_mode: T.unsafe(nil), completion_list: T.unsafe(nil)); end

  def insert_text_mode(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
end

class LanguageServer::Protocol::Interface::CompletionContext
  def attributes(); end

  def initialize(trigger_kind:, trigger_character: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CompletionContext
end

class LanguageServer::Protocol::Interface::CompletionItem
  def additional_text_edits(); end

  def attributes(); end

  def command(); end

  def commit_characters(); end

  def data(); end

  def deprecated(); end

  def detail(); end

  def documentation(); end

  def filter_text(); end

  def initialize(label:, label_details: T.unsafe(nil), kind: T.unsafe(nil), tags: T.unsafe(nil), detail: T.unsafe(nil), documentation: T.unsafe(nil), deprecated: T.unsafe(nil), preselect: T.unsafe(nil), sort_text: T.unsafe(nil), filter_text: T.unsafe(nil), insert_text: T.unsafe(nil), insert_text_format: T.unsafe(nil), insert_text_mode: T.unsafe(nil), text_edit: T.unsafe(nil), text_edit_text: T.unsafe(nil), additional_text_edits: T.unsafe(nil), commit_characters: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def insert_text(); end

  def insert_text_format(); end

  def insert_text_mode(); end

  def kind(); end

  def label(); end

  def label_details(); end

  def preselect(); end

  def sort_text(); end

  def tags(); end

  def text_edit(); end

  def text_edit_text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionItem
end

class LanguageServer::Protocol::Interface::CompletionItemLabelDetails
  def attributes(); end

  def description(); end

  def detail(); end

  def initialize(detail: T.unsafe(nil), description: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionItemLabelDetails
end

class LanguageServer::Protocol::Interface::CompletionList
  def attributes(); end

  def initialize(is_incomplete:, items:, item_defaults: T.unsafe(nil)); end

  def is_incomplete(); end

  def item_defaults(); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionList
end

class LanguageServer::Protocol::Interface::CompletionOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CompletionOptions
end

class LanguageServer::Protocol::Interface::CompletionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CompletionParams
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
end

class LanguageServer::Protocol::Interface::ConfigurationItem
  def attributes(); end

  def initialize(scope_uri: T.unsafe(nil), section: T.unsafe(nil)); end

  def scope_uri(); end

  def section(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationItem
end

class LanguageServer::Protocol::Interface::ConfigurationParams
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationParams
end

class LanguageServer::Protocol::Interface::CreateFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CreateFile
end

class LanguageServer::Protocol::Interface::CreateFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFileOptions
end

class LanguageServer::Protocol::Interface::CreateFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFilesParams
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
end

class LanguageServer::Protocol::Interface::DeclarationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeclarationOptions
end

class LanguageServer::Protocol::Interface::DeclarationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DeclarationParams
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
end

class LanguageServer::Protocol::Interface::DefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionOptions
end

class LanguageServer::Protocol::Interface::DefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DefinitionParams
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
end

class LanguageServer::Protocol::Interface::DeleteFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::DeleteFile
end

class LanguageServer::Protocol::Interface::DeleteFileOptions
  def attributes(); end

  def ignore_if_not_exists(); end

  def initialize(recursive: T.unsafe(nil), ignore_if_not_exists: T.unsafe(nil)); end

  def recursive(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeleteFileOptions
end

class LanguageServer::Protocol::Interface::DeleteFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeleteFilesParams
end

class LanguageServer::Protocol::Interface::Diagnostic
  def attributes(); end

  def code(); end

  def code_description(); end

  def data(); end

  def initialize(range:, message:, severity: T.unsafe(nil), code: T.unsafe(nil), code_description: T.unsafe(nil), source: T.unsafe(nil), tags: T.unsafe(nil), related_information: T.unsafe(nil), data: T.unsafe(nil)); end

  def message(); end

  def range(); end

  def related_information(); end

  def severity(); end

  def source(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Diagnostic
end

class LanguageServer::Protocol::Interface::DiagnosticClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), related_document_support: T.unsafe(nil)); end

  def related_document_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticClientCapabilities
end

class LanguageServer::Protocol::Interface::DiagnosticOptions
  def attributes(); end

  def identifier(); end

  def initialize(inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticOptions
end

class LanguageServer::Protocol::Interface::DiagnosticRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def identifier(); end

  def initialize(document_selector:, inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil), id: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticRegistrationOptions
end

class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
  def attributes(); end

  def initialize(location:, message:); end

  def location(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
end

class LanguageServer::Protocol::Interface::DiagnosticServerCancellationData
  def attributes(); end

  def initialize(retrigger_request:); end

  def retrigger_request(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticServerCancellationData
end

class LanguageServer::Protocol::Interface::DiagnosticWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
  def attributes(); end

  def initialize(settings:); end

  def settings(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
end

class LanguageServer::Protocol::Interface::DidChangeNotebookDocumentParams
  def attributes(); end

  def change(); end

  def initialize(notebook_document:, change:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
  def attributes(); end

  def content_changes(); end

  def initialize(text_document:, content_changes:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), relative_pattern_support: T.unsafe(nil)); end

  def relative_pattern_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
  def attributes(); end

  def changes(); end

  def initialize(changes:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
  def attributes(); end

  def initialize(watchers:); end

  def to_hash(); end

  def to_json(*args); end

  def watchers(); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
  def attributes(); end

  def event(); end

  def initialize(event:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
end

class LanguageServer::Protocol::Interface::DidCloseNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
end

class LanguageServer::Protocol::Interface::DidOpenNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
end

class LanguageServer::Protocol::Interface::DidSaveNotebookDocumentParams
  def attributes(); end

  def initialize(notebook_document:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, text: T.unsafe(nil)); end

  def text(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
end

class LanguageServer::Protocol::Interface::DocumentColorParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentColorParams
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, id: T.unsafe(nil), work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil), previous_result_id: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticParams
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticReportPartialResult
  def attributes(); end

  def initialize(related_documents:); end

  def related_documents(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticReportPartialResult
end

class LanguageServer::Protocol::Interface::DocumentFilter
  def attributes(); end

  def initialize(language: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def language(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFilter
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
  def attributes(); end

  def initialize(text_document:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentHighlight
  def attributes(); end

  def initialize(range:, kind: T.unsafe(nil)); end

  def kind(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlight
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentLink
  def attributes(); end

  def data(); end

  def initialize(range:, target: T.unsafe(nil), tooltip: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def target(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::DocumentLink
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), tooltip_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip_support(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
  def attributes(); end

  def first_trigger_character(); end

  def initialize(first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
  def attributes(); end

  def ch(); end

  def initialize(text_document:, position:, ch:, options:); end

  def options(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def first_trigger_character(); end

  def initialize(document_selector:, first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
  def attributes(); end

  def initialize(text_document:, range:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentSymbol
  def attributes(); end

  def children(); end

  def deprecated(); end

  def detail(); end

  def initialize(name:, kind:, range:, selection_range:, detail: T.unsafe(nil), tags: T.unsafe(nil), deprecated: T.unsafe(nil), children: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbol
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def hierarchical_document_symbol_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), hierarchical_document_symbol_support: T.unsafe(nil), tag_support: T.unsafe(nil), label_support: T.unsafe(nil)); end

  def label_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(command:, work_done_token: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
end

class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
end

class LanguageServer::Protocol::Interface::ExecutionSummary
  def attributes(); end

  def execution_order(); end

  def initialize(execution_order:, success: T.unsafe(nil)); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecutionSummary
end

class LanguageServer::Protocol::Interface::FileCreate
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileCreate
end

class LanguageServer::Protocol::Interface::FileDelete
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileDelete
end

class LanguageServer::Protocol::Interface::FileEvent
  def attributes(); end

  def initialize(uri:, type:); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileEvent
end

class LanguageServer::Protocol::Interface::FileOperationFilter
  def attributes(); end

  def initialize(pattern:, scheme: T.unsafe(nil)); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationFilter
end

class LanguageServer::Protocol::Interface::FileOperationPattern
  def attributes(); end

  def glob(); end

  def initialize(glob:, matches: T.unsafe(nil), options: T.unsafe(nil)); end

  def matches(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPattern
end

class LanguageServer::Protocol::Interface::FileOperationPatternOptions
  def attributes(); end

  def ignore_case(); end

  def initialize(ignore_case: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPatternOptions
end

class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
  def attributes(); end

  def filters(); end

  def initialize(filters:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
end

class LanguageServer::Protocol::Interface::FileRename
  def attributes(); end

  def initialize(old_uri:, new_uri:); end

  def new_uri(); end

  def old_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileRename
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
  def attributes(); end

  def glob_pattern(); end

  def initialize(glob_pattern:, kind: T.unsafe(nil)); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
end

class LanguageServer::Protocol::Interface::FoldingRange
  def attributes(); end

  def collapsed_text(); end

  def end_character(); end

  def end_line(); end

  def initialize(start_line:, end_line:, start_character: T.unsafe(nil), end_character: T.unsafe(nil), kind: T.unsafe(nil), collapsed_text: T.unsafe(nil)); end

  def kind(); end

  def start_character(); end

  def start_line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRange
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def folding_range(); end

  def folding_range_kind(); end

  def initialize(dynamic_registration: T.unsafe(nil), range_limit: T.unsafe(nil), line_folding_only: T.unsafe(nil), folding_range_kind: T.unsafe(nil), folding_range: T.unsafe(nil)); end

  def line_folding_only(); end

  def range_limit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::FormattingOptions
  def attributes(); end

  def initialize(tab_size:, insert_spaces:, trim_trailing_whitespace: T.unsafe(nil), insert_final_newline: T.unsafe(nil), trim_final_newlines: T.unsafe(nil)); end

  def insert_final_newline(); end

  def insert_spaces(); end

  def tab_size(); end

  def to_hash(); end

  def to_json(*args); end

  def trim_final_newlines(); end

  def trim_trailing_whitespace(); end
end

class LanguageServer::Protocol::Interface::FormattingOptions
end

class LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::Hover
  def attributes(); end

  def contents(); end

  def initialize(contents:, range: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Hover
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
  def attributes(); end

  def content_format(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), content_format: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
end

class LanguageServer::Protocol::Interface::HoverOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverOptions
end

class LanguageServer::Protocol::Interface::HoverParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::HoverParams
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
end

class LanguageServer::Protocol::Interface::HoverResult
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::HoverResult
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
end

class LanguageServer::Protocol::Interface::ImplementationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ImplementationOptions
end

class LanguageServer::Protocol::Interface::ImplementationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ImplementationParams
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
end

class LanguageServer::Protocol::Interface::InitializeError
  def attributes(); end

  def initialize(retry:); end

  def retry(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeError
end

class LanguageServer::Protocol::Interface::InitializeParams
  def attributes(); end

  def capabilities(); end

  def client_info(); end

  def initialization_options(); end

  def initialize(process_id:, root_uri:, capabilities:, work_done_token: T.unsafe(nil), client_info: T.unsafe(nil), locale: T.unsafe(nil), root_path: T.unsafe(nil), initialization_options: T.unsafe(nil), trace: T.unsafe(nil), workspace_folders: T.unsafe(nil)); end

  def locale(); end

  def process_id(); end

  def root_path(); end

  def root_uri(); end

  def to_hash(); end

  def to_json(*args); end

  def trace(); end

  def work_done_token(); end

  def workspace_folders(); end
end

class LanguageServer::Protocol::Interface::InitializeParams
end

class LanguageServer::Protocol::Interface::InitializeResult
  def attributes(); end

  def capabilities(); end

  def initialize(capabilities:, server_info: T.unsafe(nil)); end

  def server_info(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeResult
end

class LanguageServer::Protocol::Interface::InitializedParams
  def attributes(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializedParams
end

class LanguageServer::Protocol::Interface::InlayHint
  def attributes(); end

  def data(); end

  def initialize(position:, label:, kind: T.unsafe(nil), text_edits: T.unsafe(nil), tooltip: T.unsafe(nil), padding_left: T.unsafe(nil), padding_right: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def label(); end

  def padding_left(); end

  def padding_right(); end

  def position(); end

  def text_edits(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::InlayHint
end

class LanguageServer::Protocol::Interface::InlayHintClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHintClientCapabilities
end

class LanguageServer::Protocol::Interface::InlayHintLabelPart
  def attributes(); end

  def command(); end

  def initialize(value:, tooltip: T.unsafe(nil), location: T.unsafe(nil), command: T.unsafe(nil)); end

  def location(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::InlayHintLabelPart
end

class LanguageServer::Protocol::Interface::InlayHintOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintOptions
end

class LanguageServer::Protocol::Interface::InlayHintParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlayHintParams
end

class LanguageServer::Protocol::Interface::InlayHintRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil), id: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintRegistrationOptions
end

class LanguageServer::Protocol::Interface::InlayHintWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHintWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::InlineValueClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueClientCapabilities
end

class LanguageServer::Protocol::Interface::InlineValueContext
  def attributes(); end

  def frame_id(); end

  def initialize(frame_id:, stopped_location:); end

  def stopped_location(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueContext
end

class LanguageServer::Protocol::Interface::InlineValueEvaluatableExpression
  def attributes(); end

  def expression(); end

  def initialize(range:, expression: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueEvaluatableExpression
end

class LanguageServer::Protocol::Interface::InlineValueOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueOptions
end

class LanguageServer::Protocol::Interface::InlineValueParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlineValueParams
end

class LanguageServer::Protocol::Interface::InlineValueRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueRegistrationOptions
end

class LanguageServer::Protocol::Interface::InlineValueText
  def attributes(); end

  def initialize(range:, text:); end

  def range(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueText
end

class LanguageServer::Protocol::Interface::InlineValueVariableLookup
  def attributes(); end

  def case_sensitive_lookup(); end

  def initialize(range:, case_sensitive_lookup:, variable_name: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def variable_name(); end
end

class LanguageServer::Protocol::Interface::InlineValueVariableLookup
end

class LanguageServer::Protocol::Interface::InlineValueWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::InsertReplaceEdit
  def attributes(); end

  def initialize(new_text:, insert:, replace:); end

  def insert(); end

  def new_text(); end

  def replace(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InsertReplaceEdit
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
  def attributes(); end

  def initialize(ranges:, word_pattern: T.unsafe(nil)); end

  def ranges(); end

  def to_hash(); end

  def to_json(*args); end

  def word_pattern(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
end

class LanguageServer::Protocol::Interface::Location
  def attributes(); end

  def initialize(uri:, range:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::Location
end

class LanguageServer::Protocol::Interface::LocationLink
  def attributes(); end

  def initialize(target_uri:, target_range:, target_selection_range:, origin_selection_range: T.unsafe(nil)); end

  def origin_selection_range(); end

  def target_range(); end

  def target_selection_range(); end

  def target_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LocationLink
end

class LanguageServer::Protocol::Interface::LogMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::LogMessageParams
end

class LanguageServer::Protocol::Interface::LogTraceParams
  def attributes(); end

  def initialize(message:, verbose: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def verbose(); end
end

class LanguageServer::Protocol::Interface::LogTraceParams
end

class LanguageServer::Protocol::Interface::MarkupContent
  def attributes(); end

  def initialize(kind:, value:); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::MarkupContent
end

class LanguageServer::Protocol::Interface::Message
  def attributes(); end

  def initialize(jsonrpc:); end

  def jsonrpc(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Message
end

class LanguageServer::Protocol::Interface::MessageActionItem
  def attributes(); end

  def initialize(title:); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MessageActionItem
end

class LanguageServer::Protocol::Interface::Moniker
  def attributes(); end

  def identifier(); end

  def initialize(scheme:, identifier:, unique:, kind: T.unsafe(nil)); end

  def kind(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end

  def unique(); end
end

class LanguageServer::Protocol::Interface::Moniker
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
end

class LanguageServer::Protocol::Interface::MonikerOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::MonikerOptions
end

class LanguageServer::Protocol::Interface::MonikerParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::MonikerParams
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
end

class LanguageServer::Protocol::Interface::NotebookCell
  def attributes(); end

  def document(); end

  def execution_summary(); end

  def initialize(kind:, document:, metadata: T.unsafe(nil), execution_summary: T.unsafe(nil)); end

  def kind(); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCell
end

class LanguageServer::Protocol::Interface::NotebookCellArrayChange
  def attributes(); end

  def cells(); end

  def delete_count(); end

  def initialize(start:, delete_count:, cells: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellArrayChange
end

class LanguageServer::Protocol::Interface::NotebookCellTextDocumentFilter
  def attributes(); end

  def initialize(notebook:, language: T.unsafe(nil)); end

  def language(); end

  def notebook(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellTextDocumentFilter
end

class LanguageServer::Protocol::Interface::NotebookDocument
  def attributes(); end

  def cells(); end

  def initialize(uri:, notebook_type:, version:, cells:, metadata: T.unsafe(nil)); end

  def metadata(); end

  def notebook_type(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::NotebookDocument
end

class LanguageServer::Protocol::Interface::NotebookDocumentChangeEvent
  def attributes(); end

  def cells(); end

  def initialize(metadata: T.unsafe(nil), cells: T.unsafe(nil)); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentChangeEvent
end

class LanguageServer::Protocol::Interface::NotebookDocumentClientCapabilities
  def attributes(); end

  def initialize(synchronization:); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentClientCapabilities
end

class LanguageServer::Protocol::Interface::NotebookDocumentFilter
  def attributes(); end

  def initialize(notebook_type: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def notebook_type(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentFilter
end

class LanguageServer::Protocol::Interface::NotebookDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentIdentifier
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def execution_summary_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), execution_summary_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncClientCapabilities
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncOptions
  def attributes(); end

  def initialize(notebook_selector:, save: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncOptions
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(notebook_selector:, save: T.unsafe(nil), id: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncRegistrationOptions
end

class LanguageServer::Protocol::Interface::NotificationMessage
  def attributes(); end

  def initialize(jsonrpc:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotificationMessage
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
end

class LanguageServer::Protocol::Interface::ParameterInformation
  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ParameterInformation
end

class LanguageServer::Protocol::Interface::PartialResultParams
  def attributes(); end

  def initialize(partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PartialResultParams
end

class LanguageServer::Protocol::Interface::Position
  def attributes(); end

  def character(); end

  def initialize(line:, character:); end

  def line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Position
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
end

class LanguageServer::Protocol::Interface::PreviousResultId
  def attributes(); end

  def initialize(uri:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::PreviousResultId
end

class LanguageServer::Protocol::Interface::ProgressParams
  def attributes(); end

  def initialize(token:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ProgressParams
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
  def attributes(); end

  def code_description_support(); end

  def data_support(); end

  def initialize(related_information: T.unsafe(nil), tag_support: T.unsafe(nil), version_support: T.unsafe(nil), code_description_support: T.unsafe(nil), data_support: T.unsafe(nil)); end

  def related_information(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end

  def version_support(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
  def attributes(); end

  def diagnostics(); end

  def initialize(uri:, diagnostics:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
end

class LanguageServer::Protocol::Interface::Range
  def attributes(); end

  def end(); end

  def initialize(start:, end:); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Range
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
end

class LanguageServer::Protocol::Interface::ReferenceContext
  def attributes(); end

  def include_declaration(); end

  def initialize(include_declaration:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceContext
end

class LanguageServer::Protocol::Interface::ReferenceOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ReferenceOptions
end

class LanguageServer::Protocol::Interface::ReferenceParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ReferenceParams
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
end

class LanguageServer::Protocol::Interface::Registration
  def attributes(); end

  def id(); end

  def initialize(id:, method:, register_options: T.unsafe(nil)); end

  def method(); end

  def register_options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Registration
end

class LanguageServer::Protocol::Interface::RegistrationParams
  def attributes(); end

  def initialize(registrations:); end

  def registrations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegistrationParams
end

class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
  def attributes(); end

  def engine(); end

  def initialize(engine:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def version(); end
end

class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
end

class LanguageServer::Protocol::Interface::RelatedFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil), related_documents: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelatedFullDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::RelatedUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, related_documents: T.unsafe(nil)); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelatedUnchangedDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::RelativePattern
  def attributes(); end

  def base_uri(); end

  def initialize(base_uri:, pattern:); end

  def pattern(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelativePattern
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), prepare_support: T.unsafe(nil), prepare_support_default_behavior: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def prepare_support(); end

  def prepare_support_default_behavior(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
end

class LanguageServer::Protocol::Interface::RenameFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, old_uri:, new_uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def new_uri(); end

  def old_uri(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFile
end

class LanguageServer::Protocol::Interface::RenameFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFileOptions
end

class LanguageServer::Protocol::Interface::RenameFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFilesParams
end

class LanguageServer::Protocol::Interface::RenameOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RenameOptions
end

class LanguageServer::Protocol::Interface::RenameParams
  def attributes(); end

  def initialize(text_document:, position:, new_name:, work_done_token: T.unsafe(nil)); end

  def new_name(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::RenameParams
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
end

class LanguageServer::Protocol::Interface::RequestMessage
  def attributes(); end

  def id(); end

  def initialize(jsonrpc:, id:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RequestMessage
end

class LanguageServer::Protocol::Interface::ResponseError
  def attributes(); end

  def code(); end

  def data(); end

  def initialize(code:, message:, data: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseError
end

class LanguageServer::Protocol::Interface::ResponseMessage
  def attributes(); end

  def error(); end

  def id(); end

  def initialize(jsonrpc:, id:, result: T.unsafe(nil), error: T.unsafe(nil)); end

  def jsonrpc(); end

  def result(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseMessage
end

class LanguageServer::Protocol::Interface::SaveOptions
  def attributes(); end

  def include_text(); end

  def initialize(include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SaveOptions
end

class LanguageServer::Protocol::Interface::SelectionRange
  def attributes(); end

  def initialize(range:, parent: T.unsafe(nil)); end

  def parent(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRange
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
  def attributes(); end

  def initialize(text_document:, positions:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def positions(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::SemanticTokens
  def attributes(); end

  def data(); end

  def initialize(data:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokens
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
  def attributes(); end

  def augments_syntax_tokens(); end

  def dynamic_registration(); end

  def formats(); end

  def initialize(requests:, token_types:, token_modifiers:, formats:, dynamic_registration: T.unsafe(nil), overlapping_token_support: T.unsafe(nil), multiline_token_support: T.unsafe(nil), server_cancel_support: T.unsafe(nil), augments_syntax_tokens: T.unsafe(nil)); end

  def multiline_token_support(); end

  def overlapping_token_support(); end

  def requests(); end

  def server_cancel_support(); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
  def attributes(); end

  def edits(); end

  def initialize(edits:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
  def attributes(); end

  def initialize(text_document:, previous_result_id:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
  def attributes(); end

  def edits(); end

  def initialize(edits:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
  def attributes(); end

  def data(); end

  def delete_count(); end

  def initialize(start:, delete_count:, data: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
  def attributes(); end

  def initialize(token_types:, token_modifiers:); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
  def attributes(); end

  def full(); end

  def initialize(legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
  def attributes(); end

  def data(); end

  def initialize(data:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def full(); end

  def id(); end

  def initialize(document_selector:, legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil), id: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::ServerCapabilities
  def attributes(); end

  def call_hierarchy_provider(); end

  def code_action_provider(); end

  def code_lens_provider(); end

  def color_provider(); end

  def completion_provider(); end

  def declaration_provider(); end

  def definition_provider(); end

  def diagnostic_provider(); end

  def document_formatting_provider(); end

  def document_highlight_provider(); end

  def document_link_provider(); end

  def document_on_type_formatting_provider(); end

  def document_range_formatting_provider(); end

  def document_symbol_provider(); end

  def execute_command_provider(); end

  def experimental(); end

  def folding_range_provider(); end

  def hover_provider(); end

  def implementation_provider(); end

  def initialize(position_encoding: T.unsafe(nil), text_document_sync: T.unsafe(nil), notebook_document_sync: T.unsafe(nil), completion_provider: T.unsafe(nil), hover_provider: T.unsafe(nil), signature_help_provider: T.unsafe(nil), declaration_provider: T.unsafe(nil), definition_provider: T.unsafe(nil), type_definition_provider: T.unsafe(nil), implementation_provider: T.unsafe(nil), references_provider: T.unsafe(nil), document_highlight_provider: T.unsafe(nil), document_symbol_provider: T.unsafe(nil), code_action_provider: T.unsafe(nil), code_lens_provider: T.unsafe(nil), document_link_provider: T.unsafe(nil), color_provider: T.unsafe(nil), document_formatting_provider: T.unsafe(nil), document_range_formatting_provider: T.unsafe(nil), document_on_type_formatting_provider: T.unsafe(nil), rename_provider: T.unsafe(nil), folding_range_provider: T.unsafe(nil), execute_command_provider: T.unsafe(nil), selection_range_provider: T.unsafe(nil), linked_editing_range_provider: T.unsafe(nil), call_hierarchy_provider: T.unsafe(nil), semantic_tokens_provider: T.unsafe(nil), moniker_provider: T.unsafe(nil), type_hierarchy_provider: T.unsafe(nil), inline_value_provider: T.unsafe(nil), inlay_hint_provider: T.unsafe(nil), diagnostic_provider: T.unsafe(nil), workspace_symbol_provider: T.unsafe(nil), workspace: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def inlay_hint_provider(); end

  def inline_value_provider(); end

  def linked_editing_range_provider(); end

  def moniker_provider(); end

  def notebook_document_sync(); end

  def position_encoding(); end

  def references_provider(); end

  def rename_provider(); end

  def selection_range_provider(); end

  def semantic_tokens_provider(); end

  def signature_help_provider(); end

  def text_document_sync(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition_provider(); end

  def type_hierarchy_provider(); end

  def workspace(); end

  def workspace_symbol_provider(); end
end

class LanguageServer::Protocol::Interface::ServerCapabilities
end

class LanguageServer::Protocol::Interface::SetTraceParams
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::SetTraceParams
end

class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
  def attributes(); end

  def initialize(support:); end

  def support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
end

class LanguageServer::Protocol::Interface::ShowDocumentParams
  def attributes(); end

  def external(); end

  def initialize(uri:, external: T.unsafe(nil), take_focus: T.unsafe(nil), selection: T.unsafe(nil)); end

  def selection(); end

  def take_focus(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::ShowDocumentParams
end

class LanguageServer::Protocol::Interface::ShowDocumentResult
  def attributes(); end

  def initialize(success:); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowDocumentResult
end

class LanguageServer::Protocol::Interface::ShowMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::ShowMessageParams
end

class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
  def attributes(); end

  def initialize(message_action_item: T.unsafe(nil)); end

  def message_action_item(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
  def actions(); end

  def attributes(); end

  def initialize(type:, message:, actions: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
end

class LanguageServer::Protocol::Interface::SignatureHelp
  def active_parameter(); end

  def active_signature(); end

  def attributes(); end

  def initialize(signatures:, active_signature: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def signatures(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelp
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
  def attributes(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), signature_information: T.unsafe(nil), context_support: T.unsafe(nil)); end

  def signature_information(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
end

class LanguageServer::Protocol::Interface::SignatureHelpContext
  def active_signature_help(); end

  def attributes(); end

  def initialize(trigger_kind:, is_retrigger:, trigger_character: T.unsafe(nil), active_signature_help: T.unsafe(nil)); end

  def is_retrigger(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpContext
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
end

class LanguageServer::Protocol::Interface::SignatureInformation
  def active_parameter(); end

  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil), parameters: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def label(); end

  def parameters(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureInformation
end

class LanguageServer::Protocol::Interface::StaticRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::StaticRegistrationOptions
end

class LanguageServer::Protocol::Interface::SymbolInformation
  def attributes(); end

  def container_name(); end

  def deprecated(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), deprecated: T.unsafe(nil), container_name: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SymbolInformation
end

class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, sync_kind:); end

  def sync_kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
  def attributes(); end

  def call_hierarchy(); end

  def code_action(); end

  def code_lens(); end

  def color_provider(); end

  def completion(); end

  def declaration(); end

  def definition(); end

  def diagnostic(); end

  def document_highlight(); end

  def document_link(); end

  def document_symbol(); end

  def folding_range(); end

  def formatting(); end

  def hover(); end

  def implementation(); end

  def initialize(synchronization: T.unsafe(nil), completion: T.unsafe(nil), hover: T.unsafe(nil), signature_help: T.unsafe(nil), declaration: T.unsafe(nil), definition: T.unsafe(nil), type_definition: T.unsafe(nil), implementation: T.unsafe(nil), references: T.unsafe(nil), document_highlight: T.unsafe(nil), document_symbol: T.unsafe(nil), code_action: T.unsafe(nil), code_lens: T.unsafe(nil), document_link: T.unsafe(nil), color_provider: T.unsafe(nil), formatting: T.unsafe(nil), range_formatting: T.unsafe(nil), on_type_formatting: T.unsafe(nil), rename: T.unsafe(nil), publish_diagnostics: T.unsafe(nil), folding_range: T.unsafe(nil), selection_range: T.unsafe(nil), linked_editing_range: T.unsafe(nil), call_hierarchy: T.unsafe(nil), semantic_tokens: T.unsafe(nil), moniker: T.unsafe(nil), type_hierarchy: T.unsafe(nil), inline_value: T.unsafe(nil), inlay_hint: T.unsafe(nil), diagnostic: T.unsafe(nil)); end

  def inlay_hint(); end

  def inline_value(); end

  def linked_editing_range(); end

  def moniker(); end

  def on_type_formatting(); end

  def publish_diagnostics(); end

  def range_formatting(); end

  def references(); end

  def rename(); end

  def selection_range(); end

  def semantic_tokens(); end

  def signature_help(); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition(); end

  def type_hierarchy(); end
end

class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
end

class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
  def attributes(); end

  def initialize(text:, range: T.unsafe(nil), range_length: T.unsafe(nil)); end

  def range(); end

  def range_length(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
  def attributes(); end

  def edits(); end

  def initialize(text_document:, edits:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
end

class LanguageServer::Protocol::Interface::TextDocumentItem
  def attributes(); end

  def initialize(uri:, language_id:, version:, text:); end

  def language_id(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::TextDocumentItem
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
  def attributes(); end

  def initialize(text_document:, position:); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
end

class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def include_text(); end

  def initialize(document_selector:, include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
  def attributes(); end

  def did_save(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), did_save: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
  def attributes(); end

  def change(); end

  def initialize(open_close: T.unsafe(nil), change: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), save: T.unsafe(nil)); end

  def open_close(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
end

class LanguageServer::Protocol::Interface::TextEdit
  def attributes(); end

  def initialize(range:, new_text:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextEdit
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
end

class LanguageServer::Protocol::Interface::TypeHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyItem
end

class LanguageServer::Protocol::Interface::TypeHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyOptions
end

class LanguageServer::Protocol::Interface::TypeHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyPrepareParams
end

class LanguageServer::Protocol::Interface::TypeHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyRegistrationOptions
end

class LanguageServer::Protocol::Interface::TypeHierarchySubtypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySubtypesParams
end

class LanguageServer::Protocol::Interface::TypeHierarchySupertypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySupertypesParams
end

class LanguageServer::Protocol::Interface::UnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::UnchangedDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::Unregistration
  def attributes(); end

  def id(); end

  def initialize(id:, method:); end

  def method(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Unregistration
end

class LanguageServer::Protocol::Interface::UnregistrationParams
  def attributes(); end

  def initialize(unregisterations:); end

  def to_hash(); end

  def to_json(*args); end

  def unregisterations(); end
end

class LanguageServer::Protocol::Interface::UnregistrationParams
end

class LanguageServer::Protocol::Interface::VersionedNotebookDocumentIdentifier
  def attributes(); end

  def initialize(version:, uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::VersionedNotebookDocumentIdentifier
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
end

class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, reason:); end

  def reason(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, title:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
  def attributes(); end

  def initialize(kind:, message: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
  def attributes(); end

  def initialize(work_done_token: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(previous_result_ids:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_ids(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticParams
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReport
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReport
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReportPartialResult
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReportPartialResult
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
  def attributes(); end

  def change_annotations(); end

  def changes(); end

  def document_changes(); end

  def initialize(changes: T.unsafe(nil), document_changes: T.unsafe(nil), change_annotations: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
  def attributes(); end

  def change_annotation_support(); end

  def document_changes(); end

  def failure_handling(); end

  def initialize(document_changes: T.unsafe(nil), resource_operations: T.unsafe(nil), failure_handling: T.unsafe(nil), normalizes_line_endings: T.unsafe(nil), change_annotation_support: T.unsafe(nil)); end

  def normalizes_line_endings(); end

  def resource_operations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
  def attributes(); end

  def initialize(uri:, name:); end

  def name(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
  def added(); end

  def attributes(); end

  def initialize(added:, removed:); end

  def removed(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
  def attributes(); end

  def change_notifications(); end

  def initialize(supported: T.unsafe(nil), change_notifications: T.unsafe(nil)); end

  def supported(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
end

class LanguageServer::Protocol::Interface::WorkspaceFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, uri:, version:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WorkspaceFullDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::WorkspaceSymbol
  def attributes(); end

  def container_name(); end

  def data(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), container_name: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbol
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), tag_support: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
  def attributes(); end

  def initialize(query:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def query(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
end

class LanguageServer::Protocol::Interface::WorkspaceUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, uri:, version:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WorkspaceUnchangedDocumentDiagnosticReport
end

module LanguageServer::Protocol::Interface
end

module LanguageServer::Protocol::Transport::Io
end

class LanguageServer::Protocol::Transport::Io::Reader
  def initialize(io); end

  def read(&block); end
end

class LanguageServer::Protocol::Transport::Io::Reader
end

class LanguageServer::Protocol::Transport::Io::Writer
  def initialize(io); end

  def io(); end

  def write(response); end
end

class LanguageServer::Protocol::Transport::Io::Writer
end

module LanguageServer::Protocol::Transport::Io
end

class LanguageServer::Protocol::Transport::Stdio::Reader
  def initialize(); end
end

class LanguageServer::Protocol::Transport::Stdio::Reader
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
end

class Listen::Adapter::Base
  def config(); end

  def configure(); end

  def initialize(config); end

  def options(); end

  def start(); end

  def started?(); end

  def stop(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  def self.usable?(); end
end

class Listen::Adapter::Config
  def adapter_options(); end

  def directories(); end

  def initialize(directories, queue, silencer, adapter_options); end

  def queue(); end

  def silencer(); end
end

class Listen::Adapter::Config
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  README_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
end

module Listen::Adapter
  def self.select(options=T.unsafe(nil)); end
end

class Listen::Backend
  def initialize(directories, queue, silencer, config); end

  def min_delay_between_events(); end

  def start(*args, **arg, &block); end

  def stop(*args, **arg, &block); end
end

class Listen::Backend
  extend ::Forwardable
end

class Listen::Change
  def initialize(config, record); end

  def invalidate(type, rel_path, options); end

  def record(); end
end

class Listen::Change::Config
  def initialize(queue, silencer); end

  def queue(*args); end

  def silenced?(path, type); end
end

class Listen::Change::Config
end

class Listen::Change
end

class Listen::Directory
end

class Listen::Directory
  def self._async_changes(snapshot, path, previous, options); end

  def self._change(snapshot, type, path, options); end

  def self._children(path); end

  def self.ascendant_of?(base, other); end

  def self.scan(snapshot, rel_path, options); end
end

class Listen::Error
end

class Listen::Error::INotifyMaxWatchesExceeded
end

class Listen::Error::INotifyMaxWatchesExceeded
end

class Listen::Error::NotStarted
end

class Listen::Error::NotStarted
end

class Listen::Error::SymlinkLoop
end

class Listen::Error::SymlinkLoop
end

class Listen::Error
end

module Listen::Event
end

class Listen::Event::Config
  def call(*args); end

  def callable?(); end

  def event_queue(); end

  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  def listener(); end

  def min_delay_between_events(); end

  def optimize_changes(changes); end

  def sleep(seconds); end
end

class Listen::Event::Config
end

class Listen::Event::Loop
  include ::Listen::FSM
  def initialize(config); end

  def pause(); end

  def start(); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def wakeup_on_event(); end
  MAX_STARTUP_SECONDS = ::T.let(nil, ::T.untyped)
end

Listen::Event::Loop::Error = Listen::Error

Listen::Event::Loop::NotStarted = Listen::Error::NotStarted

class Listen::Event::Loop
  extend ::Listen::FSM::ClassMethods
end

class Listen::Event::Processor
  def initialize(config, reasons); end

  def loop_for(latency); end
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor
end

class Listen::Event::Queue
  def <<(args); end

  def close(*args, **arg, &block); end

  def empty?(*args, **arg, &block); end

  def initialize(config); end

  def pop(*args, **arg, &block); end
end

class Listen::Event::Queue::Config
  def initialize(relative); end

  def relative?(); end
end

class Listen::Event::Queue::Config
end

class Listen::Event::Queue
  extend ::Forwardable
end

module Listen::Event
end

module Listen::FSM
  def initialize_fsm(); end

  def state(); end

  def wait_for_state(*wait_for_states, timeout: T.unsafe(nil)); end
end

module Listen::FSM::ClassMethods
  def start_state(new_start_state=T.unsafe(nil)); end

  def state(state_name, to: T.unsafe(nil), &block); end

  def states(); end
end

module Listen::FSM::ClassMethods
end

class Listen::FSM::State
  def call(obj); end

  def initialize(name, transitions, &block); end

  def name(); end

  def transitions(); end

  def valid_transition?(new_state); end
end

class Listen::FSM::State
end

module Listen::FSM
  def self.included(klass); end
end

class Listen::File
end

class Listen::File
  def self.change(record, rel_path); end

  def self.inaccurate_mac_time?(stat); end
end

class Listen::Listener
  include ::Listen::FSM
  def ignore(regexps); end

  def ignore!(regexps); end

  def initialize(*dirs, &block); end

  def only(regexps); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def start(); end

  def stop(); end

  def stopped?(); end
end

class Listen::Listener::Config
  def adapter_instance_options(klass); end

  def adapter_select_options(); end

  def initialize(opts); end

  def min_delay_between_events(); end

  def relative?(); end

  def silencer_rules(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Listener::Config
end

class Listen::Listener
  extend ::Listen::FSM::ClassMethods
end

module Listen::MonotonicTime
end

module Listen::MonotonicTime
  def self.now(); end
end

class Listen::Options
  def initialize(opts, defaults); end

  def method_missing(name, *_); end
end

class Listen::Options
end

class Listen::QueueOptimizer
  def initialize(config); end

  def smoosh_changes(changes); end
end

class Listen::QueueOptimizer::Config
  def debug(*args, &block); end

  def exist?(path); end

  def initialize(adapter_class, silencer); end

  def silenced?(path, type); end
end

class Listen::QueueOptimizer::Config
end

class Listen::QueueOptimizer
end

class Listen::Record
  def add_dir(rel_path); end

  def build(); end

  def dir_entries(rel_path); end

  def file_data(rel_path); end

  def initialize(directory, silencer); end

  def root(); end

  def unset_path(rel_path); end

  def update_file(rel_path, data); end
end

class Listen::Record::Entry
  def children(); end

  def initialize(root, relative, name=T.unsafe(nil)); end

  def meta(); end

  def name(); end

  def real_path(); end

  def record_dir_key(); end

  def relative(); end

  def root(); end

  def sys_path(); end
end

class Listen::Record::Entry
end

class Listen::Record::SymlinkDetector
  def verify_unwatched!(entry); end

  def warn(message); end
  README_URL = ::T.let(nil, ::T.untyped)
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
end

Listen::Record::SymlinkDetector::Error = Listen::Error

class Listen::Record::SymlinkDetector
end

class Listen::Record
end

class Listen::Silencer
  def configure(options); end

  def ignore_patterns(); end

  def ignore_patterns=(ignore_patterns); end

  def initialize(**options); end

  def only_patterns(); end

  def only_patterns=(only_patterns); end

  def silenced?(relative_path, type); end
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_FILES = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer::Controller
  def append_ignores(*regexps); end

  def initialize(silencer, default_options); end

  def replace_with_bang_ignores(regexps); end

  def replace_with_only(regexps); end
end

class Listen::Silencer::Controller
end

class Listen::Silencer
end

module Listen::Thread
end

module Listen::Thread
  def self.new(name, &block); end

  def self.rescue_and_log(method_name, *args, caller_stack: T.unsafe(nil)); end
end

module Listen
  def self.adapter_warn(message); end

  def self.adapter_warn_behavior(); end

  def self.adapter_warn_behavior=(adapter_warn_behavior); end

  def self.logger(); end

  def self.logger=(logger); end
end

class LoadError
  include ::DidYouMean::Correctable
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
  MODE = ::T.let(nil, ::T.untyped)
  MODE_TO_CREATE = ::T.let(nil, ::T.untyped)
  MODE_TO_OPEN = ::T.let(nil, ::T.untyped)
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Severity
  def self.coerce(severity); end
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

module Minitest::Assertions
  def _synchronize(); end

  def _where(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_pattern(); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_pattern(); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), _ignored=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
  BASE_DIR = ::T.let(nil, ::T.untyped)
end

module Minitest::Reportable
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def metadata(); end

  def metadata=(metadata); end

  def metadata?(); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.test_order(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def neuter_exception(e); end

  def new_exception(klass, msg, bt, kill=T.unsafe(nil)); end

  def sanitize_exception(e); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  SETUP_METHODS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end
end

class Module
  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end

  def deprecate(*method_names, deprecator:, **options); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def method_visibility(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def set_temporary_name(arg); end

  def silence_redefinition_of_method(method); end

  def undefined_instance_methods(); end
end

Module::DelegationError = ActiveSupport::DelegationError

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class NilClass
  def =~(arg); end

  def to_d(); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

class Numeric
  def zettabyte(); end

  def zettabytes(); end
  ZETTABYTE = ::T.let(nil, ::T.untyped)
end

class Object
  include ::ActiveSupport::Tryable
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::RequireDependency
  def MethodName(string); end

  def html_safe?(); end

  def presence_in(another_object); end

  def to_yaml(options=T.unsafe(nil)); end

  def with(**attributes); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def delete(arg); end
end

module Open3
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenStruct
  def MethodName!(string); end

  def Namespace!(name); end

  def TypeName!(string); end

  def __id__!(); end

  def __send__!(*arg); end

  def as_json!(options=T.unsafe(nil)); end

  def at_exit!(&block); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def exit!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_values!(); end

  def instance_variable_get!(arg); end

  def instance_variable_names!(); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def presence!(); end

  def presence_in!(another_object); end

  def pretty_inspect!(); end

  def pretty_print!(q); end

  def pretty_print_cycle!(q); end

  def pretty_print_inspect!(); end

  def pretty_print_instance_variables!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def require_dependency!(filename); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_json!(options=T.unsafe(nil)); end

  def to_param!(); end

  def to_query!(key); end

  def to_s!(); end

  def to_yaml!(options=T.unsafe(nil)); end

  def with!(**attributes); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def pretty_head(); end
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

class PP
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  def self.width_for(out); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  include ::AST::Processor::Mixin
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def lexer(); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def forwarded_kwrestarg(dstar_t); end

  def forwarded_restarg(star_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_pattern(lhs, match_t, rhs); end

  def match_pattern_p(lhs, match_t, rhs); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_label(key_t); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_kwargs(); end

  def self.emit_kwargs=(emit_kwargs); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_match_pattern(); end

  def self.emit_match_pattern=(emit_match_pattern); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def in_argdef(); end

  def in_argdef=(in_argdef); end

  def in_block(); end

  def in_block=(in_block); end

  def in_class(); end

  def in_class=(in_class); end

  def in_def(); end

  def in_def=(in_def); end

  def in_defined(); end

  def in_defined=(in_defined); end

  def in_dynamic_block?(); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def in_lambda(); end

  def in_lambda=(in_lambda); end

  def reset(); end
  FLAGS = ::T.let(nil, ::T.untyped)
end

class Parser::Context
end

class Parser::CurrentArgStack
  def empty?(); end

  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def check_ambiguous_slash(tm); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def cmdarg_stack(); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def cond_stack(); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def e_lbrace(); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_class_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_colon_with_digits(p, tm, diag_msg); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment_from_range(p, pe); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_global_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_instance_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_rbrace_rparen_rbrack(); end

  def emit_singleton_class(); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encoding(); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def initialize(version); end

  def lambda_stack(); end

  def numeric_literal_int(); end

  def on_newline(p); end

  def paren_nest(); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def push_cmdarg(); end

  def push_cond(); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version(); end

  def version?(*versions); end
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_inside_string(); end

  def self.lex_en_inside_string=(lex_en_inside_string); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::LexerStrings
  def advance(p); end

  def check_ambiguous_slash(tm); end

  def check_invalid_escapes(p); end

  def close_interp_on_current_literal(p); end

  def cond(); end

  def continue_lexing(current_literal); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_character_constant(); end

  def emit_interp_var(interp_var_kind); end

  def emit_invalid_escapes?(); end

  def encode_escape(ord); end

  def encode_escaped_char(p); end

  def eof_codepoint?(point); end

  def extend_interp_code(current_literal); end

  def extend_interp_digit_var(); end

  def extend_interp_var(current_literal); end

  def extend_string_eol_check_eof(current_literal, pe); end

  def extend_string_eol_heredoc_intertwined(p); end

  def extend_string_eol_heredoc_line(); end

  def extend_string_eol_words(current_literal, p); end

  def extend_string_escaped(); end

  def extend_string_for_token_range(current_literal, string); end

  def extend_string_slice_end(lookahead); end

  def herebody_s(); end

  def herebody_s=(herebody_s); end

  def initialize(lexer, version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def on_newline(p); end

  def pop_literal(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def read_character_constant(p); end

  def read_post_meta_or_ctrl_char(p); end

  def reset(); end

  def slash_c_char(); end

  def slash_m_char(); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def source_pts(); end

  def source_pts=(source_pts); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def unescape_char(p); end

  def unicode_points(p); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::LexerStrings
  def self.lex_en_character(); end

  def self.lex_en_character=(lex_en_character); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_en_unknown(); end

  def self.lex_en_unknown=(lex_en_unknown); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def empty?(); end

  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(static:); end

  def register(numparam); end

  def stack(); end

  def top(); end
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
end

module Parser::Messages
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*arg); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def local_pop(); end

  def local_push(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

class Parser::Ruby33
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(start, length=T.unsafe(nil)); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_by_identity(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_by_identity(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::MethodDefinition
  def assignment(); end

  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::MethodDefinition
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def as_lsp_range(); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_anonymous_blockarg(); end

  def declare_anonymous_kwrestarg(); end

  def declare_anonymous_restarg(); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_anonymous_blockarg?(); end

  def declared_anonymous_blockarg_in_current_scpe?(); end

  def declared_anonymous_kwrestarg?(); end

  def declared_anonymous_kwrestarg_in_current_scope?(); end

  def declared_anonymous_restarg?(); end

  def declared_anonymous_restarg_in_current_scope?(); end

  def declared_forward_args?(); end

  def empty?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def parent_has_anonymous_blockarg?(); end

  def parent_has_anonymous_kwrestarg?(); end

  def parent_has_anonymous_restarg?(); end

  def reset(); end

  def unextend(); end
  ANONYMOUS_BLOCKARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_BLOCKARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::UnknownEncodingInMagicComment
end

class Parser::UnknownEncodingInMagicComment
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def empty?(); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

class Pathname
  def lutime(arg, arg1); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class PrettyPrint
  VERSION = ::T.let(nil, ::T.untyped)
end

module Prism
  BACKEND = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Prism::AliasGlobalVariableNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(new_name, old_name, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def new_name(); end

  def old_name(); end

  def type(); end
end

class Prism::AliasGlobalVariableNode
  def self.type(); end
end

class Prism::AliasMethodNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(new_name, old_name, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def new_name(); end

  def old_name(); end

  def type(); end
end

class Prism::AliasMethodNode
  def self.type(); end
end

class Prism::AlternationPatternNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(left, right, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def type(); end
end

class Prism::AlternationPatternNode
  def self.type(); end
end

class Prism::AndNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(left, right, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def type(); end
end

class Prism::AndNode
  def self.type(); end
end

class Prism::ArgumentsNode
  def accept(visitor); end

  def arguments(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def contains_keyword_splat?(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, arguments, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::ArgumentsNode
  def self.type(); end
end

module Prism::ArgumentsNodeFlags
  CONTAINS_KEYWORD_SPLAT = ::T.let(nil, ::T.untyped)
end

module Prism::ArgumentsNodeFlags
end

class Prism::ArrayNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def contains_splat?(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(flags, elements, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def type(); end
end

class Prism::ArrayNode
  def self.type(); end
end

module Prism::ArrayNodeFlags
  CONTAINS_SPLAT = ::T.let(nil, ::T.untyped)
end

module Prism::ArrayNodeFlags
end

class Prism::ArrayPatternNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def constant(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def posts(); end

  def requireds(); end

  def rest(); end

  def type(); end
end

class Prism::ArrayPatternNode
  def self.type(); end
end

class Prism::AssocNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(key, value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def key(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::AssocNode
  def self.type(); end
end

class Prism::AssocSplatNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::AssocSplatNode
  def self.type(); end
end

class Prism::BackReferenceReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::BackReferenceReadNode
  def self.type(); end
end

class Prism::BasicVisitor
  def visit(node); end

  def visit_all(nodes); end

  def visit_child_nodes(node); end
end

class Prism::BasicVisitor
end

class Prism::BeginNode
  def accept(visitor); end

  def begin_keyword(); end

  def begin_keyword_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def else_clause(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def ensure_clause(); end

  def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def rescue_clause(); end

  def statements(); end

  def type(); end
end

class Prism::BeginNode
  def self.type(); end
end

class Prism::BlockArgumentNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(expression, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::BlockArgumentNode
  def self.type(); end
end

class Prism::BlockLocalVariableNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::BlockLocalVariableNode
  def self.type(); end
end

class Prism::BlockNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(locals, locals_body_index, parameters, body, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def locals_body_index(); end

  def opening(); end

  def opening_loc(); end

  def parameters(); end

  def type(); end
end

class Prism::BlockNode
  def self.type(); end
end

class Prism::BlockParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::BlockParameterNode
  def self.type(); end
end

class Prism::BlockParametersNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(parameters, locals, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def opening(); end

  def opening_loc(); end

  def parameters(); end

  def type(); end
end

class Prism::BlockParametersNode
  def self.type(); end
end

class Prism::BreakNode
  def accept(visitor); end

  def arguments(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(arguments, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def type(); end
end

class Prism::BreakNode
  def self.type(); end
end

class Prism::CallAndWriteNode
  def accept(visitor); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def message(); end

  def message_loc(); end

  def operator(); end

  def operator_loc(); end

  def read_name(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def value(); end

  def variable_call?(); end

  def write_name(); end
end

class Prism::CallAndWriteNode
  def self.type(); end
end

class Prism::CallNode
  def accept(visitor); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def message(); end

  def message_loc(); end

  def name(); end

  def opening(); end

  def opening_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def variable_call?(); end
end

class Prism::CallNode
  def self.type(); end
end

module Prism::CallNodeFlags
  ATTRIBUTE_WRITE = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
  VARIABLE_CALL = ::T.let(nil, ::T.untyped)
end

module Prism::CallNodeFlags
end

class Prism::CallOperatorWriteNode
  def accept(visitor); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def message(); end

  def message_loc(); end

  def operator(); end

  def operator_loc(); end

  def read_name(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def value(); end

  def variable_call?(); end

  def write_name(); end
end

class Prism::CallOperatorWriteNode
  def self.type(); end
end

class Prism::CallOrWriteNode
  def accept(visitor); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def message(); end

  def message_loc(); end

  def operator(); end

  def operator_loc(); end

  def read_name(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def value(); end

  def variable_call?(); end

  def write_name(); end
end

class Prism::CallOrWriteNode
  def self.type(); end
end

class Prism::CallTargetNode
  def accept(visitor); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, name, message_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def message(); end

  def message_loc(); end

  def name(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def variable_call?(); end
end

class Prism::CallTargetNode
  def self.type(); end
end

class Prism::CapturePatternNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(value, target, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def target(); end

  def type(); end

  def value(); end
end

class Prism::CapturePatternNode
  def self.type(); end
end

class Prism::CaseMatchNode
  def accept(visitor); end

  def case_keyword(); end

  def case_keyword_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def conditions(); end

  def consequent(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def predicate(); end

  def type(); end
end

class Prism::CaseMatchNode
  def self.type(); end
end

class Prism::CaseNode
  def accept(visitor); end

  def case_keyword(); end

  def case_keyword_loc(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def conditions(); end

  def consequent(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def predicate(); end

  def type(); end
end

class Prism::CaseNode
  def self.type(); end
end

class Prism::ClassNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def class_keyword(); end

  def class_keyword_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def constant_path(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def inheritance_operator(); end

  def inheritance_operator_loc(); end

  def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def name(); end

  def superclass(); end

  def type(); end
end

class Prism::ClassNode
  def self.type(); end
end

class Prism::ClassVariableAndWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ClassVariableAndWriteNode
  def self.type(); end
end

class Prism::ClassVariableOperatorWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, operator, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ClassVariableOperatorWriteNode
  def self.type(); end
end

class Prism::ClassVariableOrWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ClassVariableOrWriteNode
  def self.type(); end
end

class Prism::ClassVariableReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::ClassVariableReadNode
  def self.type(); end
end

class Prism::ClassVariableTargetNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::ClassVariableTargetNode
  def self.type(); end
end

class Prism::ClassVariableWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ClassVariableWriteNode
  def self.type(); end
end

class Prism::Comment
  def deconstruct_keys(keys); end

  def initialize(location); end

  def location(); end
end

class Prism::Comment
end

class Prism::Compiler
  def visit(node); end

  def visit_alias_global_variable_node(node); end

  def visit_alias_method_node(node); end

  def visit_all(nodes); end

  def visit_alternation_pattern_node(node); end

  def visit_and_node(node); end

  def visit_arguments_node(node); end

  def visit_array_node(node); end

  def visit_array_pattern_node(node); end

  def visit_assoc_node(node); end

  def visit_assoc_splat_node(node); end

  def visit_back_reference_read_node(node); end

  def visit_begin_node(node); end

  def visit_block_argument_node(node); end

  def visit_block_local_variable_node(node); end

  def visit_block_node(node); end

  def visit_block_parameter_node(node); end

  def visit_block_parameters_node(node); end

  def visit_break_node(node); end

  def visit_call_and_write_node(node); end

  def visit_call_node(node); end

  def visit_call_operator_write_node(node); end

  def visit_call_or_write_node(node); end

  def visit_call_target_node(node); end

  def visit_capture_pattern_node(node); end

  def visit_case_match_node(node); end

  def visit_case_node(node); end

  def visit_child_nodes(node); end

  def visit_class_node(node); end

  def visit_class_variable_and_write_node(node); end

  def visit_class_variable_operator_write_node(node); end

  def visit_class_variable_or_write_node(node); end

  def visit_class_variable_read_node(node); end

  def visit_class_variable_target_node(node); end

  def visit_class_variable_write_node(node); end

  def visit_constant_and_write_node(node); end

  def visit_constant_operator_write_node(node); end

  def visit_constant_or_write_node(node); end

  def visit_constant_path_and_write_node(node); end

  def visit_constant_path_node(node); end

  def visit_constant_path_operator_write_node(node); end

  def visit_constant_path_or_write_node(node); end

  def visit_constant_path_target_node(node); end

  def visit_constant_path_write_node(node); end

  def visit_constant_read_node(node); end

  def visit_constant_target_node(node); end

  def visit_constant_write_node(node); end

  def visit_def_node(node); end

  def visit_defined_node(node); end

  def visit_else_node(node); end

  def visit_embedded_statements_node(node); end

  def visit_embedded_variable_node(node); end

  def visit_ensure_node(node); end

  def visit_false_node(node); end

  def visit_find_pattern_node(node); end

  def visit_flip_flop_node(node); end

  def visit_float_node(node); end

  def visit_for_node(node); end

  def visit_forwarding_arguments_node(node); end

  def visit_forwarding_parameter_node(node); end

  def visit_forwarding_super_node(node); end

  def visit_global_variable_and_write_node(node); end

  def visit_global_variable_operator_write_node(node); end

  def visit_global_variable_or_write_node(node); end

  def visit_global_variable_read_node(node); end

  def visit_global_variable_target_node(node); end

  def visit_global_variable_write_node(node); end

  def visit_hash_node(node); end

  def visit_hash_pattern_node(node); end

  def visit_if_node(node); end

  def visit_imaginary_node(node); end

  def visit_implicit_node(node); end

  def visit_implicit_rest_node(node); end

  def visit_in_node(node); end

  def visit_index_and_write_node(node); end

  def visit_index_operator_write_node(node); end

  def visit_index_or_write_node(node); end

  def visit_index_target_node(node); end

  def visit_instance_variable_and_write_node(node); end

  def visit_instance_variable_operator_write_node(node); end

  def visit_instance_variable_or_write_node(node); end

  def visit_instance_variable_read_node(node); end

  def visit_instance_variable_target_node(node); end

  def visit_instance_variable_write_node(node); end

  def visit_integer_node(node); end

  def visit_interpolated_match_last_line_node(node); end

  def visit_interpolated_regular_expression_node(node); end

  def visit_interpolated_string_node(node); end

  def visit_interpolated_symbol_node(node); end

  def visit_interpolated_x_string_node(node); end

  def visit_keyword_hash_node(node); end

  def visit_keyword_rest_parameter_node(node); end

  def visit_lambda_node(node); end

  def visit_local_variable_and_write_node(node); end

  def visit_local_variable_operator_write_node(node); end

  def visit_local_variable_or_write_node(node); end

  def visit_local_variable_read_node(node); end

  def visit_local_variable_target_node(node); end

  def visit_local_variable_write_node(node); end

  def visit_match_last_line_node(node); end

  def visit_match_predicate_node(node); end

  def visit_match_required_node(node); end

  def visit_match_write_node(node); end

  def visit_missing_node(node); end

  def visit_module_node(node); end

  def visit_multi_target_node(node); end

  def visit_multi_write_node(node); end

  def visit_next_node(node); end

  def visit_nil_node(node); end

  def visit_no_keywords_parameter_node(node); end

  def visit_numbered_parameters_node(node); end

  def visit_numbered_reference_read_node(node); end

  def visit_optional_keyword_parameter_node(node); end

  def visit_optional_parameter_node(node); end

  def visit_or_node(node); end

  def visit_parameters_node(node); end

  def visit_parentheses_node(node); end

  def visit_pinned_expression_node(node); end

  def visit_pinned_variable_node(node); end

  def visit_post_execution_node(node); end

  def visit_pre_execution_node(node); end

  def visit_program_node(node); end

  def visit_range_node(node); end

  def visit_rational_node(node); end

  def visit_redo_node(node); end

  def visit_regular_expression_node(node); end

  def visit_required_keyword_parameter_node(node); end

  def visit_required_parameter_node(node); end

  def visit_rescue_modifier_node(node); end

  def visit_rescue_node(node); end

  def visit_rest_parameter_node(node); end

  def visit_retry_node(node); end

  def visit_return_node(node); end

  def visit_self_node(node); end

  def visit_singleton_class_node(node); end

  def visit_source_encoding_node(node); end

  def visit_source_file_node(node); end

  def visit_source_line_node(node); end

  def visit_splat_node(node); end

  def visit_statements_node(node); end

  def visit_string_node(node); end

  def visit_super_node(node); end

  def visit_symbol_node(node); end

  def visit_true_node(node); end

  def visit_undef_node(node); end

  def visit_unless_node(node); end

  def visit_until_node(node); end

  def visit_when_node(node); end

  def visit_while_node(node); end

  def visit_x_string_node(node); end

  def visit_yield_node(node); end
end

class Prism::Compiler
end

class Prism::ConstantAndWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ConstantAndWriteNode
  def self.type(); end
end

class Prism::ConstantOperatorWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, operator, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ConstantOperatorWriteNode
  def self.type(); end
end

class Prism::ConstantOrWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ConstantOrWriteNode
  def self.type(); end
end

class Prism::ConstantPathAndWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(target, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def target(); end

  def type(); end

  def value(); end
end

class Prism::ConstantPathAndWriteNode
  def self.type(); end
end

class Prism::ConstantPathNode
  def accept(visitor); end

  def child(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def delimiter(); end

  def delimiter_loc(); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(parent, child, delimiter_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def parent(); end

  def type(); end
end

class Prism::ConstantPathNode::DynamicPartsInConstantPathError
end

class Prism::ConstantPathNode::DynamicPartsInConstantPathError
end

class Prism::ConstantPathNode
  def self.type(); end
end

class Prism::ConstantPathOperatorWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(target, operator_loc, value, operator, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def target(); end

  def type(); end

  def value(); end
end

class Prism::ConstantPathOperatorWriteNode
  def self.type(); end
end

class Prism::ConstantPathOrWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(target, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def target(); end

  def type(); end

  def value(); end
end

class Prism::ConstantPathOrWriteNode
  def self.type(); end
end

class Prism::ConstantPathTargetNode
  def accept(visitor); end

  def child(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def delimiter(); end

  def delimiter_loc(); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(parent, child, delimiter_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def parent(); end

  def type(); end
end

class Prism::ConstantPathTargetNode
  def self.type(); end
end

class Prism::ConstantPathWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(target, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def target(); end

  def type(); end

  def value(); end
end

class Prism::ConstantPathWriteNode
  def self.type(); end
end

class Prism::ConstantReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::ConstantReadNode
  def self.type(); end
end

class Prism::ConstantTargetNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::ConstantTargetNode
  def self.type(); end
end

class Prism::ConstantWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::ConstantWriteNode
  def self.type(); end
end

module Prism::DSL
end

module Prism::DSL
end

class Prism::DefNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def def_keyword(); end

  def def_keyword_loc(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def equal(); end

  def equal_loc(); end

  def initialize(name, name_loc, receiver, parameters, body, locals, locals_body_index, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def locals_body_index(); end

  def lparen(); end

  def lparen_loc(); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def parameters(); end

  def receiver(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end
end

class Prism::DefNode
  def self.type(); end
end

class Prism::DefinedNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def lparen(); end

  def lparen_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end

  def value(); end
end

class Prism::DefinedNode
  def self.type(); end
end

class Prism::DesugarCompiler
end

class Prism::DesugarCompiler
end

class Prism::Dispatcher
  def dispatch(node); end

  def dispatch_once(node); end

  def listeners(); end

  def register(listener, *events); end
end

class Prism::Dispatcher
end

class Prism::ElseNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def else_keyword(); end

  def else_keyword_loc(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def statements(); end

  def type(); end
end

class Prism::ElseNode
  def self.type(); end
end

class Prism::EmbDocComment
  def trailing?(); end
end

class Prism::EmbDocComment
end

class Prism::EmbeddedStatementsNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(opening_loc, statements, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def statements(); end

  def type(); end
end

class Prism::EmbeddedStatementsNode
  def self.type(); end
end

class Prism::EmbeddedVariableNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(operator_loc, variable, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def variable(); end
end

class Prism::EmbeddedVariableNode
  def self.type(); end
end

module Prism::EncodingFlags
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
end

module Prism::EncodingFlags
end

class Prism::EnsureNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def ensure_keyword(); end

  def ensure_keyword_loc(); end

  def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def statements(); end

  def type(); end
end

class Prism::EnsureNode
  def self.type(); end
end

class Prism::FalseNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::FalseNode
  def self.type(); end
end

class Prism::FindPatternNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def constant(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def left(); end

  def opening(); end

  def opening_loc(); end

  def requireds(); end

  def right(); end

  def type(); end
end

class Prism::FindPatternNode
  def self.type(); end
end

class Prism::FlipFlopNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def exclude_end?(); end

  def initialize(flags, left, right, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def type(); end
end

class Prism::FlipFlopNode
  def self.type(); end
end

class Prism::FloatNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end

  def value(); end
end

class Prism::FloatNode
  def self.type(); end
end

class Prism::ForNode
  def accept(visitor); end

  def child_nodes(); end

  def collection(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def do_keyword(); end

  def do_keyword_loc(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def for_keyword(); end

  def for_keyword_loc(); end

  def in_keyword(); end

  def in_keyword_loc(); end

  def index(); end

  def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def statements(); end

  def type(); end
end

class Prism::ForNode
  def self.type(); end
end

class Prism::ForwardingArgumentsNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::ForwardingArgumentsNode
  def self.type(); end
end

class Prism::ForwardingParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::ForwardingParameterNode
  def self.type(); end
end

class Prism::ForwardingSuperNode
  def accept(visitor); end

  def block(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(block, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::ForwardingSuperNode
  def self.type(); end
end

class Prism::GlobalVariableAndWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::GlobalVariableAndWriteNode
  def self.type(); end
end

class Prism::GlobalVariableOperatorWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, operator, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::GlobalVariableOperatorWriteNode
  def self.type(); end
end

class Prism::GlobalVariableOrWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::GlobalVariableOrWriteNode
  def self.type(); end
end

class Prism::GlobalVariableReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::GlobalVariableReadNode
  def self.type(); end
end

class Prism::GlobalVariableTargetNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::GlobalVariableTargetNode
  def self.type(); end
end

class Prism::GlobalVariableWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::GlobalVariableWriteNode
  def self.type(); end
end

class Prism::HashNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(opening_loc, elements, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def type(); end
end

class Prism::HashNode
  def self.type(); end
end

class Prism::HashPatternNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def constant(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(constant, elements, rest, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def rest(); end

  def type(); end
end

class Prism::HashPatternNode
  def self.type(); end
end

module Prism::HeredocQuery
  def heredoc?(); end
end

module Prism::HeredocQuery
end

class Prism::IfNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def consequent(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def if_keyword(); end

  def if_keyword_loc(); end

  def initialize(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def predicate(); end

  def statements(); end

  def then_keyword(); end

  def then_keyword_loc(); end

  def type(); end
end

class Prism::IfNode
  def self.type(); end
end

class Prism::ImaginaryNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(numeric, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def numeric(); end

  def type(); end

  def value(); end
end

class Prism::ImaginaryNode
  def self.type(); end
end

class Prism::ImplicitNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end

  def value(); end
end

class Prism::ImplicitNode
  def self.type(); end
end

class Prism::ImplicitRestNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::ImplicitRestNode
  def self.type(); end
end

class Prism::InNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def in(); end

  def in_loc(); end

  def initialize(pattern, statements, in_loc, then_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def pattern(); end

  def statements(); end

  def then_loc(); end

  def type(); end
end

class Prism::InNode
  def self.type(); end
end

class Prism::IndexAndWriteNode
  def accept(visitor); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def value(); end

  def variable_call?(); end
end

class Prism::IndexAndWriteNode
  def self.type(); end
end

class Prism::IndexOperatorWriteNode
  def accept(visitor); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def value(); end

  def variable_call?(); end
end

class Prism::IndexOperatorWriteNode
  def self.type(); end
end

class Prism::IndexOrWriteNode
  def accept(visitor); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def value(); end

  def variable_call?(); end
end

class Prism::IndexOrWriteNode
  def self.type(); end
end

class Prism::IndexTargetNode
  def accept(visitor); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, receiver, opening_loc, arguments, closing_loc, block, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def type(); end

  def variable_call?(); end
end

class Prism::IndexTargetNode
  def self.type(); end
end

class Prism::InlineComment
  def trailing?(); end
end

class Prism::InlineComment
end

class Prism::InstanceVariableAndWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::InstanceVariableAndWriteNode
  def self.type(); end
end

class Prism::InstanceVariableOperatorWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, operator, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::InstanceVariableOperatorWriteNode
  def self.type(); end
end

class Prism::InstanceVariableOrWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::InstanceVariableOrWriteNode
  def self.type(); end
end

class Prism::InstanceVariableReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::InstanceVariableReadNode
  def self.type(); end
end

class Prism::InstanceVariableTargetNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::InstanceVariableTargetNode
  def self.type(); end
end

class Prism::InstanceVariableWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::InstanceVariableWriteNode
  def self.type(); end
end

module Prism::IntegerBaseFlags
  BINARY = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
end

module Prism::IntegerBaseFlags
end

class Prism::IntegerNode
  def accept(visitor); end

  def binary?(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def decimal?(); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def hexadecimal?(); end

  def initialize(flags, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def octal?(); end

  def type(); end

  def value(); end
end

class Prism::IntegerNode
  def self.type(); end
end

class Prism::InterpolatedMatchLastLineNode
  include ::Prism::RegularExpressionOptions
  def accept(visitor); end

  def ascii_8bit?(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(flags, opening_loc, parts, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def type(); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::InterpolatedMatchLastLineNode
  def self.type(); end
end

class Prism::InterpolatedRegularExpressionNode
  include ::Prism::RegularExpressionOptions
  def accept(visitor); end

  def ascii_8bit?(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(flags, opening_loc, parts, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def type(); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::InterpolatedRegularExpressionNode
  def self.type(); end
end

class Prism::InterpolatedStringNode
  include ::Prism::HeredocQuery
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(opening_loc, parts, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def type(); end
end

class Prism::InterpolatedStringNode
  def self.type(); end
end

class Prism::InterpolatedSymbolNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(opening_loc, parts, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def type(); end
end

class Prism::InterpolatedSymbolNode
  def self.type(); end
end

class Prism::InterpolatedXStringNode
  include ::Prism::HeredocQuery
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(opening_loc, parts, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def type(); end
end

class Prism::InterpolatedXStringNode
  def self.type(); end
end

class Prism::KeywordHashNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(flags, elements, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def static_keys?(); end

  def type(); end
end

class Prism::KeywordHashNode
  def self.type(); end
end

module Prism::KeywordHashNodeFlags
  STATIC_KEYS = ::T.let(nil, ::T.untyped)
end

module Prism::KeywordHashNodeFlags
end

class Prism::KeywordRestParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::KeywordRestParameterNode
  def self.type(); end
end

class Prism::LambdaNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(locals, locals_body_index, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def locals_body_index(); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def parameters(); end

  def type(); end
end

class Prism::LambdaNode
  def self.type(); end
end

class Prism::LocalVariableAndWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(name_loc, operator_loc, value, name, depth, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::LocalVariableAndWriteNode
  def self.type(); end
end

class Prism::LocalVariableOperatorWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(name_loc, operator_loc, value, name, operator, depth, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::LocalVariableOperatorWriteNode
  def self.type(); end
end

class Prism::LocalVariableOrWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(name_loc, operator_loc, value, name, depth, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::LocalVariableOrWriteNode
  def self.type(); end
end

class Prism::LocalVariableReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(name, depth, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::LocalVariableReadNode
  def self.type(); end
end

class Prism::LocalVariableTargetNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(name, depth, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::LocalVariableTargetNode
  def self.type(); end
end

class Prism::LocalVariableWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(name, depth, name_loc, value, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::LocalVariableWriteNode
  def self.type(); end
end

class Prism::Location
  def ==(other); end

  def comments(); end

  def copy(**options); end

  def deconstruct_keys(keys); end

  def end_character_column(); end

  def end_character_offset(); end

  def end_column(); end

  def end_line(); end

  def end_offset(); end

  def initialize(source, start_offset, length); end

  def join(other); end

  def length(); end

  def slice(); end

  def source(); end

  def start_character_column(); end

  def start_character_offset(); end

  def start_column(); end

  def start_line(); end

  def start_line_slice(); end

  def start_offset(); end
end

class Prism::Location
  def self.null(); end
end

module Prism::LoopFlags
  BEGIN_MODIFIER = ::T.let(nil, ::T.untyped)
end

module Prism::LoopFlags
end

class Prism::MagicComment
  def deconstruct_keys(keys); end

  def initialize(key_loc, value_loc); end

  def key(); end

  def key_loc(); end

  def value(); end

  def value_loc(); end
end

class Prism::MagicComment
end

class Prism::MatchLastLineNode
  include ::Prism::RegularExpressionOptions
  def accept(visitor); end

  def ascii_8bit?(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def content(); end

  def content_loc(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def type(); end

  def unescaped(); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::MatchLastLineNode
  def self.type(); end
end

class Prism::MatchPredicateNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(value, pattern, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def pattern(); end

  def type(); end

  def value(); end
end

class Prism::MatchPredicateNode
  def self.type(); end
end

class Prism::MatchRequiredNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(value, pattern, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def pattern(); end

  def type(); end

  def value(); end
end

class Prism::MatchRequiredNode
  def self.type(); end
end

class Prism::MatchWriteNode
  def accept(visitor); end

  def call(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(call, targets, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def targets(); end

  def type(); end
end

class Prism::MatchWriteNode
  def self.type(); end
end

class Prism::MissingNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::MissingNode
  def self.type(); end
end

class Prism::ModuleNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def constant_path(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def module_keyword(); end

  def module_keyword_loc(); end

  def name(); end

  def type(); end
end

class Prism::ModuleNode
  def self.type(); end
end

class Prism::MultiTargetNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def lefts(); end

  def lparen(); end

  def lparen_loc(); end

  def rest(); end

  def rights(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end
end

class Prism::MultiTargetNode
  def self.type(); end
end

class Prism::MultiWriteNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def lefts(); end

  def lparen(); end

  def lparen_loc(); end

  def operator(); end

  def operator_loc(); end

  def rest(); end

  def rights(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end

  def value(); end
end

class Prism::MultiWriteNode
  def self.type(); end
end

class Prism::MutationCompiler
end

class Prism::MutationCompiler
end

class Prism::NextNode
  def accept(visitor); end

  def arguments(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(arguments, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def type(); end
end

class Prism::NextNode
  def self.type(); end
end

class Prism::NilNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::NilNode
  def self.type(); end
end

class Prism::NoKeywordsParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(operator_loc, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::NoKeywordsParameterNode
  def self.type(); end
end

class Prism::Node
  def location(); end

  def newline?(); end

  def set_newline_flag(newline_marked); end

  def slice(); end

  def to_dot(); end
end

class Prism::Node
end

class Prism::NodeInspector
  def <<(line); end

  def child_inspector(append); end

  def child_node(node, append); end

  def header(node); end

  def initialize(prefix=T.unsafe(nil)); end

  def list(prefix, nodes); end

  def location(value); end

  def output(); end

  def prefix(); end

  def to_str(); end
end

class Prism::NodeInspector
end

class Prism::NumberedParametersNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(maximum, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def maximum(); end

  def type(); end
end

class Prism::NumberedParametersNode
  def self.type(); end
end

class Prism::NumberedReferenceReadNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(number, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def number(); end

  def type(); end
end

class Prism::NumberedReferenceReadNode
  def self.type(); end
end

class Prism::OptionalKeywordParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def type(); end

  def value(); end
end

class Prism::OptionalKeywordParameterNode
  def self.type(); end
end

class Prism::OptionalParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, value, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def value(); end
end

class Prism::OptionalParameterNode
  def self.type(); end
end

class Prism::OrNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(left, right, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def type(); end
end

class Prism::OrNode
  def self.type(); end
end

module Prism::Pack
  AGNOSTIC_ENDIAN = ::T.let(nil, ::T.untyped)
  BACK = ::T.let(nil, ::T.untyped)
  BER = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  ENDIAN_NA = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  LENGTH_FIXED = ::T.let(nil, ::T.untyped)
  LENGTH_MAX = ::T.let(nil, ::T.untyped)
  LENGTH_NA = ::T.let(nil, ::T.untyped)
  LENGTH_RELATIVE = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  MOVE = ::T.let(nil, ::T.untyped)
  NATIVE_ENDIAN = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  SIGNED = ::T.let(nil, ::T.untyped)
  SIGNED_NA = ::T.let(nil, ::T.untyped)
  SIZE_16 = ::T.let(nil, ::T.untyped)
  SIZE_32 = ::T.let(nil, ::T.untyped)
  SIZE_64 = ::T.let(nil, ::T.untyped)
  SIZE_8 = ::T.let(nil, ::T.untyped)
  SIZE_INT = ::T.let(nil, ::T.untyped)
  SIZE_LONG = ::T.let(nil, ::T.untyped)
  SIZE_LONG_LONG = ::T.let(nil, ::T.untyped)
  SIZE_NA = ::T.let(nil, ::T.untyped)
  SIZE_P = ::T.let(nil, ::T.untyped)
  SIZE_SHORT = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  STRING_BASE64 = ::T.let(nil, ::T.untyped)
  STRING_FIXED = ::T.let(nil, ::T.untyped)
  STRING_HEX_HIGH = ::T.let(nil, ::T.untyped)
  STRING_HEX_LOW = ::T.let(nil, ::T.untyped)
  STRING_LSB = ::T.let(nil, ::T.untyped)
  STRING_MIME = ::T.let(nil, ::T.untyped)
  STRING_MSB = ::T.let(nil, ::T.untyped)
  STRING_NULL_PADDED = ::T.let(nil, ::T.untyped)
  STRING_NULL_TERMINATED = ::T.let(nil, ::T.untyped)
  STRING_POINTER = ::T.let(nil, ::T.untyped)
  STRING_SPACE_PADDED = ::T.let(nil, ::T.untyped)
  STRING_UU = ::T.let(nil, ::T.untyped)
  UNSIGNED = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Prism::Pack::Directive
  def describe(); end

  def endian(); end

  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  def length(); end

  def length_type(); end

  def signed(); end

  def size(); end

  def source(); end

  def type(); end

  def variant(); end

  def version(); end
  ENDIAN_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  SIGNED_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  SIZE_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
end

class Prism::Pack::Directive
end

class Prism::Pack::Format
  def describe(); end

  def directives(); end

  def encoding(); end

  def initialize(directives, encoding); end
end

class Prism::Pack::Format
end

module Prism::Pack
  def self.parse(arg, arg1, arg2); end
end

class Prism::ParametersNode
  def accept(visitor); end

  def block(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword_rest(); end

  def keywords(); end

  def optionals(); end

  def posts(); end

  def requireds(); end

  def rest(); end

  def signature(); end

  def type(); end
end

class Prism::ParametersNode
  def self.type(); end
end

class Prism::ParenthesesNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(body, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def type(); end
end

class Prism::ParenthesesNode
  def self.type(); end
end

class Prism::ParseError
  def deconstruct_keys(keys); end

  def initialize(message, location); end

  def location(); end

  def message(); end
end

class Prism::ParseError
end

class Prism::ParseResult
  def attach_comments!(); end

  def comments(); end

  def data_loc(); end

  def deconstruct_keys(keys); end

  def errors(); end

  def failure?(); end

  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  def magic_comments(); end

  def mark_newlines!(); end

  def source(); end

  def success?(); end

  def value(); end

  def warnings(); end
end

class Prism::ParseResult
end

class Prism::ParseWarning
  def deconstruct_keys(keys); end

  def initialize(message, location); end

  def location(); end

  def message(); end
end

class Prism::ParseWarning
end

class Prism::Pattern
  def compile(); end

  def initialize(query); end

  def query(); end

  def scan(root); end
end

class Prism::Pattern::CompilationError
  def initialize(repr); end
end

class Prism::Pattern::CompilationError
end

class Prism::Pattern
end

class Prism::PinnedExpressionNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def lparen(); end

  def lparen_loc(); end

  def operator(); end

  def operator_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end
end

class Prism::PinnedExpressionNode
  def self.type(); end
end

class Prism::PinnedVariableNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(variable, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def type(); end

  def variable(); end
end

class Prism::PinnedVariableNode
  def self.type(); end
end

class Prism::PostExecutionNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def opening(); end

  def opening_loc(); end

  def statements(); end

  def type(); end
end

class Prism::PostExecutionNode
  def self.type(); end
end

class Prism::PreExecutionNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def opening(); end

  def opening_loc(); end

  def statements(); end

  def type(); end
end

class Prism::PreExecutionNode
  def self.type(); end
end

class Prism::ProgramNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(locals, statements, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def statements(); end

  def type(); end
end

class Prism::ProgramNode
  def self.type(); end
end

module Prism::RangeFlags
  EXCLUDE_END = ::T.let(nil, ::T.untyped)
end

module Prism::RangeFlags
end

class Prism::RangeNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def exclude_end?(); end

  def initialize(flags, left, right, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def type(); end
end

class Prism::RangeNode
  def self.type(); end
end

class Prism::RationalNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(numeric, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def numeric(); end

  def type(); end

  def value(); end
end

class Prism::RationalNode
  def self.type(); end
end

class Prism::RedoNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::RedoNode
  def self.type(); end
end

module Prism::RegularExpressionFlags
  ASCII_8BIT = ::T.let(nil, ::T.untyped)
  EUC_JP = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_US_ASCII_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
  IGNORE_CASE = ::T.let(nil, ::T.untyped)
  MULTI_LINE = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
  WINDOWS_31J = ::T.let(nil, ::T.untyped)
end

module Prism::RegularExpressionFlags
end

class Prism::RegularExpressionNode
  include ::Prism::RegularExpressionOptions
  def accept(visitor); end

  def ascii_8bit?(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def content(); end

  def content_loc(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def type(); end

  def unescaped(); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::RegularExpressionNode
  def self.type(); end
end

module Prism::RegularExpressionOptions
  def options(); end
end

module Prism::RegularExpressionOptions
end

class Prism::RequiredKeywordParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def type(); end
end

class Prism::RequiredKeywordParameterNode
  def self.type(); end
end

class Prism::RequiredParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Prism::RequiredParameterNode
  def self.type(); end
end

class Prism::RescueModifierNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(expression, keyword_loc, rescue_expression, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def rescue_expression(); end

  def type(); end
end

class Prism::RescueModifierNode
  def self.type(); end
end

class Prism::RescueNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def consequent(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def exceptions(); end

  def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def operator(); end

  def operator_loc(); end

  def reference(); end

  def statements(); end

  def type(); end
end

class Prism::RescueNode
  def self.type(); end
end

class Prism::RestParameterNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(name, name_loc, operator_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::RestParameterNode
  def self.type(); end
end

class Prism::RetryNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::RetryNode
  def self.type(); end
end

class Prism::ReturnNode
  def accept(visitor); end

  def arguments(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(keyword_loc, arguments, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def type(); end
end

class Prism::ReturnNode
  def self.type(); end
end

class Prism::RipperCompat
  def column(); end

  def error?(); end

  def initialize(source); end

  def lineno(); end

  def parse(); end

  def source(); end
end

class Prism::RipperCompat::SexpBuilder
end

class Prism::RipperCompat::SexpBuilder
end

class Prism::RipperCompat::SexpBuilderPP
end

class Prism::RipperCompat::SexpBuilderPP
end

class Prism::RipperCompat
  def self.sexp(source); end

  def self.sexp_raw(source); end
end

class Prism::SelfNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::SelfNode
  def self.type(); end
end

module Prism::Serialize
  MAJOR_VERSION = ::T.let(nil, ::T.untyped)
  MINOR_VERSION = ::T.let(nil, ::T.untyped)
  PATCH_VERSION = ::T.let(nil, ::T.untyped)
  TOKEN_TYPES = ::T.let(nil, ::T.untyped)
end

class Prism::Serialize::Loader
  def constant_pool(); end

  def constant_pool_offset(); end

  def encoding(); end

  def initialize(source, serialized); end

  def input(); end

  def io(); end

  def load_comments(); end

  def load_encoding(); end

  def load_header(); end

  def load_metadata(); end

  def load_nodes(); end

  def load_result(); end

  def load_start_line(); end

  def load_tokens(); end

  def load_tokens_result(); end

  def serialized(); end

  def source(); end

  def start_line(); end
end

class Prism::Serialize::Loader
end

module Prism::Serialize
  def self.load(input, serialized); end

  def self.load_tokens(source, serialized); end
end

class Prism::SingletonClassNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def class_keyword(); end

  def class_keyword_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def expression(); end

  def initialize(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def locals(); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::SingletonClassNode
  def self.type(); end
end

class Prism::Source
  def character_column(byte_offset); end

  def character_offset(byte_offset); end

  def column(byte_offset); end

  def initialize(source, start_line=T.unsafe(nil), offsets=T.unsafe(nil)); end

  def line(byte_offset); end

  def line_start(byte_offset); end

  def offsets(); end

  def slice(byte_offset, length); end

  def source(); end

  def start_line(); end

  def start_line=(start_line); end
end

class Prism::Source
end

class Prism::SourceEncodingNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::SourceEncodingNode
  def self.type(); end
end

class Prism::SourceFileNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def filepath(); end

  def initialize(filepath, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::SourceFileNode
  def self.type(); end
end

class Prism::SourceLineNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::SourceLineNode
  def self.type(); end
end

class Prism::SplatNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(operator_loc, expression, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def operator(); end

  def operator_loc(); end

  def type(); end
end

class Prism::SplatNode
  def self.type(); end
end

class Prism::StatementsNode
  def accept(visitor); end

  def body(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(body, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::StatementsNode
  def self.type(); end
end

module Prism::StringFlags
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
  FROZEN = ::T.let(nil, ::T.untyped)
end

module Prism::StringFlags
end

class Prism::StringNode
  include ::Prism::HeredocQuery
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def content(); end

  def content_loc(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def forced_binary_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def type(); end

  def unescaped(); end
end

class Prism::StringNode
  def self.type(); end
end

class Prism::SuperNode
  def accept(visitor); end

  def arguments(); end

  def block(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def lparen(); end

  def lparen_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end
end

class Prism::SuperNode
  def self.type(); end
end

module Prism::SymbolFlags
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_US_ASCII_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
end

module Prism::SymbolFlags
end

class Prism::SymbolNode
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(flags, opening_loc, value_loc, closing_loc, unescaped, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def type(); end

  def unescaped(); end

  def value(); end

  def value_loc(); end
end

class Prism::SymbolNode
  def self.type(); end
end

class Prism::Token
  def ==(other); end

  def deconstruct_keys(keys); end

  def initialize(type, value, location); end

  def location(); end

  def type(); end

  def value(); end
end

class Prism::Token
end

class Prism::TrueNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(location); end

  def inspect(inspector=T.unsafe(nil)); end

  def type(); end
end

class Prism::TrueNode
  def self.type(); end
end

class Prism::UndefNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(names, keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def names(); end

  def type(); end
end

class Prism::UndefNode
  def self.type(); end
end

class Prism::UnlessNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def consequent(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def predicate(); end

  def statements(); end

  def then_keyword(); end

  def then_keyword_loc(); end

  def type(); end
end

class Prism::UnlessNode
  def self.type(); end
end

class Prism::UntilNode
  def accept(visitor); end

  def begin_modifier?(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, keyword_loc, closing_loc, predicate, statements, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def predicate(); end

  def statements(); end

  def type(); end
end

class Prism::UntilNode
  def self.type(); end
end

class Prism::Visitor
  def visit_alias_global_variable_node(node); end

  def visit_alias_method_node(node); end

  def visit_alternation_pattern_node(node); end

  def visit_and_node(node); end

  def visit_arguments_node(node); end

  def visit_array_node(node); end

  def visit_array_pattern_node(node); end

  def visit_assoc_node(node); end

  def visit_assoc_splat_node(node); end

  def visit_back_reference_read_node(node); end

  def visit_begin_node(node); end

  def visit_block_argument_node(node); end

  def visit_block_local_variable_node(node); end

  def visit_block_node(node); end

  def visit_block_parameter_node(node); end

  def visit_block_parameters_node(node); end

  def visit_break_node(node); end

  def visit_call_and_write_node(node); end

  def visit_call_node(node); end

  def visit_call_operator_write_node(node); end

  def visit_call_or_write_node(node); end

  def visit_call_target_node(node); end

  def visit_capture_pattern_node(node); end

  def visit_case_match_node(node); end

  def visit_case_node(node); end

  def visit_class_node(node); end

  def visit_class_variable_and_write_node(node); end

  def visit_class_variable_operator_write_node(node); end

  def visit_class_variable_or_write_node(node); end

  def visit_class_variable_read_node(node); end

  def visit_class_variable_target_node(node); end

  def visit_class_variable_write_node(node); end

  def visit_constant_and_write_node(node); end

  def visit_constant_operator_write_node(node); end

  def visit_constant_or_write_node(node); end

  def visit_constant_path_and_write_node(node); end

  def visit_constant_path_node(node); end

  def visit_constant_path_operator_write_node(node); end

  def visit_constant_path_or_write_node(node); end

  def visit_constant_path_target_node(node); end

  def visit_constant_path_write_node(node); end

  def visit_constant_read_node(node); end

  def visit_constant_target_node(node); end

  def visit_constant_write_node(node); end

  def visit_def_node(node); end

  def visit_defined_node(node); end

  def visit_else_node(node); end

  def visit_embedded_statements_node(node); end

  def visit_embedded_variable_node(node); end

  def visit_ensure_node(node); end

  def visit_false_node(node); end

  def visit_find_pattern_node(node); end

  def visit_flip_flop_node(node); end

  def visit_float_node(node); end

  def visit_for_node(node); end

  def visit_forwarding_arguments_node(node); end

  def visit_forwarding_parameter_node(node); end

  def visit_forwarding_super_node(node); end

  def visit_global_variable_and_write_node(node); end

  def visit_global_variable_operator_write_node(node); end

  def visit_global_variable_or_write_node(node); end

  def visit_global_variable_read_node(node); end

  def visit_global_variable_target_node(node); end

  def visit_global_variable_write_node(node); end

  def visit_hash_node(node); end

  def visit_hash_pattern_node(node); end

  def visit_if_node(node); end

  def visit_imaginary_node(node); end

  def visit_implicit_node(node); end

  def visit_implicit_rest_node(node); end

  def visit_in_node(node); end

  def visit_index_and_write_node(node); end

  def visit_index_operator_write_node(node); end

  def visit_index_or_write_node(node); end

  def visit_index_target_node(node); end

  def visit_instance_variable_and_write_node(node); end

  def visit_instance_variable_operator_write_node(node); end

  def visit_instance_variable_or_write_node(node); end

  def visit_instance_variable_read_node(node); end

  def visit_instance_variable_target_node(node); end

  def visit_instance_variable_write_node(node); end

  def visit_integer_node(node); end

  def visit_interpolated_match_last_line_node(node); end

  def visit_interpolated_regular_expression_node(node); end

  def visit_interpolated_string_node(node); end

  def visit_interpolated_symbol_node(node); end

  def visit_interpolated_x_string_node(node); end

  def visit_keyword_hash_node(node); end

  def visit_keyword_rest_parameter_node(node); end

  def visit_lambda_node(node); end

  def visit_local_variable_and_write_node(node); end

  def visit_local_variable_operator_write_node(node); end

  def visit_local_variable_or_write_node(node); end

  def visit_local_variable_read_node(node); end

  def visit_local_variable_target_node(node); end

  def visit_local_variable_write_node(node); end

  def visit_match_last_line_node(node); end

  def visit_match_predicate_node(node); end

  def visit_match_required_node(node); end

  def visit_match_write_node(node); end

  def visit_missing_node(node); end

  def visit_module_node(node); end

  def visit_multi_target_node(node); end

  def visit_multi_write_node(node); end

  def visit_next_node(node); end

  def visit_nil_node(node); end

  def visit_no_keywords_parameter_node(node); end

  def visit_numbered_parameters_node(node); end

  def visit_numbered_reference_read_node(node); end

  def visit_optional_keyword_parameter_node(node); end

  def visit_optional_parameter_node(node); end

  def visit_or_node(node); end

  def visit_parameters_node(node); end

  def visit_parentheses_node(node); end

  def visit_pinned_expression_node(node); end

  def visit_pinned_variable_node(node); end

  def visit_post_execution_node(node); end

  def visit_pre_execution_node(node); end

  def visit_program_node(node); end

  def visit_range_node(node); end

  def visit_rational_node(node); end

  def visit_redo_node(node); end

  def visit_regular_expression_node(node); end

  def visit_required_keyword_parameter_node(node); end

  def visit_required_parameter_node(node); end

  def visit_rescue_modifier_node(node); end

  def visit_rescue_node(node); end

  def visit_rest_parameter_node(node); end

  def visit_retry_node(node); end

  def visit_return_node(node); end

  def visit_self_node(node); end

  def visit_singleton_class_node(node); end

  def visit_source_encoding_node(node); end

  def visit_source_file_node(node); end

  def visit_source_line_node(node); end

  def visit_splat_node(node); end

  def visit_statements_node(node); end

  def visit_string_node(node); end

  def visit_super_node(node); end

  def visit_symbol_node(node); end

  def visit_true_node(node); end

  def visit_undef_node(node); end

  def visit_unless_node(node); end

  def visit_until_node(node); end

  def visit_when_node(node); end

  def visit_while_node(node); end

  def visit_x_string_node(node); end

  def visit_yield_node(node); end
end

class Prism::Visitor
end

class Prism::WhenNode
  def accept(visitor); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def conditions(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(keyword_loc, conditions, statements, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def statements(); end

  def type(); end
end

class Prism::WhenNode
  def self.type(); end
end

class Prism::WhileNode
  def accept(visitor); end

  def begin_modifier?(); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(flags, keyword_loc, closing_loc, predicate, statements, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def predicate(); end

  def statements(); end

  def type(); end
end

class Prism::WhileNode
  def self.type(); end
end

class Prism::XStringNode
  include ::Prism::HeredocQuery
  def accept(visitor); end

  def child_nodes(); end

  def closing(); end

  def closing_loc(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def content(); end

  def content_loc(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def forced_binary_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def opening(); end

  def opening_loc(); end

  def type(); end

  def unescaped(); end
end

class Prism::XStringNode
  def self.type(); end
end

class Prism::YieldNode
  def accept(visitor); end

  def arguments(); end

  def child_nodes(); end

  def comment_targets(); end

  def compact_child_nodes(); end

  def copy(**params); end

  def deconstruct(); end

  def deconstruct_keys(keys); end

  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  def inspect(inspector=T.unsafe(nil)); end

  def keyword(); end

  def keyword_loc(); end

  def lparen(); end

  def lparen_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def type(); end
end

class Prism::YieldNode
  def self.type(); end
end

module Prism
  def self.dump(*arg); end

  def self.dump_file(*arg); end

  def self.lex(*arg); end

  def self.lex_compat(source, **options); end

  def self.lex_file(*arg); end

  def self.lex_ripper(source); end

  def self.load(source, serialized); end

  def self.parse(*arg); end

  def self.parse_comments(*arg); end

  def self.parse_failure?(source, **options); end

  def self.parse_file(*arg); end

  def self.parse_file_comments(*arg); end

  def self.parse_file_failure?(filepath, **options); end

  def self.parse_file_success?(*arg); end

  def self.parse_lex(*arg); end

  def self.parse_lex_file(*arg); end

  def self.parse_success?(*arg); end
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module Process
  CLOCK_TAI = ::T.let(nil, ::T.untyped)
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::ActiveSupport::ForkTracker::CoreExt
  def self.exit(*arg); end
end

module Psych
  LOADER_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::AliasesNotEnabled
  def initialize(); end
end

class Psych::AliasesNotEnabled
end

class Psych::AnchorNotDefined
  def initialize(anchor_name); end
end

class Psych::AnchorNotDefined
end

class Psych::ScalarScanner
  INTEGER_LEGACY = ::T.let(nil, ::T.untyped)
  INTEGER_STRICT = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  def visit_Symbol(sym); end
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
end

class Psych::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.config(); end

  def self.domain_types(); end

  def self.domain_types=(value); end

  def self.dump_tags(); end

  def self.dump_tags=(value); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(value); end

  def self.remove_type(type_tag); end

  def self.safe_dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

  def self.unsafe_load_file(filename, **kwargs); end
end

module RBS
  VERSION = ::T.let(nil, ::T.untyped)
end

module RBS::AST
end

class RBS::AST::Annotation
  def ==(other); end

  def eql?(other); end

  def initialize(string:, location:); end

  def location(); end

  def string(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Annotation
end

class RBS::AST::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(string:, location:); end

  def location(); end

  def string(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Comment
end

module RBS::AST::Declarations
end

class RBS::AST::Declarations::AliasDecl
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def initialize(new_name:, old_name:, location:, comment:); end

  def location(); end

  def new_name(); end

  def old_name(); end
end

class RBS::AST::Declarations::AliasDecl
end

class RBS::AST::Declarations::Base
end

class RBS::AST::Declarations::Base
end

class RBS::AST::Declarations::Class
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, super_class:, members:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def super_class(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end

  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), super_class: T.unsafe(nil), members: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Class::Super
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, location:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::Class::Super
end

class RBS::AST::Declarations::Class
end

class RBS::AST::Declarations::ClassAlias
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::ClassAlias
end

class RBS::AST::Declarations::Constant
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::AST::Declarations::Constant
end

class RBS::AST::Declarations::Global
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::AST::Declarations::Global
end

class RBS::AST::Declarations::Interface
  include ::RBS::AST::Declarations::MixinHelper
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end

  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), members: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Interface
end

module RBS::AST::Declarations::MixinHelper
  def each_mixin(&block); end
end

module RBS::AST::Declarations::MixinHelper
end

class RBS::AST::Declarations::Module
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, members:, self_types:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def self_types(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end

  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), members: T.unsafe(nil), self_types: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Module::Self
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, location:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::Module::Self
end

class RBS::AST::Declarations::Module
end

class RBS::AST::Declarations::ModuleAlias
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::ModuleAlias
end

module RBS::AST::Declarations::NestedDeclarationHelper
  def each_decl(); end

  def each_member(); end
end

module RBS::AST::Declarations::NestedDeclarationHelper
end

class RBS::AST::Declarations::TypeAlias
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end

  def type_params(); end
end

class RBS::AST::Declarations::TypeAlias
end

module RBS::AST::Declarations
end

module RBS::AST::Directives
end

class RBS::AST::Directives::Base
end

class RBS::AST::Directives::Base
end

class RBS::AST::Directives::Use
  def clauses(); end

  def initialize(clauses:, location:); end

  def location(); end
end

class RBS::AST::Directives::Use::SingleClause
  def initialize(type_name:, new_name:, location:); end

  def location(); end

  def new_name(); end

  def type_name(); end
end

class RBS::AST::Directives::Use::SingleClause
end

class RBS::AST::Directives::Use::WildcardClause
  def initialize(namespace:, location:); end

  def location(); end

  def namespace(); end
end

class RBS::AST::Directives::Use::WildcardClause
end

class RBS::AST::Directives::Use
end

module RBS::AST::Directives
end

module RBS::AST::Members
end

class RBS::AST::Members::Alias
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end

  def instance?(); end

  def kind(); end

  def location(); end

  def new_name(); end

  def old_name(); end

  def singleton?(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Alias
end

class RBS::AST::Members::AttrAccessor
  include ::RBS::AST::Members::Attribute
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrAccessor
end

class RBS::AST::Members::AttrReader
  include ::RBS::AST::Members::Attribute
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrReader
end

class RBS::AST::Members::AttrWriter
  include ::RBS::AST::Members::Attribute
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrWriter
end

module RBS::AST::Members::Attribute
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: T.unsafe(nil)); end

  def ivar_name(); end

  def kind(); end

  def location(); end

  def name(); end

  def type(); end

  def update(name: T.unsafe(nil), type: T.unsafe(nil), ivar_name: T.unsafe(nil), kind: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

module RBS::AST::Members::Attribute
end

class RBS::AST::Members::Base
end

class RBS::AST::Members::Base
end

class RBS::AST::Members::ClassInstanceVariable
  include ::RBS::AST::Members::Var
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::ClassInstanceVariable
end

class RBS::AST::Members::ClassVariable
  include ::RBS::AST::Members::Var
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::ClassVariable
end

class RBS::AST::Members::Extend
  include ::RBS::AST::Members::Mixin
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Extend
end

class RBS::AST::Members::Include
  include ::RBS::AST::Members::Mixin
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Include
end

class RBS::AST::Members::InstanceVariable
  include ::RBS::AST::Members::Var
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::InstanceVariable
end

module RBS::AST::Members::LocationOnly
  def ==(other); end

  def eql?(other); end

  def hash(); end

  def initialize(location:); end

  def location(); end
end

module RBS::AST::Members::LocationOnly
end

class RBS::AST::Members::MethodDefinition
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, kind:, overloads:, annotations:, location:, comment:, overloading:, visibility:); end

  def instance?(); end

  def kind(); end

  def location(); end

  def name(); end

  def overloading(); end

  def overloading?(); end

  def overloads(); end

  def singleton?(); end

  def to_json(state=T.unsafe(nil)); end

  def update(name: T.unsafe(nil), kind: T.unsafe(nil), overloads: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), overloading: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

class RBS::AST::Members::MethodDefinition::Overload
  def ==(other); end

  def annotations(); end

  def eql?(other); end

  def initialize(method_type:, annotations:); end

  def method_type(); end

  def sub(subst); end

  def to_json(state=T.unsafe(nil)); end

  def update(annotations: T.unsafe(nil), method_type: T.unsafe(nil)); end
end

class RBS::AST::Members::MethodDefinition::Overload
end

class RBS::AST::Members::MethodDefinition
end

module RBS::AST::Members::Mixin
  def ==(other); end

  def annotations(); end

  def args(); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, args:, annotations:, location:, comment:); end

  def location(); end

  def name(); end
end

module RBS::AST::Members::Mixin
end

class RBS::AST::Members::Prepend
  include ::RBS::AST::Members::Mixin
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Prepend
end

class RBS::AST::Members::Private
  include ::RBS::AST::Members::LocationOnly
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Private
end

class RBS::AST::Members::Public
  include ::RBS::AST::Members::LocationOnly
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Public
end

module RBS::AST::Members::Var
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def type(); end
end

module RBS::AST::Members::Var
end

module RBS::AST::Members
end

class RBS::AST::TypeParam
  def ==(other); end

  def default_type(); end

  def eql?(other); end

  def initialize(name:, variance:, upper_bound:, location:, default_type: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def rename(name); end

  def to_json(state=T.unsafe(nil)); end

  def unchecked!(value=T.unsafe(nil)); end

  def unchecked?(); end

  def upper_bound(); end

  def upper_bound_type(); end

  def variance(); end
end

class RBS::AST::TypeParam
  def self.application(params, args); end

  def self.normalize_args(params, args); end

  def self.rename(params, new_names:); end

  def self.resolve_variables(params); end

  def self.subst_var(vars, type); end

  def self.validate(type_params); end
end

class RBS::AST::Visitor
  def visit(node); end

  def visit_all(nodes); end

  def visit_declaration_class(node); end

  def visit_declaration_constant(node); end

  def visit_declaration_global(node); end

  def visit_declaration_interface(node); end

  def visit_declaration_module(node); end

  def visit_declaration_type_alias(node); end

  def visit_member_alias(node); end

  def visit_member_attr_accessor(node); end

  def visit_member_attr_reader(node); end

  def visit_member_attr_writer(node); end

  def visit_member_class_instance_variable(node); end

  def visit_member_class_variable(node); end

  def visit_member_extend(node); end

  def visit_member_include(node); end

  def visit_member_instance_variable(node); end

  def visit_member_method_definition(node); end

  def visit_member_prepend(node); end

  def visit_member_private(node); end

  def visit_member_public(node); end
end

class RBS::AST::Visitor
end

module RBS::AST
end

class RBS::AncestorGraph
  def ancestor_builder(); end

  def build(); end

  def build_ancestors(node, ancestors); end

  def children(); end

  def each_ancestor(node, yielded: T.unsafe(nil), &block); end

  def each_child(node, &block); end

  def each_descendant(node, yielded: T.unsafe(nil), &block); end

  def each_parent(node, &block); end

  def env(); end

  def initialize(env:, ancestor_builder: T.unsafe(nil)); end

  def parents(); end

  def register(parent:, child:); end
end

class RBS::AncestorGraph::InstanceNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::AncestorGraph::InstanceNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::AncestorGraph::SingletonNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::AncestorGraph::SingletonNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::AncestorGraph
end

class RBS::BaseError
end

class RBS::BaseError
end

class RBS::Buffer
  def content(); end

  def initialize(name:, content:); end

  def last_position(); end

  def lines(); end

  def loc_to_pos(loc); end

  def name(); end

  def pos_to_loc(pos); end

  def ranges(); end
end

class RBS::Buffer
end

module RBS::BuiltinNames
  Array = ::T.let(nil, ::T.untyped)
  BasicObject = ::T.let(nil, ::T.untyped)
  Class = ::T.let(nil, ::T.untyped)
  Comparable = ::T.let(nil, ::T.untyped)
  Enumerable = ::T.let(nil, ::T.untyped)
  Enumerator = ::T.let(nil, ::T.untyped)
  FalseClass = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Kernel = ::T.let(nil, ::T.untyped)
  Module = ::T.let(nil, ::T.untyped)
  Numeric = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  Regexp = ::T.let(nil, ::T.untyped)
  Set = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
  TrueClass = ::T.let(nil, ::T.untyped)
end

class RBS::BuiltinNames::Name
  def initialize(name:); end

  def instance_type(*args); end

  def instance_type?(type); end

  def name(); end

  def singleton_type(); end

  def singleton_type?(type); end
end

class RBS::BuiltinNames::Name
  def self.define(name, namespace: T.unsafe(nil)); end
end

module RBS::BuiltinNames
end

class RBS::CLI
end

class RBS::CLI::ColoredIO
  def initialize(stdout:); end

  def puts(*arg, **arg1, &arg2); end

  def puts_green(string); end

  def puts_red(string); end

  def stdout(); end
end

class RBS::CLI::ColoredIO
end

class RBS::CLI
end

module RBS::Collection
end

class RBS::Collection::Cleaner
  def clean(); end

  def initialize(lockfile_path:); end

  def lock(); end

  def needed?(gem_name, version); end
end

class RBS::Collection::Cleaner
end

class RBS::Collection::Config
  def config_path(); end

  def data(); end

  def gem(gem_name); end

  def gems(); end

  def initialize(data, config_path:); end

  def repo_path(); end

  def repo_path_data(); end

  def sources(); end
  PATH = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Config::CollectionNotAvailable
  def initialize(); end
end

class RBS::Collection::Config::CollectionNotAvailable
end

class RBS::Collection::Config::Lockfile
  def check_rbs_availability!(); end

  def fullpath(); end

  def gemfile_lock_fullpath(); end

  def gemfile_lock_path(); end

  def gems(); end

  def initialize(lockfile_path:, path:, gemfile_lock_path:); end

  def library_data(lib); end

  def lockfile_dir(); end

  def lockfile_path(); end

  def path(); end

  def sources(); end

  def to_lockfile(); end
end

class RBS::Collection::Config::Lockfile
  def self.from_lockfile(lockfile_path:, data:); end
end

class RBS::Collection::Config::LockfileGenerator
  def config(); end

  def definition(); end

  def existing_lockfile(); end

  def gem_entries(); end

  def gem_hash(); end

  def generate(); end

  def initialize(config:, definition:, with_lockfile:); end

  def lockfile(); end
  ALUMNI_STDLIBS = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError
  def initialize(expected:, actual:); end
end

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError
end

class RBS::Collection::Config::LockfileGenerator
  def self.generate(config:, definition:, with_lockfile: T.unsafe(nil)); end
end

class RBS::Collection::Config
  def self.find_config_path(); end

  def self.from_path(path); end

  def self.generate_lockfile(config_path:, definition:, with_lockfile: T.unsafe(nil)); end

  def self.to_lockfile_path(config_path); end
end

class RBS::Collection::Installer
  def initialize(lockfile_path:, stdout: T.unsafe(nil)); end

  def install_from_lockfile(); end

  def lockfile(); end

  def stdout(); end
end

class RBS::Collection::Installer
end

module RBS::Collection::Sources
end

module RBS::Collection::Sources::Base
  def dependencies_of(name, version); end
end

module RBS::Collection::Sources::Base
end

class RBS::Collection::Sources::Git
  include ::RBS::Collection::Sources::Base
  def has?(name, version); end

  def initialize(name:, revision:, remote:, repo_dir:); end

  def install(dest:, name:, version:, stdout:); end

  def load_metadata(dir:); end

  def manifest_of(name, version); end

  def metadata_content(name:, version:); end

  def name(); end

  def remote(); end

  def repo_dir(); end

  def resolved_revision(); end

  def revision(); end

  def to_lockfile(); end

  def versions(name); end

  def write_metadata(dir:, name:, version:); end
  METADATA_FILENAME = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Git::CommandError
end

class RBS::Collection::Sources::Git::CommandError
end

class RBS::Collection::Sources::Git
end

class RBS::Collection::Sources::Local
  include ::RBS::Collection::Sources::Base
  def full_path(); end

  def has?(name, version); end

  def initialize(path:, base_directory:); end

  def install(dest:, name:, version:, stdout:); end

  def manifest_of(name, version); end

  def path(); end

  def to_lockfile(); end

  def versions(name); end
end

class RBS::Collection::Sources::Local
end

class RBS::Collection::Sources::Rubygems
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  include ::Singleton::SingletonInstanceMethods
  def has?(name, version); end

  def install(dest:, name:, version:, stdout:); end

  def manifest_of(name, version); end

  def to_lockfile(); end

  def versions(name); end
end

class RBS::Collection::Sources::Rubygems
  extend ::Singleton::SingletonClassMethods
end

class RBS::Collection::Sources::Stdlib
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  include ::Singleton::SingletonInstanceMethods
  def has?(name, version); end

  def install(dest:, name:, version:, stdout:); end

  def manifest_of(name, version); end

  def to_lockfile(); end

  def versions(name); end
  REPO = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Stdlib
  extend ::Singleton::SingletonClassMethods
end

module RBS::Collection::Sources
  def self.from_config_entry(source_entry, base_directory:); end
end

module RBS::Collection
end

class RBS::Constant
  def ==(other); end

  def entry(); end

  def eql?(other); end

  def initialize(name:, type:, entry:); end

  def name(); end

  def type(); end
end

class RBS::Constant
end

class RBS::CyclicClassAliasDefinitionError
  include ::RBS::DetailedMessageable
  def alias_entry(); end

  def initialize(entry); end

  def location(); end
end

class RBS::CyclicClassAliasDefinitionError
end

class RBS::CyclicTypeParameterBound
  include ::RBS::DetailedMessageable
  def initialize(type_name:, method_name:, params:, location:); end

  def location(); end

  def method_name(); end

  def params(); end

  def type_name(); end
end

class RBS::CyclicTypeParameterBound
end

class RBS::Definition
  def ancestors(); end

  def class?(); end

  def class_type?(); end

  def class_variables(); end

  def each_type(&block); end

  def entry(); end

  def initialize(type_name:, entry:, self_type:, ancestors:); end

  def instance_type?(); end

  def interface?(); end

  def interface_type?(); end

  def map_method_type(&block); end

  def methods(); end

  def module?(); end

  def self_type(); end

  def sub(s); end

  def type_name(); end

  def type_params(); end

  def type_params_decl(); end
end

module RBS::Definition::Ancestor
end

class RBS::Definition::Ancestor::Instance
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, source:); end

  def name(); end

  def source(); end
end

class RBS::Definition::Ancestor::Instance
end

class RBS::Definition::Ancestor::Singleton
  def ==(other); end

  def eql?(other); end

  def initialize(name:); end

  def name(); end
end

class RBS::Definition::Ancestor::Singleton
end

module RBS::Definition::Ancestor
end

class RBS::Definition::InstanceAncestors
  def ancestors(); end

  def apply(args, env:, location:); end

  def initialize(type_name:, params:, ancestors:); end

  def params(); end

  def type_name(); end
end

class RBS::Definition::InstanceAncestors
end

class RBS::Definition::Method
  def ==(other); end

  def accessibility(); end

  def alias_of(); end

  def annotations(); end

  def comments(); end

  def defined_in(); end

  def defs(); end

  def eql?(other); end

  def extra_annotations(); end

  def implemented_in(); end

  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: T.unsafe(nil)); end

  def map_method_type(&block); end

  def map_type(&block); end

  def map_type_bound(&block); end

  def members(); end

  def method_types(); end

  def private?(); end

  def public?(); end

  def sub(s); end

  def super_method(); end

  def update(super_method: T.unsafe(nil), defs: T.unsafe(nil), accessibility: T.unsafe(nil), alias_of: T.unsafe(nil), annotations: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
  def ==(other); end

  def annotations(); end

  def comment(); end

  def defined_in(); end

  def eql?(other); end

  def implemented_in(); end

  def initialize(type:, member:, defined_in:, implemented_in:, overload_annotations: T.unsafe(nil)); end

  def member(); end

  def member_annotations(); end

  def overload?(); end

  def overload_annotations(); end

  def type(); end

  def update(type: T.unsafe(nil), member: T.unsafe(nil), defined_in: T.unsafe(nil), implemented_in: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
end

class RBS::Definition::Method
end

class RBS::Definition::SingletonAncestors
  def ancestors(); end

  def initialize(type_name:, ancestors:); end

  def type_name(); end
end

class RBS::Definition::SingletonAncestors
end

class RBS::Definition::Variable
  def declared_in(); end

  def initialize(parent_variable:, type:, declared_in:); end

  def parent_variable(); end

  def sub(s); end

  def type(); end
end

class RBS::Definition::Variable
end

class RBS::Definition
end

class RBS::DefinitionBuilder
  def ancestor_builder(); end

  def build_instance(type_name); end

  def build_interface(type_name); end

  def build_singleton(type_name); end

  def build_singleton0(type_name); end

  def define_instance(definition, type_name, subst); end

  def define_interface(definition, type_name, subst); end

  def define_method(methods, definition, method, subst, self_type_methods, defined_in:, implemented_in: T.unsafe(nil)); end

  def ensure_namespace!(namespace, location:); end

  def env(); end

  def expand_alias(type_name); end

  def expand_alias1(type_name); end

  def expand_alias2(type_name, args); end

  def import_methods(definition, module_name, module_methods, interfaces_methods, subst, self_type_methods); end

  def initialize(env:, ancestor_builder: T.unsafe(nil), method_builder: T.unsafe(nil)); end

  def insert_variable(type_name, variables, name:, type:); end

  def instance_cache(); end

  def interface_cache(); end

  def interface_methods(interface_ancestors); end

  def method_builder(); end

  def singleton0_cache(); end

  def singleton_cache(); end

  def source_location(source, decl); end

  def tapp_subst(name, args); end

  def try_cache(type_name, cache:); end

  def update(env:, except:, ancestor_builder:); end

  def validate_params_with(type_params, result:); end

  def validate_type_name(name, location); end

  def validate_type_params(definition, ancestors:, methods:); end

  def validate_type_presence(type); end
end

class RBS::DefinitionBuilder::AncestorBuilder
  def env(); end

  def fill_ancestor_source(ancestor, name:, source:, &block); end

  def initialize(env:); end

  def instance_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def instance_ancestors_cache(); end

  def interface_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def interface_ancestors_cache(); end

  def mixin_ancestors(entry, type_name, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end

  def mixin_ancestors0(decl, type_name, align_params:, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end

  def one_instance_ancestors(type_name); end

  def one_instance_ancestors_cache(); end

  def one_interface_ancestors(type_name); end

  def one_interface_ancestors_cache(); end

  def one_singleton_ancestors(type_name); end

  def one_singleton_ancestors_cache(); end

  def singleton_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def singleton_ancestors_cache(); end

  def validate_super_class!(type_name, entry); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def each_ancestor(&block); end

  def each_extended_interface(&block); end

  def each_extended_module(&block); end

  def each_included_interface(&block); end

  def each_included_module(&block); end

  def each_prepended_module(&block); end

  def each_self_type(&block); end

  def extended_interfaces(); end

  def extended_modules(); end

  def included_interfaces(); end

  def included_modules(); end

  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  def params(); end

  def prepended_modules(); end

  def self_types(); end

  def super_class(); end

  def type_name(); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def self.class_instance(type_name:, params:, super_class:); end

  def self.interface(type_name:, params:); end

  def self.module_instance(type_name:, params:); end

  def self.singleton(type_name:, super_class:); end
end

class RBS::DefinitionBuilder::AncestorBuilder
end

class RBS::DefinitionBuilder::MethodBuilder
  def build_alias(methods, type, member:); end

  def build_attribute(methods, type, member:, accessibility:); end

  def build_instance(type_name); end

  def build_interface(type_name); end

  def build_method(methods, type, member:, accessibility:); end

  def build_singleton(type_name); end

  def each_member_with_accessibility(members, accessibility: T.unsafe(nil)); end

  def env(); end

  def initialize(env:); end

  def instance_methods(); end

  def interface_methods(); end

  def singleton_methods(); end

  def update(env:, except:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
  def each(&blk); end

  def initialize(type:); end

  def methods(); end

  def type(); end

  def validate!(); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition
  def accessibility(); end

  def original(); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition
  def self.empty(name:, type:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  include ::TSort
  def initialize(methods); end

  def methods(); end

  def tsort_each_child(defn); end

  def tsort_each_node(&block); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
end

class RBS::DefinitionBuilder::MethodBuilder
end

class RBS::DefinitionBuilder
end

class RBS::DefinitionError
end

class RBS::DefinitionError
end

module RBS::DetailedMessageable
  def detailed_message(highlight: T.unsafe(nil), **arg); end
end

module RBS::DetailedMessageable
end

class RBS::Diff
  def each_diff(&block); end

  def initialize(type_name:, library_options:, after_path: T.unsafe(nil), before_path: T.unsafe(nil), detail: T.unsafe(nil)); end
end

class RBS::Diff
end

class RBS::DuplicatedDeclarationError
  def decls(); end

  def initialize(name, *decls); end

  def name(); end
end

class RBS::DuplicatedDeclarationError
end

class RBS::DuplicatedInterfaceMethodDefinitionError
  include ::RBS::DetailedMessageable
  def initialize(type:, method_name:, member:); end

  def location(); end

  def member(); end

  def method_name(); end

  def qualified_method_name(); end

  def type(); end

  def type_name(); end
end

class RBS::DuplicatedInterfaceMethodDefinitionError
end

class RBS::DuplicatedMethodDefinitionError
  include ::RBS::DetailedMessageable
  def initialize(type:, method_name:, members:); end

  def location(); end

  def members(); end

  def method_name(); end

  def other_locations(); end

  def qualified_method_name(); end

  def type(); end

  def type_name(); end
end

class RBS::DuplicatedMethodDefinitionError
end

class RBS::Environment
  def <<(decl); end

  def absolute_type(resolver, map, type, context:); end

  def absolute_type_name(resolver, map, type_name, context:); end

  def add_signature(buffer:, directives:, decls:); end

  def append_context(context, decl); end

  def buffers(); end

  def class_alias?(name); end

  def class_alias_decls(); end

  def class_decl?(name); end

  def class_decls(); end

  def class_entry(type_name); end

  def constant_decl?(name); end

  def constant_decls(); end

  def constant_entry(type_name); end

  def constant_name?(name); end

  def declarations(); end

  def global_decls(); end

  def insert_decl(decl, outer:, namespace:); end

  def interface_decls(); end

  def interface_name?(name); end

  def module_alias?(name); end

  def module_class_entry(type_name); end

  def module_decl?(name); end

  def module_entry(type_name); end

  def module_name?(name); end

  def normalize_module_name(name); end

  def normalize_module_name?(name); end

  def normalize_type_name(name); end

  def normalize_type_name!(name); end

  def normalize_type_name?(name); end

  def normalized_class_entry(type_name); end

  def normalized_module_class_entry(type_name); end

  def normalized_module_entry(type_name); end

  def normalized_type_name!(name); end

  def normalized_type_name?(type_name); end

  def resolve_declaration(resolver, map, decl, outer:, prefix:); end

  def resolve_member(resolver, map, member, context:); end

  def resolve_method_type(resolver, map, type, context:); end

  def resolve_type_names(only: T.unsafe(nil)); end

  def resolve_type_params(resolver, map, params, context:); end

  def resolver_context(*nesting); end

  def signatures(); end

  def type_alias_decls(); end

  def type_alias_name?(name); end

  def type_name?(name); end

  def unload(buffers); end

  def validate_type_params(); end
end

class RBS::Environment::ClassAliasEntry
end

class RBS::Environment::ClassAliasEntry
end

class RBS::Environment::ClassEntry
end

class RBS::Environment::ClassEntry
end

class RBS::Environment::ConstantEntry
end

class RBS::Environment::ConstantEntry
end

module RBS::Environment::ContextUtil
  def calculate_context(decls); end
end

module RBS::Environment::ContextUtil
end

class RBS::Environment::GlobalEntry
end

class RBS::Environment::GlobalEntry
end

class RBS::Environment::InterfaceEntry
end

class RBS::Environment::InterfaceEntry
end

class RBS::Environment::ModuleAliasEntry
end

class RBS::Environment::ModuleAliasEntry
end

class RBS::Environment::ModuleEntry
  def self_types(); end
end

class RBS::Environment::ModuleEntry
end

class RBS::Environment::MultiEntry
  def compatible_params?(ps1, ps2); end

  def decls(); end

  def initialize(name:); end

  def insert(decl:, outer:); end

  def name(); end

  def primary(); end

  def type_params(); end

  def validate_type_params(); end
end

class RBS::Environment::MultiEntry::D
  include ::RBS::Environment::ContextUtil
  def context(); end

  def decl(); end

  def decl=(_); end

  def outer(); end

  def outer=(_); end
end

class RBS::Environment::MultiEntry::D
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Environment::MultiEntry
end

class RBS::Environment::SingleEntry
  include ::RBS::Environment::ContextUtil
  def context(); end

  def decl(); end

  def initialize(name:, decl:, outer:); end

  def name(); end

  def outer(); end
end

class RBS::Environment::SingleEntry
end

class RBS::Environment::TypeAliasEntry
end

class RBS::Environment::TypeAliasEntry
end

class RBS::Environment::UseMap
  def build_map(clause); end

  def initialize(table:); end

  def resolve(type_name); end

  def resolve?(type_name); end

  def use_dirs(); end
end

class RBS::Environment::UseMap::Table
  def children(); end

  def compute_children(); end

  def known_types(); end
end

class RBS::Environment::UseMap::Table
end

class RBS::Environment::UseMap
end

class RBS::Environment
  def self.from_loader(loader); end
end

class RBS::EnvironmentLoader
  include ::RBS::FileFinder
  def add(path: T.unsafe(nil), library: T.unsafe(nil), version: T.unsafe(nil), resolve_dependencies: T.unsafe(nil)); end

  def add_collection(lockfile); end

  def core_root(); end

  def dirs(); end

  def each_dir(); end

  def each_signature(); end

  def has_library?(library:, version:); end

  def initialize(core_root: T.unsafe(nil), repository: T.unsafe(nil)); end

  def libs(); end

  def load(env:); end

  def repository(); end

  def resolve_dependencies(library:, version:); end
  DEFAULT_CORE_ROOT = ::T.let(nil, ::T.untyped)
end

class RBS::EnvironmentLoader::Library
end

class RBS::EnvironmentLoader::Library
end

class RBS::EnvironmentLoader::UnknownLibraryError
  def initialize(lib:); end

  def library(); end
end

class RBS::EnvironmentLoader::UnknownLibraryError
end

class RBS::EnvironmentLoader
  def self.gem_sig_path(name, version); end
end

class RBS::EnvironmentWalker
  include ::TSort
  def builder(); end

  def each_type_name(type, &block); end

  def each_type_node(type, &block); end

  def env(); end

  def initialize(env:); end

  def only_ancestors!(only=T.unsafe(nil)); end

  def only_ancestors?(); end

  def tsort_each_child(node, &block); end

  def tsort_each_node(&block); end
end

class RBS::EnvironmentWalker::InstanceNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::InstanceNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker::SingletonNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::SingletonNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker::TypeNameNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::TypeNameNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker
end

class RBS::Factory
  def type_name(string); end
end

class RBS::Factory
end

module RBS::FileFinder
end

module RBS::FileFinder
  def self.each_file(path, skip_hidden:, immediate: T.unsafe(nil), &block); end
end

class RBS::GenericParameterMismatchError
  def decl(); end

  def initialize(name:, decl:); end

  def name(); end
end

class RBS::GenericParameterMismatchError
end

class RBS::InconsistentClassModuleAliasError
  include ::RBS::DetailedMessageable
  def alias_entry(); end

  def initialize(entry); end

  def location(); end
end

class RBS::InconsistentClassModuleAliasError
end

class RBS::InheritModuleError
  include ::RBS::DetailedMessageable
  def initialize(super_decl); end

  def location(); end

  def super_decl(); end
end

class RBS::InheritModuleError
  def self.check!(super_decl, env:); end
end

class RBS::InvalidOverloadMethodError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, method_name:, kind:, members:); end

  def kind(); end

  def location(); end

  def members(); end

  def method_name(); end

  def type_name(); end
end

class RBS::InvalidOverloadMethodError
end

class RBS::InvalidTypeApplicationError
  def args(); end

  def initialize(type_name:, args:, params:, location:); end

  def location(); end

  def params(); end

  def type_name(); end

  def type_params(); end
end

class RBS::InvalidTypeApplicationError
  def self.check!(type_name:, args:, params:, location:); end

  def self.check2!(env:, type_name:, args:, location:); end
end

class RBS::InvalidVarianceAnnotationError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, param:, location:); end

  def location(); end

  def param(); end

  def type_name(); end
end

class RBS::InvalidVarianceAnnotationError
end

class RBS::LoadingError
end

class RBS::LoadingError
end

class RBS::Location
  def ==(other); end

  def [](arg); end

  def _add_optional_child(arg, arg1, arg2); end

  def _add_optional_no_child(arg); end

  def _add_required_child(arg, arg1, arg2); end

  def _optional_keys(); end

  def _required_keys(); end

  def add_optional_child(name, range); end

  def add_required_child(name, range); end

  def aref(arg); end

  def as_lsp_range(); end

  def buffer(); end

  def each_optional_key(&block); end

  def each_required_key(&block); end

  def end_column(); end

  def end_line(); end

  def end_loc(); end

  def end_pos(); end

  def initialize(arg, arg1, arg2); end

  def key?(name); end

  def name(); end

  def optional_key?(name); end

  def range(); end

  def required_key?(name); end

  def source(); end

  def start_column(); end

  def start_line(); end

  def start_loc(); end

  def start_pos(); end

  def to_json(state=T.unsafe(nil)); end
end

RBS::Location::WithChildren = RBS::Location

class RBS::Location
  def self.new(buffer_=T.unsafe(nil), start_pos_=T.unsafe(nil), end_pos_=T.unsafe(nil), buffer: T.unsafe(nil), start_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def self.to_string(location, default: T.unsafe(nil)); end
end

class RBS::Locator
  def buffer(); end

  def decls(); end

  def dirs(); end

  def find(line:, column:); end

  def find2(line:, column:); end

  def find_in_decl(pos, decl:, array:); end

  def find_in_directive(pos, dir, array); end

  def find_in_loc(pos, location:, array:); end

  def find_in_member(pos, member:, array:); end

  def find_in_method_type(pos, method_type:, array:); end

  def find_in_type(pos, type:, array:); end

  def find_in_type_param(pos, type_param:, array:); end

  def initialize(buffer:, dirs:, decls:); end

  def test_loc(pos, location:); end
end

class RBS::Locator
end

module RBS::MethodNameHelper
  def method_name_string(); end
end

module RBS::MethodNameHelper
end

class RBS::MethodType
  def ==(other); end

  def block(); end

  def each_type(&block); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(type_params:, type:, block:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_bound(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end

  def type_param_names(); end

  def type_params(); end

  def update(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::MethodType
end

class RBS::MixinClassError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, member:); end

  def location(); end

  def member(); end

  def type_name(); end
end

class RBS::MixinClassError
  def self.check!(type_name:, env:, member:); end
end

class RBS::Namespace
  def +(other); end

  def ==(other); end

  def absolute!(); end

  def absolute?(); end

  def append(component); end

  def ascend(); end

  def empty?(); end

  def eql?(other); end

  def initialize(path:, absolute:); end

  def parent(); end

  def path(); end

  def relative!(); end

  def relative?(); end

  def split(); end

  def to_type_name(); end
end

class RBS::Namespace
  def self.empty(); end

  def self.parse(string); end

  def self.root(); end
end

class RBS::NoMixinFoundError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, member:); end

  def location(); end

  def member(); end

  def type_name(); end
end

class RBS::NoMixinFoundError
  def self.check!(type_name, env:, member:); end
end

class RBS::NoSelfTypeFoundError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoSelfTypeFoundError
  def self.check!(self_type, env:); end
end

class RBS::NoSuperclassFoundError
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoSuperclassFoundError
  def self.check!(type_name, env:, location:); end
end

class RBS::NoTypeFoundError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoTypeFoundError
  def self.check!(type_name, env:, location:); end
end

class RBS::NonregularTypeAliasError
  include ::RBS::DetailedMessageable
  def diagnostic(); end

  def initialize(diagnostic:, location:); end

  def location(); end
end

class RBS::NonregularTypeAliasError
end

class RBS::Parser
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class RBS::Parser::LexResult
  def buffer(); end

  def initialize(buffer:, value:); end

  def value(); end
end

class RBS::Parser::LexResult
end

class RBS::Parser::Token
  def comment?(); end

  def initialize(type:, location:); end

  def location(); end

  def type(); end

  def value(); end
end

class RBS::Parser::Token
end

class RBS::Parser
  def self._lex(arg, arg1); end

  def self._parse_method_type(arg, arg1, arg2, arg3, arg4); end

  def self._parse_signature(arg, arg1); end

  def self._parse_type(arg, arg1, arg2, arg3, arg4); end

  def self.buffer(source); end

  def self.lex(source); end

  def self.parse_method_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end

  def self.parse_signature(source); end

  def self.parse_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end
end

class RBS::ParsingError
  include ::RBS::DetailedMessageable
  def error_message(); end

  def initialize(location, error_message, token_type); end

  def location(); end

  def token_type(); end
end

class RBS::ParsingError
end

module RBS::Prototype
end

module RBS::Prototype::Helpers
end

module RBS::Prototype::Helpers
end

class RBS::Prototype::NodeUsage
  include ::RBS::Prototype::Helpers
  def calculate(node, conditional:); end

  def conditional_nodes(); end

  def each_conditional_node(&block); end

  def initialize(node); end
end

class RBS::Prototype::NodeUsage
end

class RBS::Prototype::RB
  include ::RBS::Prototype::Helpers
  def block_type(node); end

  def body_type(node); end

  def const_to_name(node, context:); end

  def const_to_name!(node, context: T.unsafe(nil)); end

  def current_accessibility(decls, index=T.unsafe(nil)); end

  def decls(); end

  def find_def_index_by_name(decls, name); end

  def function_return_type_from_body(node); end

  def function_type_from_body(node, def_name); end

  def if_unless_type(node); end

  def is_accessibility?(decl); end

  def literal_to_symbol(node); end

  def literal_to_type(node); end

  def node_type(node, default: T.unsafe(nil)); end

  def param_type(node, default: T.unsafe(nil)); end

  def parse(string); end

  def private(); end

  def process(node, decls:, comments:, context:); end

  def process_children(node, decls:, comments:, context:); end

  def public(); end

  def range_element_type(types); end

  def remove_unnecessary_accessibility_methods!(decls); end

  def sort_members!(decls); end

  def source_decls(); end

  def toplevel_members(); end

  def types_to_union_type(types); end
end

class RBS::Prototype::RB::Context
  def attribute_kind(); end

  def enter_namespace(namespace); end

  def method_kind(); end

  def update(module_function: T.unsafe(nil), singleton: T.unsafe(nil), in_def: T.unsafe(nil)); end
end

class RBS::Prototype::RB::Context
  def self.initial(namespace: T.unsafe(nil)); end
end

class RBS::Prototype::RB
end

class RBS::Prototype::RBI
  include ::RBS::Prototype::Helpers
  def call_node?(node, name:, receiver: T.unsafe(nil), args: T.unsafe(nil)); end

  def const_to_name(node); end

  def current_module(); end

  def current_module!(); end

  def current_namespace(); end

  def decls(); end

  def each_arg(array, &block); end

  def each_child(node); end

  def join_comments(nodes, comments); end

  def last_sig(); end

  def method_type(args_node, type_node, variables:, overloads:); end

  def modules(); end

  def nested_name(name); end

  def node_to_hash(node); end

  def parse(string); end

  def parse_params(args_node, args, method_type, variables:, overloads:); end

  def pop_sig(); end

  def proc_type?(type_node); end

  def process(node, comments:, outer: T.unsafe(nil)); end

  def push_class(name, super_class, comment:); end

  def push_module(name, comment:); end

  def push_sig(node); end

  def type_of(type_node, variables:); end

  def type_of0(type_node, variables:); end
end

class RBS::Prototype::RBI
end

class RBS::Prototype::Runtime
  include ::RBS::Prototype::Helpers
  include ::RBS::Prototype::Runtime::Helpers
  def block_from_ast_of(method); end

  def builder(); end

  def decls(); end

  def ensure_outer_module_declarations(mod); end

  def env(); end

  def generate_class(mod); end

  def generate_constants(mod, decls); end

  def generate_methods(mod, module_name, members); end

  def generate_mixin(mod, decl, type_name, type_name_absolute); end

  def generate_module(mod); end

  def generate_super_class(mod); end

  def initialize(patterns:, env:, merge:, todo: T.unsafe(nil), owners_included: T.unsafe(nil)); end

  def merge(); end

  def merge_rbs(module_name, members, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def method_type(method); end

  def outline(); end

  def outline=(outline); end

  def owners_included(); end

  def parse(file); end

  def patterns(); end

  def target?(const); end

  def target_method?(mod, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def todo(); end

  def todo_object(); end

  def type_args(type_name); end

  def type_params(mod); end
end

class RBS::Prototype::Runtime::DataGenerator
end

class RBS::Prototype::Runtime::DataGenerator
  def self.generatable?(target); end
end

module RBS::Prototype::Runtime::Helpers
end

module RBS::Prototype::Runtime::Helpers
end

module RBS::Prototype::Runtime::Reflection
end

module RBS::Prototype::Runtime::Reflection
  def self.constants_of(mod, inherit=T.unsafe(nil)); end

  def self.object_class(value); end
end

class RBS::Prototype::Runtime::StructGenerator
  CAN_CALL_KEYWORD_INIT_P = ::T.let(nil, ::T.untyped)
end

class RBS::Prototype::Runtime::StructGenerator
  def self.generatable?(target); end
end

class RBS::Prototype::Runtime::ValueObjectBase
  include ::RBS::Prototype::Runtime::Helpers
  def build_decl(); end

  def initialize(target_class); end
end

class RBS::Prototype::Runtime::ValueObjectBase
end

class RBS::Prototype::Runtime
end

module RBS::Prototype
end

class RBS::RecursiveAliasDefinitionError
  include ::RBS::DetailedMessageable
  def defs(); end

  def initialize(type:, defs:); end

  def location(); end

  def type(); end
end

class RBS::RecursiveAliasDefinitionError
end

class RBS::RecursiveAncestorError
  def ancestors(); end

  def initialize(ancestors:, location:); end

  def location(); end
end

class RBS::RecursiveAncestorError
  def self.check!(self_ancestor, ancestors:, location:); end
end

class RBS::RecursiveTypeAliasError
  include ::RBS::DetailedMessageable
  def alias_names(); end

  def initialize(alias_names:, location:); end

  def location(); end

  def name(); end
end

class RBS::RecursiveTypeAliasError
end

class RBS::Repository
  def add(dir); end

  def dirs(); end

  def gems(); end

  def initialize(no_stdlib: T.unsafe(nil)); end

  def lookup(gem, version); end

  def lookup_path(gem, version); end
  DEFAULT_STDLIB_ROOT = ::T.let(nil, ::T.untyped)
end

class RBS::Repository::GemRBS
  def empty?(); end

  def find_best_version(version); end

  def initialize(name:); end

  def latest_version(); end

  def load!(); end

  def name(); end

  def oldest_version(); end

  def paths(); end

  def version_names(); end

  def versions(); end
end

class RBS::Repository::GemRBS
end

class RBS::Repository::VersionPath
  def gem(); end

  def gem=(_); end

  def path(); end

  def path=(_); end

  def version(); end

  def version=(_); end
end

class RBS::Repository::VersionPath
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Repository
  def self.default(); end

  def self.find_best_version(version, candidates); end
end

module RBS::Resolver
end

class RBS::Resolver::ConstantResolver
  def builder(); end

  def child_constants_cache(); end

  def children(module_name); end

  def constants(context); end

  def constants_from_ancestors(module_name, constants:); end

  def constants_from_context(context, constants:); end

  def constants_itself(context, constants:); end

  def context_constants_cache(); end

  def initialize(builder:); end

  def load_child_constants(name); end

  def load_context_constants(context); end

  def resolve(name, context:); end

  def resolve_child(module_name, name); end

  def table(); end
end

class RBS::Resolver::ConstantResolver::Table
  def children(name); end

  def children_table(); end

  def constant(name); end

  def constant_of_constant(name, entry); end

  def constant_of_module(name, entry); end

  def constants_table(); end

  def initialize(environment); end

  def toplevel(); end
end

class RBS::Resolver::ConstantResolver::Table
end

class RBS::Resolver::ConstantResolver
end

class RBS::Resolver::TypeNameResolver
  def all_names(); end

  def cache(); end

  def env(); end

  def has_name?(full_name); end

  def initialize(env); end

  def partition(type_name); end

  def resolve(type_name, context:); end

  def resolve_in(head, context); end

  def try_cache(query); end
end

class RBS::Resolver::TypeNameResolver
end

module RBS::Resolver
end

class RBS::Substitution
  def +(other); end

  def [](ty); end

  def add(from:, to:); end

  def apply(ty); end

  def empty?(); end

  def instance_type(); end

  def instance_type=(instance_type); end

  def mapping(); end

  def without(*vars); end
end

class RBS::Substitution
  def self.build(variables, types, instance_type: T.unsafe(nil), &block); end
end

class RBS::Subtractor
  def call(minuend=T.unsafe(nil), context: T.unsafe(nil)); end

  def initialize(minuend, subtrahend); end
end

class RBS::Subtractor
end

class RBS::SuperclassMismatchError
  def entry(); end

  def initialize(name:, entry:); end

  def name(); end
end

class RBS::SuperclassMismatchError
end

class RBS::TypeAliasDependency
  def build_dependencies(); end

  def circular_definition?(alias_name); end

  def dependencies(); end

  def dependencies_of(name); end

  def direct_dependencies(); end

  def direct_dependencies_of(name); end

  def env(); end

  def initialize(env:); end

  def transitive_closure(); end
end

class RBS::TypeAliasDependency
end

class RBS::TypeAliasRegularity
  def build_alias_type(name); end

  def builder(); end

  def compatible_args?(args1, args2); end

  def diagnostics(); end

  def each_alias_type(type, &block); end

  def each_mutual_alias_defs(&block); end

  def env(); end

  def initialize(env:); end

  def nonregular?(type_name); end

  def validate(); end

  def validate_alias_type(alias_type, names, types); end
end

class RBS::TypeAliasRegularity::Diagnostic
  def initialize(type_name:, nonregular_type:); end

  def nonregular_type(); end

  def type_name(); end
end

class RBS::TypeAliasRegularity::Diagnostic
end

class RBS::TypeAliasRegularity
  def self.validate(env:); end
end

class RBS::TypeName
  def +(other); end

  def ==(other); end

  def absolute!(); end

  def absolute?(); end

  def alias?(); end

  def class?(); end

  def eql?(other); end

  def initialize(namespace:, name:); end

  def interface?(); end

  def kind(); end

  def name(); end

  def namespace(); end

  def relative!(); end

  def split(); end

  def to_json(state=T.unsafe(nil)); end

  def to_namespace(); end

  def with_prefix(namespace); end
end

class RBS::TypeName
  def self.parse(string); end
end

class RBS::TypeParamDefaultReferenceError
  include ::RBS::DetailedMessageable
  def initialize(type_param, location:); end

  def location(); end

  def type_param(); end
end

class RBS::TypeParamDefaultReferenceError
  def self.check!(type_params); end
end

module RBS::Types
end

class RBS::Types::Alias
  include ::RBS::Types::Application
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::Alias
end

module RBS::Types::Application
  def ==(other); end

  def args(); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def hash(); end

  def name(); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

module RBS::Types::Application
end

module RBS::Types::Bases
end

class RBS::Types::Bases::Any
  def todo!(); end
end

class RBS::Types::Bases::Any
end

class RBS::Types::Bases::Base
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName
  def ==(other); end

  def eql?(other); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(location:); end

  def location(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Bases::Base
end

class RBS::Types::Bases::Bool
end

class RBS::Types::Bases::Bool
end

class RBS::Types::Bases::Bottom
end

class RBS::Types::Bases::Bottom
end

class RBS::Types::Bases::Class
end

class RBS::Types::Bases::Class
end

class RBS::Types::Bases::Instance
end

class RBS::Types::Bases::Instance
end

class RBS::Types::Bases::Nil
end

class RBS::Types::Bases::Nil
end

class RBS::Types::Bases::Self
end

class RBS::Types::Bases::Self
end

class RBS::Types::Bases::Top
end

class RBS::Types::Bases::Top
end

class RBS::Types::Bases::Void
end

class RBS::Types::Bases::Void
end

module RBS::Types::Bases
end

class RBS::Types::Block
  def ==(other); end

  def initialize(type:, required:, self_type: T.unsafe(nil)); end

  def map_type(&block); end

  def required(); end

  def self_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Block
end

class RBS::Types::ClassInstance
  include ::RBS::Types::Application
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::ClassInstance
end

class RBS::Types::ClassSingleton
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  def ==(other); end

  def eql?(other); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(name:, location:); end

  def location(); end

  def map_type_name(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::ClassSingleton
end

module RBS::Types::EmptyEachType
  def each_type(); end

  def map_type(&block); end
end

module RBS::Types::EmptyEachType
end

class RBS::Types::Function
  def ==(other); end

  def amap(array, &block); end

  def drop_head(); end

  def drop_tail(); end

  def each_param(&block); end

  def each_type(); end

  def empty?(); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_keyword?(); end

  def has_self_type?(); end

  def hmapv(hash, &block); end

  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end

  def map_type(&block); end

  def map_type_name(&block); end

  def optional_keywords(); end

  def optional_positionals(); end

  def param_to_s(); end

  def required_keywords(); end

  def required_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end

  def return_to_s(); end

  def return_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def trailing_positionals(); end

  def update(required_positionals: T.unsafe(nil), optional_positionals: T.unsafe(nil), rest_positionals: T.unsafe(nil), trailing_positionals: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil), return_type: T.unsafe(nil)); end

  def with_nonreturn_void?(); end

  def with_return_type(type); end
end

class RBS::Types::Function::Param
  def ==(other); end

  def eql?(other); end

  def initialize(type:, name:, location: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Function::Param
end

class RBS::Types::Function
  def self.empty(return_type); end
end

class RBS::Types::Interface
  include ::RBS::Types::Application
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::Interface
end

class RBS::Types::Intersection
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Intersection
end

class RBS::Types::Literal
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName
  def ==(other); end

  def eql?(other); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(literal:, location:); end

  def literal(); end

  def location(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
  TABLE = ::T.let(nil, ::T.untyped)
end

class RBS::Types::Literal
  def self.unescape_string(string, is_double_quote); end
end

module RBS::Types::NoFreeVariables
  def free_variables(set=T.unsafe(nil)); end
end

module RBS::Types::NoFreeVariables
end

module RBS::Types::NoSubst
  def sub(s); end
end

module RBS::Types::NoSubst
end

module RBS::Types::NoTypeName
  def map_type_name(); end
end

module RBS::Types::NoTypeName
end

class RBS::Types::Optional
  def ==(other); end

  def each_type(); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(type:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def type(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Optional
end

class RBS::Types::Proc
  def ==(other); end

  def block(); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(location:, type:, block:, self_type: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def self_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def type(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Proc
end

class RBS::Types::Record
  def ==(other); end

  def all_fields(); end

  def each_type(&block); end

  def eql?(other); end

  def fields(); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(location:, all_fields: T.unsafe(nil), fields: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def optional_fields(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Record
end

module RBS::Types::SelfTypeBindingHelper
end

module RBS::Types::SelfTypeBindingHelper
  def self.self_type_binding_to_s(t); end
end

class RBS::Types::Tuple
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Tuple
end

class RBS::Types::Union
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Union
end

class RBS::Types::UntypedFunction
  def ==(other); end

  def each_param(&block); end

  def each_type(&block); end

  def empty?(); end

  def eql?(other); end

  def free_variables(acc=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(return_type:); end

  def map_type(&block); end

  def map_type_name(&block); end

  def param_to_s(); end

  def return_to_s(); end

  def return_type(); end

  def sub(subst); end

  def to_json(state=T.unsafe(nil)); end

  def update(return_type: T.unsafe(nil)); end

  def with_nonreturn_void?(); end

  def with_return_type(ty); end
end

class RBS::Types::UntypedFunction
end

class RBS::Types::Variable
  include ::RBS::Types::NoTypeName
  include ::RBS::Types::EmptyEachType
  def ==(other); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(name:, location:); end

  def location(); end

  def name(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Variable
  def self.build(v); end

  def self.fresh(v=T.unsafe(nil)); end
end

module RBS::Types
end

class RBS::UnknownMethodAliasError
  include ::RBS::DetailedMessageable
  def aliased_name(); end

  def initialize(type_name:, original_name:, aliased_name:, location:); end

  def location(); end

  def original_name(); end

  def type_name(); end
end

class RBS::UnknownMethodAliasError
end

class RBS::Validator
  def absolute_type(type, context:, &block); end

  def definition_builder(); end

  def env(); end

  def initialize(env:, resolver: T.unsafe(nil)); end

  def resolver(); end

  def type_alias_dependency(); end

  def type_alias_regularity(); end

  def validate_class_alias(entry:); end

  def validate_method_definition(method_def, type_name:); end

  def validate_type(type, context:); end

  def validate_type_alias(entry:); end

  def validate_type_params(params, type_name:, location:, method_name: T.unsafe(nil)); end
end

class RBS::Validator
end

class RBS::VarianceCalculator
  def builder(); end

  def env(); end

  def function(type, result:, context:); end

  def in_inherit(name:, args:, variables:); end

  def in_method_type(method_type:, variables:); end

  def in_type_alias(name:); end

  def initialize(builder:); end

  def negate(variance); end

  def type(type, result:, context:); end
end

class RBS::VarianceCalculator::Result
  def compatible?(var, with_annotation:); end

  def contravariant(x); end

  def covariant(x); end

  def each(&block); end

  def include?(name); end

  def incompatible?(params); end

  def initialize(variables:); end

  def invariant(x); end

  def result(); end
end

class RBS::VarianceCalculator::Result
end

class RBS::VarianceCalculator
end

class RBS::Vendorer
  def clean!(); end

  def copy!(); end

  def ensure_dir(); end

  def initialize(vendor_dir:, loader:); end

  def loader(); end

  def vendor_dir(); end
end

class RBS::Vendorer
end

class RBS::WillSyntaxError
  include ::RBS::DetailedMessageable
  def initialize(message, location:); end

  def location(); end
end

class RBS::WillSyntaxError
end

class RBS::Writer
  def attribute(kind, attr); end

  def format_annotation(annotation); end

  def indent(size=T.unsafe(nil)); end

  def indentation(); end

  def initialize(out:); end

  def method_name(name); end

  def name_and_args(name, args); end

  def name_and_params(name, params); end

  def out(); end

  def prefix(); end

  def preserve!(preserve: T.unsafe(nil)); end

  def preserve?(); end

  def preserve_empty_line(prev, decl); end

  def put_lines(lines, leading_spaces:); end

  def puts(string=T.unsafe(nil)); end

  def write(contents); end

  def write_annotation(annotations); end

  def write_comment(comment); end

  def write_decl(decl); end

  def write_def(member); end

  def write_directive(dir); end

  def write_loc_source(located); end

  def write_member(member); end
end

class RBS::Writer
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

module Random::Formatter
  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def reverse_each(); end

  def sum(initial_value=T.unsafe(nil)); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

class Refinement
  def target(); end
end

class Regexp
  def timeout(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  def self.compile_file_prism(*arg); end

  def self.compile_prism(*arg); end
end

module RubyVM::RJIT
end

module RubyVM::RJIT
  def self.enable(); end

  def self.enabled?(); end
end

module RubyVM::YJIT
  def self.disasm(iseq); end

  def self.exit_locations(); end

  def self.insns_compiled(iseq); end

  def self.simulate_oom!(); end

  def self.trace_exit_locations_enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

ScanError = StringScanner::Error

module SecureRandom
  VERSION = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

class Socket::ResolutionError
  def error_code(); end
end

module Steep
  VERSION = ::T.let(nil, ::T.untyped)
end

module Steep::AST
end

module Steep::AST::Annotation
end

class Steep::AST::Annotation::BlockType
end

class Steep::AST::Annotation::BlockType
end

class Steep::AST::Annotation::BreakType
end

class Steep::AST::Annotation::BreakType
end

class Steep::AST::Annotation::Collection
  def absolute_type(type); end

  def annotations(); end

  def any?(&block); end

  def block_type(); end

  def block_type_annotation(); end

  def break_type(); end

  def break_type_annotation(); end

  def const_type_annotations(); end

  def const_types(); end

  def context(); end

  def dynamic_annotations(); end

  def factory(); end

  def implement_module_annotation(); end

  def include?(obj); end

  def initialize(annotations:, factory:, context:); end

  def instance_dynamics(); end

  def instance_type(); end

  def instance_type_annotation(); end

  def ivar_type_annotations(); end

  def ivar_types(); end

  def lvar_types(); end

  def merge_block_annotations(annotations); end

  def method_type(name); end

  def method_type_annotations(); end

  def module_dynamics(); end

  def module_type(); end

  def module_type_annotation(); end

  def return_type(); end

  def return_type_annotation(); end

  def self_type(); end

  def self_type_annotation(); end

  def size(); end

  def var_type(lvar: T.unsafe(nil), ivar: T.unsafe(nil), const: T.unsafe(nil)); end

  def var_type_annotations(); end
end

class Steep::AST::Annotation::Collection
end

class Steep::AST::Annotation::ConstType
end

class Steep::AST::Annotation::ConstType
end

class Steep::AST::Annotation::Dynamic
  include ::Steep::AST::Annotation::Located
  def ==(other); end

  def initialize(names:, location: T.unsafe(nil)); end

  def names(); end
end

class Steep::AST::Annotation::Dynamic::Name
  def ==(other); end

  def initialize(name:, kind:, location: T.unsafe(nil)); end

  def instance_method?(); end

  def kind(); end

  def location(); end

  def module_method?(); end

  def name(); end
end

class Steep::AST::Annotation::Dynamic::Name
end

class Steep::AST::Annotation::Dynamic
end

class Steep::AST::Annotation::Implements
  include ::Steep::AST::Annotation::Located
  def ==(other); end

  def initialize(name:, location: T.unsafe(nil)); end

  def name(); end
end

class Steep::AST::Annotation::Implements::Module
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:); end

  def name(); end
end

class Steep::AST::Annotation::Implements::Module
end

class Steep::AST::Annotation::Implements
end

class Steep::AST::Annotation::InstanceType
end

class Steep::AST::Annotation::InstanceType
end

class Steep::AST::Annotation::IvarType
end

class Steep::AST::Annotation::IvarType
end

module Steep::AST::Annotation::Located
  def line(); end

  def location(); end
end

module Steep::AST::Annotation::Located
end

class Steep::AST::Annotation::MethodType
end

class Steep::AST::Annotation::MethodType
end

class Steep::AST::Annotation::ModuleType
end

class Steep::AST::Annotation::ModuleType
end

class Steep::AST::Annotation::Named
  include ::Steep::AST::Annotation::Located
  def ==(other); end

  def initialize(name:, type:, location: T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Steep::AST::Annotation::Named
end

class Steep::AST::Annotation::ReturnType
end

class Steep::AST::Annotation::ReturnType
end

class Steep::AST::Annotation::SelfType
end

class Steep::AST::Annotation::SelfType
end

class Steep::AST::Annotation::Typed
  include ::Steep::AST::Annotation::Located
  def ==(other); end

  def initialize(type:, location: T.unsafe(nil)); end

  def type(); end
end

class Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::VarType
end

class Steep::AST::Annotation::VarType
end

module Steep::AST::Annotation
end

module Steep::AST::Builtin
  Array = ::T.let(nil, ::T.untyped)
  BasicObject = ::T.let(nil, ::T.untyped)
  Class = ::T.let(nil, ::T.untyped)
  FalseClass = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Module = ::T.let(nil, ::T.untyped)
  NilClass = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  Proc = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  Regexp = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
  TrueClass = ::T.let(nil, ::T.untyped)
end

class Steep::AST::Builtin::Type
  def arity(); end

  def initialize(module_name, arity: T.unsafe(nil)); end

  def instance_type(*args, fill_untyped: T.unsafe(nil)); end

  def instance_type?(type, args: T.unsafe(nil)); end

  def module_name(); end

  def module_type(); end

  def module_type?(type); end
end

class Steep::AST::Builtin::Type
end

module Steep::AST::Builtin
  def self.any_type(); end

  def self.bool_type(); end

  def self.bottom_type(); end

  def self.false_type(); end

  def self.nil_type(); end

  def self.optional(type); end

  def self.top_type(); end

  def self.true_type(); end
end

module Steep::AST::Ignore
end

class Steep::AST::Ignore::BufferScanner
  def charpos(); end

  def eos?(); end

  def initialize(location); end

  def location(); end

  def offset(); end

  def scan(regexp); end

  def scanner(); end

  def skip(regexp); end
end

class Steep::AST::Ignore::BufferScanner
end

class Steep::AST::Ignore::IgnoreEnd
  def comment(); end

  def initialize(comment, location); end

  def line(); end

  def location(); end
end

class Steep::AST::Ignore::IgnoreEnd
end

class Steep::AST::Ignore::IgnoreLine
  def comment(); end

  def ignored_diagnostics(); end

  def initialize(comment, diagnostics, location); end

  def line(); end

  def location(); end

  def raw_diagnostics(); end
end

class Steep::AST::Ignore::IgnoreLine
end

class Steep::AST::Ignore::IgnoreStart
  def comment(); end

  def initialize(comment, location); end

  def line(); end

  def location(); end
end

class Steep::AST::Ignore::IgnoreStart
end

module Steep::AST::Ignore
  def self.parse(comment, buffer); end
end

module Steep::AST::Node
end

class Steep::AST::Node::TypeApplication
  def initialize(location); end

  def line(); end

  def location(); end

  def node(); end

  def set_node(node); end

  def source(); end

  def type_location(); end

  def type_str(); end

  def types(context, subtyping, type_vars); end

  def types?(context, subtyping, type_vars); end
end

class Steep::AST::Node::TypeApplication
  def self.parse(location); end
end

class Steep::AST::Node::TypeAssertion
  def initialize(location); end

  def line(); end

  def location(); end

  def source(); end

  def type(context, subtyping, type_vars); end

  def type?(context, subtyping, type_vars); end

  def type_location(); end

  def type_str(); end

  def type_syntax?(); end
end

class Steep::AST::Node::TypeAssertion
  def self.parse(location); end
end

module Steep::AST::Node
end

module Steep::AST::Types
end

class Steep::AST::Types::Any
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Any
end

class Steep::AST::Types::Boolean
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def back_type(); end

  def eql?(other); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Boolean
end

class Steep::AST::Types::Bot
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Bot
end

class Steep::AST::Types::Class
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def free_variables(); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Class
  def self.instance(); end
end

class Steep::AST::Types::Factory
  def absolute_type(type, context:); end

  def absolute_type_name(type_name, context:); end

  def class_name?(type_name); end

  def deep_expand_alias(type, recursive: T.unsafe(nil)); end

  def definition_builder(); end

  def env(); end

  def expand_alias(type); end

  def flatten_union(type, acc=T.unsafe(nil)); end

  def function_1(func); end

  def initialize(builder:); end

  def instance_type(type_name, args: T.unsafe(nil), location: T.unsafe(nil)); end

  def method_type(method_type, method_decls:); end

  def method_type_1(method_type); end

  def module_name?(type_name); end

  def normalize_type(type); end

  def params(type); end

  def partition_union(type); end

  def try_instance_type(type); end

  def try_singleton_type(type); end

  def type(type); end

  def type_1(type); end

  def type_1_opt(type); end

  def type_cache(); end

  def type_name_resolver(); end

  def type_opt(type); end

  def type_param(type_param); end

  def type_param_1(type_param); end

  def unfold(type_name, args); end

  def unwrap_optional(type); end
end

class Steep::AST::Types::Factory
end

module Steep::AST::Types::Helper
end

module Steep::AST::Types::Helper::ChildrenLevel
  def level_of_children(children); end
end

module Steep::AST::Types::Helper::ChildrenLevel
end

module Steep::AST::Types::Helper::NoChild
  def each_child(&block); end

  def map_type(); end
end

module Steep::AST::Types::Helper::NoChild
end

module Steep::AST::Types::Helper::NoFreeVariables
  def free_variables(); end
end

module Steep::AST::Types::Helper::NoFreeVariables
end

module Steep::AST::Types::Helper
end

class Steep::AST::Types::Instance
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def free_variables(); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Instance
  def self.instance(); end
end

class Steep::AST::Types::Intersection
  include ::Steep::AST::Types::Helper::ChildrenLevel
  def ==(other); end

  def each_child(&block); end

  def eql?(other); end

  def free_variables(); end

  def initialize(types:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def map_type(&block); end

  def subst(s); end

  def types(); end

  def with_location(new_location); end
end

class Steep::AST::Types::Intersection
  def self.build(types:, location: T.unsafe(nil)); end
end

class Steep::AST::Types::Literal
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def back_type(); end

  def eql?(other); end

  def initialize(value:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def value(); end

  def with_location(new_location); end
end

class Steep::AST::Types::Literal
end

module Steep::AST::Types::Logic
end

class Steep::AST::Types::Logic::ArgEqualsReceiver
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ArgEqualsReceiver
end

class Steep::AST::Types::Logic::ArgIsAncestor
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ArgIsAncestor
end

class Steep::AST::Types::Logic::ArgIsReceiver
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ArgIsReceiver
end

class Steep::AST::Types::Logic::Base
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def level(); end

  def location(); end

  def subst(s); end
end

class Steep::AST::Types::Logic::Base
end

class Steep::AST::Types::Logic::Env
  def falsy(); end

  def initialize(truthy:, falsy:, type:, location: T.unsafe(nil)); end

  def truthy(); end

  def type(); end
end

class Steep::AST::Types::Logic::Env
end

class Steep::AST::Types::Logic::Not
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::Not
end

class Steep::AST::Types::Logic::ReceiverIsArg
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ReceiverIsArg
end

class Steep::AST::Types::Logic::ReceiverIsNil
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ReceiverIsNil
end

class Steep::AST::Types::Logic::ReceiverIsNotNil
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ReceiverIsNotNil
end

module Steep::AST::Types::Logic
end

module Steep::AST::Types::Name
end

class Steep::AST::Types::Name::Alias
end

class Steep::AST::Types::Name::Alias
end

class Steep::AST::Types::Name::Applying
  include ::Steep::AST::Types::Helper::ChildrenLevel
  def ==(other); end

  def args(); end

  def each_child(&block); end

  def eql?(other); end

  def initialize(name:, args:, location: T.unsafe(nil)); end

  def with_location(new_location); end
end

class Steep::AST::Types::Name::Applying
end

class Steep::AST::Types::Name::Base
  include ::Steep::AST::Types::Helper::NoFreeVariables
  def initialize(name:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def subst(s); end
end

class Steep::AST::Types::Name::Base
end

class Steep::AST::Types::Name::Instance
  def to_module(); end
end

class Steep::AST::Types::Name::Instance
end

class Steep::AST::Types::Name::Interface
end

class Steep::AST::Types::Name::Interface
end

class Steep::AST::Types::Name::Singleton
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def with_location(new_location); end
end

class Steep::AST::Types::Name::Singleton
end

module Steep::AST::Types::Name
end

class Steep::AST::Types::Nil
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def back_type(); end

  def eql?(other); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Nil
end

class Steep::AST::Types::Proc
  include ::Steep::AST::Types::Helper::ChildrenLevel
  def ==(other); end

  def back_type(); end

  def block(); end

  def block_required?(); end

  def each_child(&block); end

  def eql?(other); end

  def free_variables(); end

  def initialize(type:, block:, self_type:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def map_type(&block); end

  def one_arg?(); end

  def self_type(); end

  def subst(s); end

  def type(); end

  def with_location(new_location); end
end

class Steep::AST::Types::Proc
end

class Steep::AST::Types::Record
  include ::Steep::AST::Types::Helper::ChildrenLevel
  def ==(other); end

  def each_child(&block); end

  def elements(); end

  def eql?(other); end

  def free_variables(); end

  def initialize(elements:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def map_type(&block); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Record
end

class Steep::AST::Types::Self
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def free_variables(); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Self
  def self.instance(); end
end

class Steep::AST::Types::Top
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Top
end

class Steep::AST::Types::Tuple
  include ::Steep::AST::Types::Helper::ChildrenLevel
  def ==(other); end

  def each_child(&block); end

  def eql?(other); end

  def free_variables(); end

  def initialize(types:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def map_type(&block); end

  def subst(s); end

  def types(); end

  def with_location(new_location); end
end

class Steep::AST::Types::Tuple
end

class Steep::AST::Types::Union
  include ::Steep::AST::Types::Helper::ChildrenLevel
  def ==(other); end

  def each_child(&block); end

  def eql?(other); end

  def free_variables(); end

  def initialize(types:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def map_type(&block); end

  def subst(s); end

  def types(); end

  def with_location(new_location); end
end

class Steep::AST::Types::Union
  def self.build(types:, location: T.unsafe(nil)); end
end

class Steep::AST::Types::Var
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def free_variables(); end

  def initialize(name:, location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def name(); end

  def subst(s); end

  def update(name: T.unsafe(nil), location: T.unsafe(nil)); end

  def with_location(new_location); end
end

class Steep::AST::Types::Var
  def self.fresh(name, location: T.unsafe(nil)); end

  def self.fresh_name(name); end
end

class Steep::AST::Types::Void
  include ::Steep::AST::Types::Helper::NoFreeVariables
  include ::Steep::AST::Types::Helper::NoChild
  def ==(other); end

  def eql?(other); end

  def initialize(location: T.unsafe(nil)); end

  def level(); end

  def location(); end

  def subst(s); end

  def with_location(new_location); end
end

class Steep::AST::Types::Void
end

module Steep::AST::Types
end

module Steep::AST
end

class Steep::AnnotationParser
  def factory(); end

  def initialize(factory:); end

  def keyword_and_type(keyword); end

  def keyword_subject_type(keyword, name); end

  def parse(src, location:); end

  def parse_type(match, name=T.unsafe(nil), location:); end
  COLON = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  DYNAMIC_NAME = ::T.let(nil, ::T.untyped)
  IVAR_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMS = ::T.let(nil, ::T.untyped)
  VAR_NAME = ::T.let(nil, ::T.untyped)
end

class Steep::AnnotationParser::SyntaxError
  def initialize(source:, location:, exn: T.unsafe(nil), message: T.unsafe(nil)); end

  def location(); end

  def source(); end
end

class Steep::AnnotationParser::SyntaxError
end

class Steep::AnnotationParser
end

module Steep::Diagnostic
end

module Steep::Diagnostic::Helper
  def error_name(); end

  def full_message(); end
end

module Steep::Diagnostic::Helper
end

class Steep::Diagnostic::LSPFormatter
  def config(); end

  def default_severity(); end

  def format(diagnostic); end

  def initialize(config=T.unsafe(nil), default_severity: T.unsafe(nil)); end

  def severity_for(diagnostic); end

  def validate_class(klass); end

  def validate_severity(klass, severity); end
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

Steep::Diagnostic::LSPFormatter::LSP = LanguageServer::Protocol

class Steep::Diagnostic::LSPFormatter
end

module Steep::Diagnostic::Ruby
  ALL = ::T.let(nil, ::T.untyped)
end

class Steep::Diagnostic::Ruby::ArgumentTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:); end

  def result(); end
end

class Steep::Diagnostic::Ruby::ArgumentTypeMismatch
end

class Steep::Diagnostic::Ruby::Base
  include ::Steep::Diagnostic::Helper
  def detail_lines(); end

  def diagnostic_code(); end

  def header_line(); end

  def initialize(node:, location: T.unsafe(nil)); end

  def location(); end

  def node(); end
end

class Steep::Diagnostic::Ruby::Base
end

class Steep::Diagnostic::Ruby::BlockBodyTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:); end

  def result(); end
end

class Steep::Diagnostic::Ruby::BlockBodyTypeMismatch
end

class Steep::Diagnostic::Ruby::BlockTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:); end

  def result(); end
end

class Steep::Diagnostic::Ruby::BlockTypeMismatch
end

class Steep::Diagnostic::Ruby::BreakTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:); end

  def result(); end
end

class Steep::Diagnostic::Ruby::BreakTypeMismatch
end

class Steep::Diagnostic::Ruby::DifferentMethodParameterKind
  def initialize(method_param:, method_type:); end

  def method_param(); end

  def method_type(); end
end

class Steep::Diagnostic::Ruby::DifferentMethodParameterKind
end

class Steep::Diagnostic::Ruby::ElseOnExhaustiveCase
  def initialize(node:, type:); end

  def type(); end
end

class Steep::Diagnostic::Ruby::ElseOnExhaustiveCase
end

class Steep::Diagnostic::Ruby::FallbackAny
  def initialize(node:); end
end

class Steep::Diagnostic::Ruby::FallbackAny
end

class Steep::Diagnostic::Ruby::FalseAssertion
  def assertion_type(); end

  def initialize(node:, assertion_type:, node_type:); end

  def node_type(); end
end

class Steep::Diagnostic::Ruby::FalseAssertion
end

class Steep::Diagnostic::Ruby::ImplicitBreakValueMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def initialize(node:, jump_type:, result:); end

  def jump_type(); end

  def result(); end
end

class Steep::Diagnostic::Ruby::ImplicitBreakValueMismatch
end

class Steep::Diagnostic::Ruby::IncompatibleAnnotation
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def initialize(node:, var_name:, result:, relation:); end

  def relation(); end

  def result(); end

  def var_name(); end
end

class Steep::Diagnostic::Ruby::IncompatibleAnnotation
end

class Steep::Diagnostic::Ruby::IncompatibleArgumentForwarding
  include ::Steep::Diagnostic::Ruby::ResultPrinter2
  def block_pair(); end

  def initialize(method_name:, node:, result:, params_pair: T.unsafe(nil), block_pair: T.unsafe(nil)); end

  def method_name(); end

  def params_pair(); end

  def result(); end
end

class Steep::Diagnostic::Ruby::IncompatibleArgumentForwarding
end

class Steep::Diagnostic::Ruby::IncompatibleAssignment
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def initialize(node:, lhs_type:, rhs_type:, result:); end

  def lhs_type(); end

  def result(); end

  def rhs_type(); end
end

class Steep::Diagnostic::Ruby::IncompatibleAssignment
end

class Steep::Diagnostic::Ruby::IncompatibleMethodTypeAnnotation
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def annotation_method(); end

  def initialize(node:, interface_method:, annotation_method:, result:); end

  def interface_method(); end

  def result(); end
end

class Steep::Diagnostic::Ruby::IncompatibleMethodTypeAnnotation
end

class Steep::Diagnostic::Ruby::IncompatibleTypeCase
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def initialize(node:, var_name:, result:, relation:); end

  def relation(); end

  def result(); end

  def var_name(); end
end

class Steep::Diagnostic::Ruby::IncompatibleTypeCase
end

class Steep::Diagnostic::Ruby::InsufficientKeywordArguments
  def initialize(node:, params:, missing_keywords:); end

  def method_name(); end

  def method_type(); end

  def missing_keywords(); end
end

class Steep::Diagnostic::Ruby::InsufficientKeywordArguments
end

class Steep::Diagnostic::Ruby::InsufficientPositionalArguments
  def initialize(node:, params:); end

  def params(); end
end

class Steep::Diagnostic::Ruby::InsufficientPositionalArguments
end

class Steep::Diagnostic::Ruby::InsufficientTypeArgument
  def initialize(node:, type_args:, method_type:); end

  def method_type(); end

  def type_args(); end
end

class Steep::Diagnostic::Ruby::InsufficientTypeArgument
end

class Steep::Diagnostic::Ruby::InvalidIgnoreComment
  def comment(); end

  def initialize(comment:); end
end

class Steep::Diagnostic::Ruby::InvalidIgnoreComment
end

class Steep::Diagnostic::Ruby::MethodArityMismatch
  def initialize(node:, method_type:); end

  def method_type(); end
end

class Steep::Diagnostic::Ruby::MethodArityMismatch
end

class Steep::Diagnostic::Ruby::MethodBodyTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:); end

  def result(); end
end

class Steep::Diagnostic::Ruby::MethodBodyTypeMismatch
end

class Steep::Diagnostic::Ruby::MethodDefinitionMissing
  def initialize(node:, module_name:, kind:, missing_method:); end

  def kind(); end

  def missing_method(); end

  def module_name(); end
end

class Steep::Diagnostic::Ruby::MethodDefinitionMissing
end

class Steep::Diagnostic::Ruby::MethodParameterMismatch
  def initialize(method_param:, method_type:); end

  def method_param(); end

  def method_type(); end
end

class Steep::Diagnostic::Ruby::MethodParameterMismatch
end

class Steep::Diagnostic::Ruby::MethodReturnTypeAnnotationMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def annotation_type(); end

  def initialize(node:, method_type:, annotation_type:, result:); end

  def method_type(); end

  def result(); end
end

class Steep::Diagnostic::Ruby::MethodReturnTypeAnnotationMismatch
end

class Steep::Diagnostic::Ruby::MultipleAssignmentConversionError
  def initialize(node:, original_type:, returned_type:); end

  def original_type(); end

  def returned_type(); end
end

class Steep::Diagnostic::Ruby::MultipleAssignmentConversionError
end

class Steep::Diagnostic::Ruby::NoMethod
  def initialize(node:, type:, method:); end

  def method(); end

  def type(); end
end

class Steep::Diagnostic::Ruby::NoMethod
end

class Steep::Diagnostic::Ruby::ProcHintIgnored
  def block_node(); end

  def hint_type(); end

  def initialize(hint_type:, node:); end
end

class Steep::Diagnostic::Ruby::ProcHintIgnored
end

class Steep::Diagnostic::Ruby::ProcTypeExpected
  def initialize(node:, type:); end

  def type(); end
end

class Steep::Diagnostic::Ruby::ProcTypeExpected
end

class Steep::Diagnostic::Ruby::RBSError
  def error(); end

  def initialize(error:, node:, location:); end
end

class Steep::Diagnostic::Ruby::RBSError
end

class Steep::Diagnostic::Ruby::RequiredBlockMissing
  def initialize(node:, method_type:); end

  def method_type(); end
end

class Steep::Diagnostic::Ruby::RequiredBlockMissing
end

module Steep::Diagnostic::Ruby::ResultPrinter
  def detail_lines(); end

  def relation_message(relation); end
end

module Steep::Diagnostic::Ruby::ResultPrinter
end

module Steep::Diagnostic::Ruby::ResultPrinter2
  def detail_lines(); end

  def result_line(result); end
end

module Steep::Diagnostic::Ruby::ResultPrinter2
end

class Steep::Diagnostic::Ruby::ReturnTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:); end

  def result(); end
end

class Steep::Diagnostic::Ruby::ReturnTypeMismatch
end

class Steep::Diagnostic::Ruby::SetterBodyTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, expected:, actual:, result:, method_name:); end

  def method_name(); end

  def result(); end
end

class Steep::Diagnostic::Ruby::SetterBodyTypeMismatch
end

class Steep::Diagnostic::Ruby::SetterReturnTypeMismatch
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def actual(); end

  def expected(); end

  def initialize(node:, method_name:, expected:, actual:, result:); end

  def method_name(); end

  def result(); end
end

class Steep::Diagnostic::Ruby::SetterReturnTypeMismatch
end

class Steep::Diagnostic::Ruby::SyntaxError
  def initialize(message:, location:); end

  def message(); end
end

class Steep::Diagnostic::Ruby::SyntaxError
end

class Steep::Diagnostic::Ruby::TypeArgumentMismatchError
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def initialize(type_arg:, type_param:, result:); end

  def result(); end

  def type_argument(); end

  def type_parameter(); end
end

class Steep::Diagnostic::Ruby::TypeArgumentMismatchError
end

class Steep::Diagnostic::Ruby::UnexpectedBlockGiven
  def initialize(node:, method_type:); end

  def method_type(); end
end

class Steep::Diagnostic::Ruby::UnexpectedBlockGiven
end

class Steep::Diagnostic::Ruby::UnexpectedDynamicMethod
  def initialize(node:, module_name:, method_name:); end

  def method_name(); end

  def module_name(); end
end

class Steep::Diagnostic::Ruby::UnexpectedDynamicMethod
end

class Steep::Diagnostic::Ruby::UnexpectedError
  def error(); end

  def initialize(node:, error:); end
end

class Steep::Diagnostic::Ruby::UnexpectedError
end

class Steep::Diagnostic::Ruby::UnexpectedJump
end

class Steep::Diagnostic::Ruby::UnexpectedJump
end

class Steep::Diagnostic::Ruby::UnexpectedJumpValue
end

class Steep::Diagnostic::Ruby::UnexpectedJumpValue
end

class Steep::Diagnostic::Ruby::UnexpectedKeywordArgument
  def initialize(node:, params:); end

  def params(); end
end

class Steep::Diagnostic::Ruby::UnexpectedKeywordArgument
end

class Steep::Diagnostic::Ruby::UnexpectedPositionalArgument
  def initialize(node:, params:); end

  def params(); end
end

class Steep::Diagnostic::Ruby::UnexpectedPositionalArgument
end

class Steep::Diagnostic::Ruby::UnexpectedSplat
  def initialize(node:, type:); end

  def type(); end
end

class Steep::Diagnostic::Ruby::UnexpectedSplat
end

class Steep::Diagnostic::Ruby::UnexpectedSuper
  def initialize(node:, method:); end

  def method(); end
end

class Steep::Diagnostic::Ruby::UnexpectedSuper
end

class Steep::Diagnostic::Ruby::UnexpectedTypeArgument
  def initialize(type_arg:, method_type:); end

  def method_type(); end

  def type_arg(); end
end

class Steep::Diagnostic::Ruby::UnexpectedTypeArgument
end

class Steep::Diagnostic::Ruby::UnexpectedYield
end

class Steep::Diagnostic::Ruby::UnexpectedYield
end

class Steep::Diagnostic::Ruby::UnknownConstant
  def class!(); end

  def initialize(node:, name:); end

  def kind(); end

  def module!(); end

  def name(); end
end

class Steep::Diagnostic::Ruby::UnknownConstant
end

class Steep::Diagnostic::Ruby::UnknownConstantAssigned
  def context(); end

  def initialize(node:, context:, name:); end

  def name(); end
end

class Steep::Diagnostic::Ruby::UnknownConstantAssigned
end

class Steep::Diagnostic::Ruby::UnknownGlobalVariable
  def initialize(node:, name:); end

  def name(); end
end

class Steep::Diagnostic::Ruby::UnknownGlobalVariable
end

class Steep::Diagnostic::Ruby::UnknownInstanceVariable
  def initialize(node:, name:); end

  def name(); end
end

class Steep::Diagnostic::Ruby::UnknownInstanceVariable
end

class Steep::Diagnostic::Ruby::UnreachableBranch
end

class Steep::Diagnostic::Ruby::UnreachableBranch
end

class Steep::Diagnostic::Ruby::UnreachableValueBranch
  def initialize(node:, type:, location: T.unsafe(nil)); end

  def type(); end
end

class Steep::Diagnostic::Ruby::UnreachableValueBranch
end

class Steep::Diagnostic::Ruby::UnresolvedOverloading
  def initialize(node:, receiver_type:, method_name:, method_types:); end

  def method_name(); end

  def method_types(); end

  def receiver_type(); end
end

class Steep::Diagnostic::Ruby::UnresolvedOverloading
end

class Steep::Diagnostic::Ruby::UnsatisfiableConstraint
  include ::Steep::Diagnostic::Ruby::ResultPrinter
  def initialize(node:, method_type:, var:, sub_type:, super_type:, result:); end

  def method_type(); end

  def result(); end

  def sub_type(); end

  def super_type(); end

  def var(); end
end

class Steep::Diagnostic::Ruby::UnsatisfiableConstraint
end

class Steep::Diagnostic::Ruby::UnsupportedSyntax
  def initialize(node:, message: T.unsafe(nil)); end

  def message(); end
end

class Steep::Diagnostic::Ruby::UnsupportedSyntax
end

module Steep::Diagnostic::Ruby
  def self.all_error(); end

  def self.default(); end

  def self.lenient(); end

  def self.silent(); end

  def self.strict(); end
end

module Steep::Diagnostic::Signature
end

class Steep::Diagnostic::Signature::Base
  include ::Steep::Diagnostic::Helper
  def detail_lines(); end

  def diagnostic_code(); end

  def header_line(); end

  def initialize(location:); end

  def location(); end

  def path(); end
end

class Steep::Diagnostic::Signature::Base
end

class Steep::Diagnostic::Signature::ClassVariableDuplicationError
  def class_name(); end

  def initialize(class_name:, other_class_name:, variable_name:, location:); end

  def other_class_name(); end

  def variable_name(); end
end

class Steep::Diagnostic::Signature::ClassVariableDuplicationError
end

class Steep::Diagnostic::Signature::CyclicClassAliasDefinitionError
  def decl(); end

  def initialize(decl:); end
end

class Steep::Diagnostic::Signature::CyclicClassAliasDefinitionError
end

class Steep::Diagnostic::Signature::DuplicatedDeclaration
  def initialize(type_name:, location:); end

  def type_name(); end
end

class Steep::Diagnostic::Signature::DuplicatedDeclaration
end

class Steep::Diagnostic::Signature::DuplicatedMethodDefinition
  def class_name(); end

  def initialize(class_name:, method_name:, location:); end

  def method_name(); end
end

class Steep::Diagnostic::Signature::DuplicatedMethodDefinition
end

class Steep::Diagnostic::Signature::GenericParameterMismatch
  def initialize(name:, location:); end

  def name(); end
end

class Steep::Diagnostic::Signature::GenericParameterMismatch
end

class Steep::Diagnostic::Signature::InconsistentClassModuleAliasError
  def decl(); end

  def initialize(decl:); end
end

class Steep::Diagnostic::Signature::InconsistentClassModuleAliasError
end

class Steep::Diagnostic::Signature::InheritModuleError
  def initialize(super_class); end

  def super_class(); end
end

class Steep::Diagnostic::Signature::InheritModuleError
end

class Steep::Diagnostic::Signature::InstanceVariableTypeError
  def initialize(name:, location:, var_type:, parent_type:); end

  def name(); end

  def parent_type(); end

  def var_type(); end
end

class Steep::Diagnostic::Signature::InstanceVariableTypeError
end

class Steep::Diagnostic::Signature::InvalidMethodOverload
  def class_name(); end

  def initialize(class_name:, method_name:, location:); end

  def method_name(); end
end

class Steep::Diagnostic::Signature::InvalidMethodOverload
end

class Steep::Diagnostic::Signature::InvalidTypeApplication
  def args(); end

  def initialize(name:, args:, params:, location:); end

  def name(); end

  def params(); end
end

class Steep::Diagnostic::Signature::InvalidTypeApplication
end

class Steep::Diagnostic::Signature::InvalidVarianceAnnotation
  def initialize(name:, param:, location:); end

  def name(); end

  def param(); end
end

class Steep::Diagnostic::Signature::InvalidVarianceAnnotation
end

class Steep::Diagnostic::Signature::MixinClassError
  def initialize(location:, member:, type_name:); end

  def member(); end

  def type_name(); end
end

class Steep::Diagnostic::Signature::MixinClassError
end

class Steep::Diagnostic::Signature::ModuleSelfTypeError
  def ancestor(); end

  def initialize(name:, ancestor:, relation:, location:); end

  def name(); end

  def relation(); end
end

class Steep::Diagnostic::Signature::ModuleSelfTypeError
end

class Steep::Diagnostic::Signature::NonregularTypeAlias
  def initialize(type_name:, nonregular_type:, location:); end

  def nonregular_type(); end

  def type_name(); end
end

class Steep::Diagnostic::Signature::NonregularTypeAlias
end

class Steep::Diagnostic::Signature::RecursiveAlias
  def class_name(); end

  def initialize(class_name:, names:, location:); end

  def names(); end
end

class Steep::Diagnostic::Signature::RecursiveAlias
end

class Steep::Diagnostic::Signature::RecursiveAncestor
  def ancestors(); end

  def initialize(ancestors:, location:); end
end

class Steep::Diagnostic::Signature::RecursiveAncestor
end

class Steep::Diagnostic::Signature::RecursiveTypeAlias
  def alias_names(); end

  def initialize(alias_names:, location:); end
end

class Steep::Diagnostic::Signature::RecursiveTypeAlias
end

class Steep::Diagnostic::Signature::SuperclassMismatch
  def initialize(name:, location:); end

  def name(); end
end

class Steep::Diagnostic::Signature::SuperclassMismatch
end

class Steep::Diagnostic::Signature::SyntaxError
  def exception(); end

  def initialize(exception, location:); end
end

class Steep::Diagnostic::Signature::SyntaxError
  def self.parser_syntax_error_message(exception); end
end

class Steep::Diagnostic::Signature::UnexpectedError
  def initialize(message:, location:); end

  def message(); end
end

class Steep::Diagnostic::Signature::UnexpectedError
end

class Steep::Diagnostic::Signature::UnknownMethodAlias
  def class_name(); end

  def initialize(class_name:, method_name:, location:); end

  def method_name(); end
end

class Steep::Diagnostic::Signature::UnknownMethodAlias
end

class Steep::Diagnostic::Signature::UnknownTypeName
  def initialize(name:, location:); end

  def name(); end
end

class Steep::Diagnostic::Signature::UnknownTypeName
end

class Steep::Diagnostic::Signature::UnsatisfiableTypeApplication
  def initialize(type_name:, type_arg:, type_param:, location:); end

  def type_arg(); end

  def type_name(); end

  def type_param(); end
end

class Steep::Diagnostic::Signature::UnsatisfiableTypeApplication
end

module Steep::Diagnostic::Signature
  def self.from_rbs_error(error, factory:); end
end

module Steep::Diagnostic
end

module Steep::Drivers
end

class Steep::Drivers::Annotations
  include ::Steep::Drivers::Utils::DriverHelper
  def command_line_patterns(); end

  def initialize(stdout:, stderr:); end

  def run(); end

  def stderr(); end

  def stdout(); end
end

class Steep::Drivers::Annotations
end

class Steep::Drivers::Check
  include ::Steep::Drivers::Utils::DriverHelper
  def command_line_patterns(); end

  def initialize(stdout:, stderr:); end

  def jobs_option(); end

  def print_expectations(project:, all_files:, expectations_path:, notifications:); end

  def print_result(project:, notifications:); end

  def run(); end

  def save_expectations(project:, all_files:, expectations_path:, notifications:); end

  def save_expectations_path(); end

  def save_expectations_path=(save_expectations_path); end

  def severity_level(); end

  def severity_level=(severity_level); end

  def stderr(); end

  def stdout(); end

  def with_expectations_path(); end

  def with_expectations_path=(with_expectations_path); end
end

Steep::Drivers::Check::LSP = LanguageServer::Protocol

class Steep::Drivers::Check
end

class Steep::Drivers::Checkfile
  include ::Steep::Drivers::Utils::DriverHelper
  def all_rbs(); end

  def all_rbs=(all_rbs); end

  def all_ruby(); end

  def all_ruby=(all_ruby); end

  def command_line_args(); end

  def initialize(stdout:, stderr:); end

  def jobs_option(); end

  def run(); end

  def stderr(); end

  def stdin_input(); end

  def stdout(); end
end

Steep::Drivers::Checkfile::LSP = LanguageServer::Protocol

class Steep::Drivers::Checkfile
end

class Steep::Drivers::DiagnosticPrinter
  def buffer(); end

  def color_severity(string, severity:); end

  def initialize(stdout:, buffer:); end

  def location(diagnostic); end

  def path(); end

  def print(diagnostic, prefix: T.unsafe(nil), source: T.unsafe(nil)); end

  def print_source_line(diagnostic, prefix: T.unsafe(nil)); end

  def severity_message(severity); end

  def stdout(); end
end

Steep::Drivers::DiagnosticPrinter::LSP = LanguageServer::Protocol

class Steep::Drivers::DiagnosticPrinter
end

class Steep::Drivers::Init
  include ::Steep::Drivers::Utils::DriverHelper
  def force_write(); end

  def force_write=(force_write); end

  def initialize(stdout:, stderr:); end

  def run(); end

  def stderr(); end

  def stdout(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Steep::Drivers::Init
end

class Steep::Drivers::Langserver
  include ::Steep::Drivers::Utils::DriverHelper
  def initialize(stdout:, stderr:, stdin:); end

  def jobs_option(); end

  def project(); end

  def reader(); end

  def run(); end

  def stderr(); end

  def stdin(); end

  def stdout(); end

  def type_check_queue(); end

  def type_check_thread(); end

  def write_mutex(); end

  def writer(); end
end

class Steep::Drivers::Langserver
end

class Steep::Drivers::PrintProject
  include ::Steep::Drivers::Utils::DriverHelper
  def initialize(stdout:, stderr:); end

  def run(); end

  def stderr(); end

  def stdout(); end
end

class Steep::Drivers::PrintProject
end

class Steep::Drivers::Stats
  include ::Steep::Drivers::Utils::DriverHelper
  def command_line_patterns(); end

  def format(); end

  def format=(format); end

  def initialize(stdout:, stderr:); end

  def jobs_option(); end

  def run(); end

  def stderr(); end

  def stdout(); end
end

class Steep::Drivers::Stats::CSVPrinter
  def initialize(io:); end

  def io(); end

  def print(stats_result); end
end

class Steep::Drivers::Stats::CSVPrinter
end

class Steep::Drivers::Stats::TablePrinter
  def initialize(io:); end

  def io(); end

  def print(stats_result); end
end

class Steep::Drivers::Stats::TablePrinter
end

class Steep::Drivers::Stats
end

module Steep::Drivers::Utils
end

module Steep::Drivers::Utils::DriverHelper
  def keep_diagnostic?(diagnostic, severity_level:); end

  def load_config(path: T.unsafe(nil)); end

  def request_id(); end

  def shutdown_exit(writer:, reader:); end

  def steepfile(); end

  def steepfile=(steepfile); end

  def wait_for_message(reader:, unknown_messages: T.unsafe(nil), &block); end

  def wait_for_response_id(reader:, id:, unknown_responses: T.unsafe(nil)); end
end

module Steep::Drivers::Utils::DriverHelper
end

class Steep::Drivers::Utils::JobsOption
  def default_jobs_count(); end

  def initialize(jobs_count_modifier: T.unsafe(nil)); end

  def jobs_count(); end

  def jobs_count=(jobs_count); end

  def jobs_count_modifier(); end

  def jobs_count_modifier=(jobs_count_modifier); end

  def jobs_count_value(); end

  def steep_command(); end

  def steep_command=(steep_command); end
end

class Steep::Drivers::Utils::JobsOption
end

module Steep::Drivers::Utils
end

class Steep::Drivers::Validate
  include ::Steep::Drivers::Utils::DriverHelper
  def initialize(stdout:, stderr:); end

  def run(); end

  def stderr(); end

  def stdout(); end
end

class Steep::Drivers::Validate
end

class Steep::Drivers::Vendor
  def clean_before(); end

  def clean_before=(clean_before); end

  def initialize(stdout:, stderr:, stdin:); end

  def run(); end

  def stderr(); end

  def stdin(); end

  def stdout(); end

  def vendor_dir(); end

  def vendor_dir=(vendor_dir); end
end

class Steep::Drivers::Vendor
end

class Steep::Drivers::Watch
  include ::Steep::Drivers::Utils::DriverHelper
  def dirs(); end

  def initialize(stdout:, stderr:); end

  def jobs_option(); end

  def queue(); end

  def run(); end

  def severity_level(); end

  def severity_level=(severity_level); end

  def stderr(); end

  def stdout(); end

  def watching?(changed_path, files:, dirs:); end
end

Steep::Drivers::Watch::LSP = LanguageServer::Protocol

class Steep::Drivers::Watch
end

class Steep::Drivers::Worker
  include ::Steep::Drivers::Utils::DriverHelper
  def commandline_args(); end

  def commandline_args=(commandline_args); end

  def delay_shutdown(); end

  def delay_shutdown=(delay_shutdown); end

  def index(); end

  def index=(index); end

  def initialize(stdout:, stderr:, stdin:); end

  def max_index(); end

  def max_index=(max_index); end

  def run(); end

  def stderr(); end

  def stdin(); end

  def stdout(); end

  def worker_name(); end

  def worker_name=(worker_name); end

  def worker_type(); end

  def worker_type=(worker_type); end
end

class Steep::Drivers::Worker
end

module Steep::Drivers
end

module Steep::Equatable
  def ==(other); end

  def eql?(other); end

  def hash(); end
end

module Steep::Equatable
end

class Steep::Expectations
  def diagnostics(); end

  def test(path:, diagnostics:); end

  def to_yaml(); end
end

class Steep::Expectations::Diagnostic
  def lsp_severity(); end

  def sort_key(); end

  def to_hash(); end

  def to_lsp(); end
end

Steep::Expectations::Diagnostic::DiagnosticSeverity = LanguageServer::Protocol::Constant::DiagnosticSeverity

class Steep::Expectations::Diagnostic
  def self.from_hash(hash); end

  def self.from_lsp(diagnostic); end
end

Steep::Expectations::LSP = LanguageServer::Protocol

class Steep::Expectations::TestResult
  def actual(); end

  def each_diagnostics(); end

  def empty?(); end

  def expectation(); end

  def expected_diagnostics(); end

  def initialize(path:, expectation:, actual:); end

  def missing_diagnostics(); end

  def path(); end

  def satisfied?(); end

  def unexpected_diagnostics(); end
end

class Steep::Expectations::TestResult
end

class Steep::Expectations
  def self.empty(); end

  def self.load(path:, content:); end
end

module Steep::Index
end

class Steep::Index::RBSIndex
  def add_constant_declaration(const_name, decl); end

  def add_global_declaration(global_name, decl); end

  def add_method_declaration(method_name, member); end

  def add_type_declaration(type_name, declaration); end

  def add_type_reference(type_name, ref); end

  def const_index(); end

  def each_declaration(type_name: T.unsafe(nil), method_name: T.unsafe(nil), const_name: T.unsafe(nil), global_name: T.unsafe(nil), &block); end

  def each_entry(&block); end

  def each_reference(type_name:, &block); end

  def entry(type_name: T.unsafe(nil), method_name: T.unsafe(nil), const_name: T.unsafe(nil), global_name: T.unsafe(nil)); end

  def global_index(); end

  def method_index(); end

  def type_index(); end
end

class Steep::Index::RBSIndex::Builder
  def env(env); end

  def index(); end

  def initialize(index:); end

  def member(type_name, member); end

  def type_reference(type, from:); end
end

class Steep::Index::RBSIndex::Builder
end

class Steep::Index::RBSIndex::ConstantEntry
  def add_declaration(decl); end

  def const_name(); end

  def declarations(); end

  def initialize(const_name:); end
end

class Steep::Index::RBSIndex::ConstantEntry
end

class Steep::Index::RBSIndex::GlobalEntry
  def add_declaration(decl); end

  def declarations(); end

  def global_name(); end

  def initialize(global_name:); end
end

class Steep::Index::RBSIndex::GlobalEntry
end

class Steep::Index::RBSIndex::MethodEntry
  def add_declaration(decl); end

  def declarations(); end

  def initialize(method_name:); end

  def method_name(); end

  def references(); end
end

class Steep::Index::RBSIndex::MethodEntry
end

class Steep::Index::RBSIndex::TypeEntry
  def add_declaration(decl); end

  def add_reference(ref); end

  def declarations(); end

  def initialize(type_name:); end

  def references(); end

  def type_name(); end
end

class Steep::Index::RBSIndex::TypeEntry
end

class Steep::Index::RBSIndex
end

class Steep::Index::SignatureSymbolProvider
  def assigned?(path); end

  def assignment(); end

  def indexes(); end

  def initialize(project:, assignment:); end

  def project(); end

  def query_symbol(query); end
end

Steep::Index::SignatureSymbolProvider::LSP = LanguageServer::Protocol

class Steep::Index::SignatureSymbolProvider::SymbolInformation
end

class Steep::Index::SignatureSymbolProvider::SymbolInformation
end

class Steep::Index::SignatureSymbolProvider
  def self.test_const_name(query, type_name); end

  def self.test_global_name(query, type_name); end

  def self.test_method_name(query, method_name); end

  def self.test_type_name(query, type_name); end
end

class Steep::Index::SourceIndex
  def add_definition(definition:, constant: T.unsafe(nil), method: T.unsafe(nil)); end

  def add_reference(ref:, constant: T.unsafe(nil), method: T.unsafe(nil)); end

  def constant_index(); end

  def count(); end

  def entry(constant: T.unsafe(nil), method: T.unsafe(nil)); end

  def initialize(source:, parent: T.unsafe(nil)); end

  def merge!(child); end

  def method_index(); end

  def new_child(); end

  def parent(); end

  def parent_count(); end

  def reference(constant_node: T.unsafe(nil)); end

  def source(); end
end

class Steep::Index::SourceIndex::ConstantEntry
  def add_definition(node); end

  def add_reference(node); end

  def definitions(); end

  def initialize(name:); end

  def merge!(other); end

  def name(); end

  def references(); end
end

class Steep::Index::SourceIndex::ConstantEntry
end

class Steep::Index::SourceIndex::MethodEntry
  def add_definition(node); end

  def add_reference(node); end

  def definitions(); end

  def initialize(name:); end

  def merge!(other); end

  def name(); end

  def references(); end
end

class Steep::Index::SourceIndex::MethodEntry
end

class Steep::Index::SourceIndex
end

module Steep::Index
end

class Steep::InstanceMethodName
  def method_name(); end

  def method_name=(_); end

  def relative(); end

  def type_name(); end

  def type_name=(_); end
end

class Steep::InstanceMethodName
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Steep::Interface
end

class Steep::Interface::Block
  def +(other); end

  def ==(other); end

  def closed?(); end

  def eql?(other); end

  def free_variables(); end

  def initialize(type:, optional:, self_type:); end

  def map_type(&block); end

  def optional(); end

  def optional?(); end

  def required?(); end

  def self_type(); end

  def subst(s); end

  def to_optional(); end

  def to_proc_type(); end

  def type(); end
end

class Steep::Interface::Block
end

class Steep::Interface::Builder
  def app_subst(type); end

  def class_subst(type); end

  def factory(); end

  def fetch_cache(cache, key); end

  def initialize(factory); end

  def interface_subst(type); end

  def intersection_shape(type, shapes); end

  def method_name_for(type_def, name); end

  def object_shape(type_name); end

  def object_shape_cache(); end

  def proc_shape(proc, proc_shape); end

  def raw_shape(type, config); end

  def record_shape(record); end

  def replace_primitive_method(method_name, method_def, method_type); end

  def self_shape(type, config); end

  def shape(type, config); end

  def singleton_shape(type_name); end

  def singleton_shape_cache(); end

  def subtyping(); end

  def tuple_shape(tuple); end

  def union_shape(shape_type, shapes); end

  def union_shape_cache(); end
end

class Steep::Interface::Builder::Config
  def class_type(); end

  def initialize(self_type:, variable_bounds:, class_type: T.unsafe(nil), instance_type: T.unsafe(nil)); end

  def instance_type(); end

  def self_type(); end

  def subst(); end

  def upper_bound(a); end

  def validate_class_type(); end

  def validate_fvs(name, type); end

  def validate_instance_type(); end

  def validate_self_type(); end

  def variable_bounds(); end
end

class Steep::Interface::Builder::Config
  def self.empty(); end
end

class Steep::Interface::Builder
end

class Steep::Interface::Function
  def ==(other); end

  def closed?(); end

  def each_child(&block); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(); end

  def initialize(params:, return_type:, location:); end

  def location(); end

  def map_type(&block); end

  def params(); end

  def return_type(); end

  def subst(s); end

  def with(params: T.unsafe(nil), return_type: T.unsafe(nil)); end
end

class Steep::Interface::Function::Params
  def &(other); end

  def +(other); end

  def ==(other); end

  def closed?(); end

  def drop_first(); end

  def each_positional_param(&block); end

  def each_type(&block); end

  def empty?(); end

  def eql?(other); end

  def first_param(); end

  def flat_keywords(); end

  def flat_unnamed_params(); end

  def free_variables(); end

  def has_keywords?(); end

  def has_positional?(); end

  def initialize(positional_params:, keyword_params:); end

  def keyword_params(); end

  def map_type(&block); end

  def optional(); end

  def optional?(); end

  def optional_keywords(); end

  def positional_params(); end

  def required(); end

  def required_keywords(); end

  def rest(); end

  def rest_keywords(); end

  def size(); end

  def subst(s); end

  def update(positional_params: T.unsafe(nil), keyword_params: T.unsafe(nil)); end

  def with_first_param(param); end

  def without_keywords(); end

  def |(other); end
end

class Steep::Interface::Function::Params::KeywordParams
  include ::Steep::Interface::Function::Params::Utils
  def &(other); end

  def +(other); end

  def ==(other); end

  def each(&block); end

  def each_type(); end

  def empty?(); end

  def eql?(other); end

  def initialize(requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil)); end

  def keywords(); end

  def map_type(&block); end

  def optionals(); end

  def requireds(); end

  def rest(); end

  def size(); end

  def subst(s); end

  def update(requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil)); end

  def |(other); end
end

class Steep::Interface::Function::Params::KeywordParams
end

class Steep::Interface::Function::Params::PositionalParams
  def ==(other); end

  def each(&block); end

  def each_type(); end

  def eql?(other); end

  def head(); end

  def initialize(head:, tail:); end

  def map(&block); end

  def map_type(&block); end

  def size(); end

  def subst(s); end

  def tail(); end

  def to_ary(); end
end

class Steep::Interface::Function::Params::PositionalParams::Base
  def ==(other); end

  def eql?(other); end

  def initialize(type); end

  def map_type(&block); end

  def subst(s); end

  def type(); end

  def var_type(); end
end

class Steep::Interface::Function::Params::PositionalParams::Base
end

class Steep::Interface::Function::Params::PositionalParams::Optional
end

class Steep::Interface::Function::Params::PositionalParams::Optional
end

class Steep::Interface::Function::Params::PositionalParams::Required
end

class Steep::Interface::Function::Params::PositionalParams::Required
end

class Steep::Interface::Function::Params::PositionalParams::Rest
end

class Steep::Interface::Function::Params::PositionalParams::Rest
end

class Steep::Interface::Function::Params::PositionalParams
  extend ::Steep::Interface::Function::Params::Utils
  def self.build(required:, optional:, rest:); end

  def self.merge_for_intersection(xs, ys); end

  def self.merge_for_overload(xs, ys); end

  def self.merge_for_union(xs, ys); end

  def self.optional(type, tail=T.unsafe(nil)); end

  def self.required(type, tail=T.unsafe(nil)); end

  def self.rest(type, tail=T.unsafe(nil)); end
end

module Steep::Interface::Function::Params::Utils
  def intersection(*types); end

  def union(*types, null: T.unsafe(nil)); end
end

module Steep::Interface::Function::Params::Utils
end

class Steep::Interface::Function::Params
  def self.build(required: T.unsafe(nil), optional: T.unsafe(nil), rest: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil)); end

  def self.empty(); end
end

class Steep::Interface::Function
end

class Steep::Interface::MethodType
  def &(other); end

  def +(other); end

  def ==(other); end

  def block(); end

  def each_type(&block); end

  def eql?(other); end

  def equals_modulo_type_params?(other); end

  def free_variables(); end

  def initialize(type_params:, type:, block:, method_decls:); end

  def instantiate(s); end

  def map_type(&block); end

  def method_decls(); end

  def subst(s); end

  def type(); end

  def type_params(); end

  def unify_overload(other); end

  def with(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), method_decls: T.unsafe(nil)); end

  def |(other); end
end

class Steep::Interface::MethodType
  def self.intersection(type1, type2, check); end

  def self.try_type_params(type1, type2, check, generate, relation); end

  def self.union(type1, type2, check); end
end

class Steep::Interface::Shape
  def initialize(type:, private:, methods: T.unsafe(nil)); end

  def methods(); end

  def private?(); end

  def public?(); end

  def public_shape(); end

  def subst(s, type: T.unsafe(nil)); end

  def type(); end

  def update(type: T.unsafe(nil), methods: T.unsafe(nil)); end
end

class Steep::Interface::Shape::Entry
  def force(); end

  def has_method_type?(); end

  def initialize(private_method:, method_types: T.unsafe(nil), &block); end

  def method_types(); end

  def private_method?(); end

  def public_method?(); end
end

class Steep::Interface::Shape::Entry
end

class Steep::Interface::Shape::Methods
  include ::Enumerable
  def [](name); end

  def []=(name, entry); end

  def each(&block); end

  def each_name(&block); end

  def initialize(substs:, methods:); end

  def key?(name); end

  def merge!(other, &block); end

  def methods(); end

  def public_methods(); end

  def push_substitution(subst); end

  def resolved_methods(); end

  def subst(); end

  def substs(); end
end

class Steep::Interface::Shape::Methods
end

class Steep::Interface::Shape
end

class Steep::Interface::Substitution
  def [](key); end

  def add!(v, ty); end

  def apply?(type); end

  def dictionary(); end

  def domain(); end

  def empty?(); end

  def except(vars); end

  def except!(vars); end

  def initialize(dictionary:, instance_type:, module_type:, self_type:); end

  def instance_type(); end

  def key?(var); end

  def merge(s); end

  def merge!(s, overwrite: T.unsafe(nil)); end

  def module_type(); end

  def self_type(); end

  def update(self_type: T.unsafe(nil), instance_type: T.unsafe(nil), module_type: T.unsafe(nil)); end
end

class Steep::Interface::Substitution::InvalidSubstitutionError
  def initialize(vars_size:, types_size:); end

  def types_size(); end

  def vars_size(); end
end

class Steep::Interface::Substitution::InvalidSubstitutionError
end

class Steep::Interface::Substitution
  def self.build(vars, types=T.unsafe(nil), instance_type: T.unsafe(nil), module_type: T.unsafe(nil), self_type: T.unsafe(nil)); end

  def self.empty(); end
end

class Steep::Interface::TypeParam
  def ==(other); end

  def eql?(other); end

  def initialize(name:, upper_bound:, variance:, unchecked:, location: T.unsafe(nil)); end

  def location(); end

  def name(); end

  def subst(s); end

  def unchecked(); end

  def update(name: T.unsafe(nil), upper_bound: T.unsafe(nil), variance: T.unsafe(nil), unchecked: T.unsafe(nil), location: T.unsafe(nil)); end

  def upper_bound(); end

  def variance(); end
end

class Steep::Interface::TypeParam
  def self.rename(params, conflicting_names=T.unsafe(nil), new_names=T.unsafe(nil)); end
end

module Steep::Interface
end

module Steep::ModuleHelper
  def module_name_from_node(parent_node, constant_name); end

  def namespace_from_node(node); end
end

module Steep::ModuleHelper
end

module Steep::NodeHelper
  def clone_node(node); end

  def deconstruct_case_node(node); end

  def deconstruct_case_node!(node); end

  def deconstruct_if_node(node); end

  def deconstruct_if_node!(node); end

  def deconstruct_resbody_node(node); end

  def deconstruct_resbody_node!(node); end

  def deconstruct_rescue_node(node); end

  def deconstruct_rescue_node!(node); end

  def deconstruct_send_node(node); end

  def deconstruct_send_node!(node); end

  def deconstruct_sendish_and_block_nodes(*nodes); end

  def deconstruct_when_node(node); end

  def deconstruct_when_node!(node); end

  def deconstruct_whileish_node(node); end

  def deconstruct_whileish_node!(node); end

  def each_child_node(node, &block); end

  def each_descendant_node(node, &block); end

  def private_send?(node); end

  def test_case_node(node); end

  def test_if_node(node); end

  def test_resbody_node(node); end

  def test_rescue_node(node); end

  def test_send_node(node); end

  def test_when_node(node); end

  def test_whileish_node(node); end

  def value_node?(node); end
end

module Steep::NodeHelper
end

module Steep::PathHelper
end

module Steep::PathHelper
  def self.to_pathname(uri, dosish: T.unsafe(nil)); end

  def self.to_pathname!(uri, dosish: T.unsafe(nil)); end

  def self.to_uri(path, dosish: T.unsafe(nil)); end
end

class Steep::Project
  def absolute_path(path); end

  def base_dir(); end

  def initialize(steepfile_path:, base_dir: T.unsafe(nil)); end

  def relative_path(path); end

  def steepfile_path(); end

  def target_for_source_path(path); end

  def targets(); end

  def targets_for_path(path); end
end

class Steep::Project::DSL
  def initialize(project:); end

  def project(); end

  def target(name, template: T.unsafe(nil), &block); end
end

class Steep::Project::DSL::TargetDSL
  def check(*args); end

  def code_diagnostics_config(); end

  def collection_config(path); end

  def collection_config_path(); end

  def configure_code_diagnostics(hash=T.unsafe(nil)); end

  def core_root(); end

  def disable_collection(); end

  def ignore(*args); end

  def ignored_sources(); end

  def initialize(name, sources: T.unsafe(nil), libraries: T.unsafe(nil), signatures: T.unsafe(nil), ignored_sources: T.unsafe(nil), repo_paths: T.unsafe(nil), code_diagnostics_config: T.unsafe(nil), project: T.unsafe(nil), collection_config_path: T.unsafe(nil)); end

  def libraries(); end

  def library(*args); end

  def name(); end

  def no_builtin!(value=T.unsafe(nil)); end

  def project(); end

  def project!(); end

  def repo_path(*paths); end

  def repo_paths(); end

  def signature(*args); end

  def signatures(); end

  def sources(); end

  def stdlib_path(core_root:, stdlib_root:); end

  def stdlib_root(); end

  def typing_options(level=T.unsafe(nil), **hash); end

  def update(name: T.unsafe(nil), sources: T.unsafe(nil), libraries: T.unsafe(nil), ignored_sources: T.unsafe(nil), signatures: T.unsafe(nil), project: T.unsafe(nil)); end

  def vendor(dir=T.unsafe(nil), stdlib: T.unsafe(nil), gems: T.unsafe(nil)); end
end

class Steep::Project::DSL::TargetDSL
end

class Steep::Project::DSL
  def self.parse(project, code, filename: T.unsafe(nil)); end

  def self.register_template(name, target); end

  def self.templates(); end
end

class Steep::Project::Options
  def collection_config_path(); end

  def collection_config_path=(collection_config_path); end

  def collection_lock(); end

  def collection_lock_path(); end

  def libraries(); end

  def load_collection_lock(force: T.unsafe(nil)); end

  def paths(); end

  def paths=(paths); end
end

class Steep::Project::Options::PathOptions
  def core_root(); end

  def core_root=(_); end

  def customized_core?(); end

  def customized_stdlib?(); end

  def repo_paths(); end

  def repo_paths=(_); end

  def stdlib_root(); end

  def stdlib_root=(_); end
end

class Steep::Project::Options::PathOptions
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Project::Options
end

class Steep::Project::Pattern
  def =~(path); end

  def ext(); end

  def ignore?(path); end

  def ignore_prefixes(); end

  def ignores(); end

  def initialize(patterns:, ext:, ignores: T.unsafe(nil)); end

  def match?(path); end

  def patterns(); end

  def prefixes(); end

  def test_string(path, patterns, prefixes); end
end

class Steep::Project::Pattern
end

class Steep::Project::Target
  def code_diagnostics_config(); end

  def initialize(name:, options:, source_pattern:, signature_pattern:, code_diagnostics_config:); end

  def name(); end

  def new_env_loader(project:); end

  def options(); end

  def possible_signature_file?(path); end

  def possible_source_file?(path); end

  def signature_pattern(); end

  def source_pattern(); end
end

class Steep::Project::Target
  def self.construct_env_loader(options:, project:); end
end

class Steep::Project
end

module Steep::Server
end

class Steep::Server::BaseWorker
  def handle_job(job); end

  def handle_request(request); end

  def initialize(project:, reader:, writer:); end

  def project(); end

  def queue(); end

  def reader(); end

  def run(); end

  def skip_job?(); end

  def skip_jobs_after_shutdown!(flag=T.unsafe(nil)); end

  def skip_jobs_after_shutdown?(); end

  def writer(); end
end

Steep::Server::BaseWorker::LSP = LanguageServer::Protocol

class Steep::Server::BaseWorker::ShutdownJob
  def id(); end

  def id=(_); end
end

class Steep::Server::BaseWorker::ShutdownJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::BaseWorker
end

module Steep::Server::ChangeBuffer
  def buffered_changes(); end

  def collect_changes(request); end

  def load_files(project:, commandline_args:); end

  def mutex(); end

  def pop_buffer(); end

  def push_buffer(); end

  def reset_change(uri:, text:); end
end

module Steep::Server::ChangeBuffer
end

class Steep::Server::DelayQueue
  def delay(); end

  def execute(&block); end

  def initialize(delay:); end

  def last_task(); end

  def queue(); end

  def thread(); end
end

class Steep::Server::DelayQueue
end

class Steep::Server::InteractionWorker
  include ::Steep::Server::ChangeBuffer
  def format_completion_item(item); end

  def format_completion_item_for_rbs(sig_service, type_name, job, complete_text, prefix_size); end

  def initialize(project:, reader:, writer:, queue: T.unsafe(nil)); end

  def process_completion(job); end

  def process_hover(job); end

  def process_latest_job(job); end

  def process_signature_help(job); end

  def queue_job(job); end

  def service(); end
end

class Steep::Server::InteractionWorker::ApplyChangeJob
end

class Steep::Server::InteractionWorker::ApplyChangeJob
end

class Steep::Server::InteractionWorker::CompletionJob
  def column(); end

  def column=(_); end

  def id(); end

  def id=(_); end

  def line(); end

  def line=(_); end

  def path(); end

  def path=(_); end

  def trigger(); end

  def trigger=(_); end
end

class Steep::Server::InteractionWorker::CompletionJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::InteractionWorker::HoverJob
  def column(); end

  def column=(_); end

  def id(); end

  def id=(_); end

  def line(); end

  def line=(_); end

  def path(); end

  def path=(_); end
end

class Steep::Server::InteractionWorker::HoverJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

Steep::Server::InteractionWorker::LSP = LanguageServer::Protocol

class Steep::Server::InteractionWorker::SignatureHelpJob
  def column(); end

  def column=(_); end

  def id(); end

  def id=(_); end

  def line(); end

  def line=(_); end

  def path(); end

  def path=(_); end
end

class Steep::Server::InteractionWorker::SignatureHelpJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::InteractionWorker
end

module Steep::Server::LSPFormatter
  include ::Steep::Services
end

Steep::Server::LSPFormatter::LSP = LanguageServer::Protocol

module Steep::Server::LSPFormatter
  def self.declaration_summary(decl); end

  def self.format_comment(comment, header: T.unsafe(nil), &block); end

  def self.format_comments(comments); end

  def self.format_completion_docs(item); end

  def self.format_hover_content(content); end

  def self.format_method_item_doc(method_types, method_names, comments, footer=T.unsafe(nil)); end

  def self.format_rbs_completion_docs(type_name, decl, comments); end

  def self.instance_variable(name, type); end

  def self.local_variable(name, type); end

  def self.markup_content(string=T.unsafe(nil), &block); end

  def self.name_and_args(name, args); end

  def self.name_and_params(name, params); end
end

class Steep::Server::Master
  def broadcast_notification(message); end

  def commandline_args(); end

  def controller(); end

  def current_type_check_request(); end

  def each_worker(&block); end

  def file_system_watcher_supported?(); end

  def fresh_request_id(); end

  def group_request(); end

  def initialize(project:, reader:, writer:, interaction_worker:, typecheck_workers:, queue: T.unsafe(nil)); end

  def initialize_params(); end

  def interaction_worker(); end

  def job_queue(); end

  def kill(); end

  def on_type_check_update(guid:, path:); end

  def pathname(uri); end

  def process_message_from_client(message); end

  def process_message_from_worker(message, worker:); end

  def project(); end

  def reader(); end

  def result_controller(); end

  def send_notification(message, worker:); end

  def send_request(method:, worker:, id: T.unsafe(nil), params: T.unsafe(nil), &block); end

  def start(); end

  def start_type_check(request, last_request:, start_progress:); end

  def start_type_checking_queue(); end

  def typecheck_automatically(); end

  def typecheck_automatically=(typecheck_automatically); end

  def typecheck_workers(); end

  def work_done_progress_supported?(); end

  def writer(); end
end

class Steep::Server::Master::GroupHandler
  def <<(handler); end

  def completed?(); end

  def completion_handler(); end

  def handlers(); end

  def on_completion(&block); end

  def process_response(message); end

  def request(); end
end

class Steep::Server::Master::GroupHandler
end

Steep::Server::Master::LSP = LanguageServer::Protocol

module Steep::Server::Master::MessageUtils
  def id(); end

  def method(); end

  def notification?(); end

  def params(); end

  def request?(); end

  def response?(); end

  def result(); end
end

module Steep::Server::Master::MessageUtils
end

class Steep::Server::Master::ReceiveMessageJob
  include ::Steep::Server::Master::MessageUtils
  def message(); end

  def message=(_); end

  def source(); end

  def source=(_); end
end

class Steep::Server::Master::ReceiveMessageJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::Master::ResultController
  def <<(handler); end

  def handlers(); end

  def process_response(message); end

  def request_group(); end
end

class Steep::Server::Master::ResultController
end

class Steep::Server::Master::ResultHandler
  def completed?(); end

  def completion_handler(); end

  def initialize(request:); end

  def on_completion(&block); end

  def process_response(message); end

  def request(); end

  def response(); end

  def result(); end
end

class Steep::Server::Master::ResultHandler
end

class Steep::Server::Master::SendMessageJob
  include ::Steep::Server::Master::MessageUtils
  def dest(); end

  def dest=(_); end

  def message(); end

  def message=(_); end
end

class Steep::Server::Master::SendMessageJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end

  def self.to_client(message:); end

  def self.to_worker(worker, message:); end
end

class Steep::Server::Master::TypeCheckController
  def changed_paths(); end

  def initialize(project:); end

  def load(command_line_args:); end

  def make_request(guid: T.unsafe(nil), last_request: T.unsafe(nil), include_unchanged: T.unsafe(nil)); end

  def priority_paths(); end

  def project(); end

  def push_changes(path); end

  def target_paths(); end

  def update_priority(open: T.unsafe(nil), close: T.unsafe(nil)); end
end

class Steep::Server::Master::TypeCheckController::TargetPaths
  def <<(path, library: T.unsafe(nil)); end

  def add(path, library: T.unsafe(nil)); end

  def all_paths(); end

  def code_path?(path); end

  def code_paths(); end

  def initialize(project:, target:); end

  def library_path?(path); end

  def library_paths(); end

  def project(); end

  def signature_path?(path); end

  def signature_paths(); end

  def target(); end
end

class Steep::Server::Master::TypeCheckController::TargetPaths
end

class Steep::Server::Master::TypeCheckController
end

class Steep::Server::Master::TypeCheckRequest
  def all_paths(); end

  def as_json(assignment:); end

  def checked(path); end

  def checked_paths(); end

  def checking_path?(path); end

  def code_paths(); end

  def finished?(); end

  def guid(); end

  def initialize(guid:); end

  def library_paths(); end

  def percentage(); end

  def priority_paths(); end

  def signature_paths(); end

  def total(); end

  def unchecked_code_paths(); end

  def unchecked_library_paths(); end

  def unchecked_paths(); end

  def unchecked_signature_paths(); end

  def uri(path); end
end

class Steep::Server::Master::TypeCheckRequest
end

class Steep::Server::Master
end

class Steep::Server::TypeCheckWorker
  include ::Steep::Server::ChangeBuffer
  def assignment(); end

  def commandline_args(); end

  def current_type_check_guid(); end

  def enqueue_typecheck_jobs(params); end

  def goto(job); end

  def initialize(project:, reader:, writer:, assignment:, commandline_args:); end

  def service(); end

  def stats_result(); end

  def typecheck_progress(guid:, path:); end

  def workspace_symbol_result(query); end
end

class Steep::Server::TypeCheckWorker::GotoJob
  def definition?(); end

  def id(); end

  def id=(_); end

  def implementation?(); end

  def kind(); end

  def kind=(_); end

  def params(); end

  def params=(_); end

  def type_definition?(); end
end

class Steep::Server::TypeCheckWorker::GotoJob
  def self.[](*arg); end

  def self.definition(id:, params:); end

  def self.implementation(id:, params:); end

  def self.keyword_init?(); end

  def self.members(); end

  def self.type_definition(id:, params:); end
end

class Steep::Server::TypeCheckWorker::StartTypeCheckJob
  def changes(); end

  def changes=(_); end

  def guid(); end

  def guid=(_); end
end

class Steep::Server::TypeCheckWorker::StartTypeCheckJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::TypeCheckWorker::StatsJob
  def id(); end

  def id=(_); end
end

class Steep::Server::TypeCheckWorker::StatsJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::TypeCheckWorker::TypeCheckCodeJob
  def guid(); end

  def guid=(_); end

  def path(); end

  def path=(_); end
end

class Steep::Server::TypeCheckWorker::TypeCheckCodeJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::TypeCheckWorker::ValidateAppSignatureJob
  def guid(); end

  def guid=(_); end

  def path(); end

  def path=(_); end
end

class Steep::Server::TypeCheckWorker::ValidateAppSignatureJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::TypeCheckWorker::ValidateLibrarySignatureJob
  def guid(); end

  def guid=(_); end

  def path(); end

  def path=(_); end
end

class Steep::Server::TypeCheckWorker::ValidateLibrarySignatureJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::TypeCheckWorker::WorkspaceSymbolJob
  def id(); end

  def id=(_); end

  def query(); end

  def query=(_); end
end

class Steep::Server::TypeCheckWorker::WorkspaceSymbolJob
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Server::TypeCheckWorker
end

class Steep::Server::WorkerProcess
  def <<(message); end

  def index(); end

  def initialize(reader:, writer:, stderr:, wait_thread:, name:, index: T.unsafe(nil)); end

  def kill(force: T.unsafe(nil)); end

  def name(); end

  def read(&block); end

  def reader(); end

  def stderr(); end

  def wait_thread(); end

  def writer(); end
end

class Steep::Server::WorkerProcess
  def self.fork_worker(type, name:, steepfile:, index:, delay_shutdown:, patterns:); end

  def self.spawn_worker(type, name:, steepfile:, steep_command:, index:, delay_shutdown:, patterns:); end

  def self.start_typecheck_workers(steepfile:, args:, steep_command:, count: T.unsafe(nil), delay_shutdown: T.unsafe(nil)); end

  def self.start_worker(type, name:, steepfile:, steep_command:, index: T.unsafe(nil), delay_shutdown: T.unsafe(nil), patterns: T.unsafe(nil)); end
end

module Steep::Server
end

module Steep::Services
end

class Steep::Services::CompletionProvider
  include ::Steep::NodeHelper
  def at_comment?(position); end

  def at_end?(pos, of:); end

  def constant_items_for_context(context, position:, prefix:, items:, parent: T.unsafe(nil)); end

  def disallowed_method?(name); end

  def env(); end

  def index_for(string, line:, column:); end

  def initialize(source_text:, path:, subtyping:); end

  def instance_variable_items_for_context(context, position:, prefix:, items:); end

  def items_for_atmark(position:); end

  def items_for_colon2(position:); end

  def items_for_dot(position:); end

  def items_for_following_keyword_arguments(text, index:, line:, column:, items:); end

  def items_for_qcall(position:); end

  def items_for_rbs(position:, buffer:); end

  def items_for_trigger(position:); end

  def keyword_argument_items_for_method(call_node:, send_node:, position:, prefix:, items:); end

  def local_variable_items_for_context(context, position:, prefix:, items:); end

  def method_items_for_receiver_type(type, include_private:, prefix:, position:, items:); end

  def modified_text(); end

  def path(); end

  def range_for(position, prefix: T.unsafe(nil)); end

  def range_from_loc(loc); end

  def run(line:, column:); end

  def source(); end

  def source_text(); end

  def subtyping(); end

  def type_check!(text, line:, column:); end

  def typing(); end

  def unwrap_optional(type); end

  def word_name?(name); end
end

class Steep::Services::CompletionProvider::ComplexMethodNameItem
  def defining_method_name(type_name, name, member); end

  def identifier(); end

  def identifier=(_); end

  def method_decls(); end

  def method_decls=(_); end

  def method_definitions(); end

  def method_names(); end

  def method_types(); end

  def method_types=(_); end

  def range(); end

  def range=(_); end

  def receiver_type(); end

  def receiver_type=(_); end
end

class Steep::Services::CompletionProvider::ComplexMethodNameItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::ConstantItem
  def class?(); end

  def comments(); end

  def decl(); end

  def env(); end

  def env=(_); end

  def full_name(); end

  def full_name=(_); end

  def identifier(); end

  def identifier=(_); end

  def module?(); end

  def range(); end

  def range=(_); end

  def type(); end

  def type=(_); end
end

class Steep::Services::CompletionProvider::ConstantItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::GeneratedMethodNameItem
  def identifier(); end

  def identifier=(_); end

  def method_types(); end

  def method_types=(_); end

  def range(); end

  def range=(_); end

  def receiver_type(); end

  def receiver_type=(_); end
end

class Steep::Services::CompletionProvider::GeneratedMethodNameItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::InstanceVariableItem
  def identifier(); end

  def identifier=(_); end

  def range(); end

  def range=(_); end

  def type(); end

  def type=(_); end
end

class Steep::Services::CompletionProvider::InstanceVariableItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::KeywordArgumentItem
  def identifier(); end

  def identifier=(_); end

  def range(); end

  def range=(_); end
end

class Steep::Services::CompletionProvider::KeywordArgumentItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::LocalVariableItem
  def identifier(); end

  def identifier=(_); end

  def range(); end

  def range=(_); end

  def type(); end

  def type=(_); end
end

class Steep::Services::CompletionProvider::LocalVariableItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::Position
  def -(size); end

  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end
end

class Steep::Services::CompletionProvider::Position
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::Range
  def end(); end

  def end=(_); end

  def start(); end

  def start=(_); end
end

class Steep::Services::CompletionProvider::Range
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::SimpleMethodNameItem
  def comment(); end

  def identifier(); end

  def identifier=(_); end

  def method_member(); end

  def method_member=(_); end

  def method_name(); end

  def method_name=(_); end

  def method_types(); end

  def method_types=(_); end

  def range(); end

  def range=(_); end

  def receiver_type(); end

  def receiver_type=(_); end
end

class Steep::Services::CompletionProvider::SimpleMethodNameItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::CompletionProvider::TextItem
end

class Steep::Services::CompletionProvider::TextItem
end

class Steep::Services::CompletionProvider::TypeNameItem
  def comments(); end

  def decl(); end
end

class Steep::Services::CompletionProvider::TypeNameItem
end

class Steep::Services::CompletionProvider
end

class Steep::Services::ContentChange
  def ==(other); end

  def apply_to(text); end

  def eql?(other); end

  def initialize(text:, range: T.unsafe(nil)); end

  def range(); end

  def text(); end
end

class Steep::Services::ContentChange::Position
  def ==(other); end

  def column(); end

  def eql?(other); end

  def initialize(line:, column:); end

  def line(); end
end

class Steep::Services::ContentChange::Position
end

class Steep::Services::ContentChange
  def self.string(string); end
end

class Steep::Services::FileLoader
  def base_dir(); end

  def each_path_in_patterns(pattern, commandline_patterns=T.unsafe(nil)); end

  def initialize(base_dir:); end

  def load_changes(pattern, command_line_patterns=T.unsafe(nil), changes:); end
end

class Steep::Services::FileLoader
end

class Steep::Services::GotoService
  include ::Steep::ModuleHelper
  def assignment(); end

  def constant_definition_in_rbs(name, locations:); end

  def constant_definition_in_ruby(name, locations:); end

  def definition(path:, line:, column:); end

  def each_type_name(type, &block); end

  def implementation(path:, line:, column:); end

  def initialize(type_check:, assignment:); end

  def method_locations(name, in_ruby:, in_rbs:, locations:); end

  def project(); end

  def query_at(path:, line:, column:); end

  def test_ast_location(loc, line:, column:); end

  def type_check(); end

  def type_check_path(target:, path:, content:, line:, column:); end

  def type_definition(path:, line:, column:); end

  def type_name_locations(name, locations: T.unsafe(nil)); end
end

class Steep::Services::GotoService::ConstantQuery
  include ::Steep::Services::GotoService::SourceHelper
end

class Steep::Services::GotoService::ConstantQuery
end

class Steep::Services::GotoService::MethodQuery
  include ::Steep::Services::GotoService::SourceHelper
end

class Steep::Services::GotoService::MethodQuery
end

module Steep::Services::GotoService::SourceHelper
  def from_rbs?(); end

  def from_ruby?(); end
end

module Steep::Services::GotoService::SourceHelper
end

class Steep::Services::GotoService::TypeNameQuery
end

class Steep::Services::GotoService::TypeNameQuery
end

class Steep::Services::GotoService
end

module Steep::Services::HoverProvider
end

class Steep::Services::HoverProvider::RBS
  def content_for(target:, path:, line:, column:); end

  def content_for_type_name(type_name, env:, location:); end

  def initialize(service:); end

  def project(); end

  def service(); end
end

class Steep::Services::HoverProvider::RBS::ClassContent
  def decl(); end

  def decl=(_); end

  def location(); end

  def location=(_); end
end

class Steep::Services::HoverProvider::RBS::ClassContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::RBS::InterfaceContent
  def decl(); end

  def decl=(_); end

  def location(); end

  def location=(_); end
end

class Steep::Services::HoverProvider::RBS::InterfaceContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::RBS::TypeAliasContent
  def decl(); end

  def decl=(_); end

  def location(); end

  def location=(_); end
end

class Steep::Services::HoverProvider::RBS::TypeAliasContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::RBS
end

class Steep::Services::HoverProvider::Ruby
  def content_for(target:, path:, line:, column:); end

  def initialize(service:); end

  def method_definition_for(factory, type_name, singleton_method: T.unsafe(nil), instance_method: T.unsafe(nil)); end

  def method_name_from_method(context, builder:); end

  def project(); end

  def service(); end

  def typecheck(target, path:, content:, line:, column:); end
end

class Steep::Services::HoverProvider::Ruby::ConstantContent
  def class_alias(); end

  def class_decl(); end

  def class_or_module?(); end

  def comments(); end

  def constant?(); end

  def constant_decl(); end

  def decl(); end

  def decl=(_); end

  def full_name(); end

  def full_name=(_); end

  def location(); end

  def location=(_); end

  def type(); end

  def type=(_); end
end

class Steep::Services::HoverProvider::Ruby::ConstantContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::Ruby::DefinitionContent
  def definition(); end

  def definition=(_); end

  def location(); end

  def location=(_); end

  def method_name(); end

  def method_name=(_); end

  def method_type(); end

  def method_type=(_); end

  def node(); end

  def node=(_); end
end

class Steep::Services::HoverProvider::Ruby::DefinitionContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::Ruby::MethodCallContent
  def location(); end

  def location=(_); end

  def method_call(); end

  def method_call=(_); end

  def node(); end

  def node=(_); end
end

class Steep::Services::HoverProvider::Ruby::MethodCallContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::Ruby::TypeAssertionContent
  def asserted_type(); end

  def asserted_type=(_); end

  def location(); end

  def location=(_); end

  def node(); end

  def node=(_); end

  def original_type(); end

  def original_type=(_); end
end

class Steep::Services::HoverProvider::Ruby::TypeAssertionContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::Ruby::TypeContent
  def location(); end

  def location=(_); end

  def node(); end

  def node=(_); end

  def type(); end

  def type=(_); end
end

class Steep::Services::HoverProvider::Ruby::TypeContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::Ruby::VariableContent
  def location(); end

  def location=(_); end

  def name(); end

  def name=(_); end

  def node(); end

  def node=(_); end

  def type(); end

  def type=(_); end
end

class Steep::Services::HoverProvider::Ruby::VariableContent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::HoverProvider::Ruby
end

module Steep::Services::HoverProvider::SingletonMethods
  def content_for(service:, path:, line:, column:); end
end

module Steep::Services::HoverProvider::SingletonMethods
end

module Steep::Services::HoverProvider
  extend ::Steep::Services::HoverProvider::SingletonMethods
end

class Steep::Services::PathAssignment
  def ===(path); end

  def =~(path); end

  def cache(); end

  def index(); end

  def initialize(index:, max_index:); end

  def max_index(); end
end

class Steep::Services::PathAssignment
  def self.all(); end

  def self.index_for(path:, max_index:); end
end

class Steep::Services::SignatureHelpProvider
  include ::Steep::NodeHelper
  def active_parameter_for(method_type, argument_nodes, last_argument_nodes, node); end

  def buffer(); end

  def env(); end

  def initialize(source:, subtyping:); end

  def last_argument_nodes_for(argument_nodes:, line:, column:); end

  def path(); end

  def run(line:, column:); end

  def signature_help_for(node, argument, last_argument, typing); end

  def source(); end

  def subtyping(); end

  def type_check!(line:, column:); end

  def typing(); end
end

class Steep::Services::SignatureHelpProvider::Item
  def active_parameter(); end

  def active_parameter=(_); end

  def comment(); end

  def comment=(_); end

  def method_type(); end

  def method_type=(_); end

  def parameters(); end
end

class Steep::Services::SignatureHelpProvider::Item
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

Steep::Services::SignatureHelpProvider::MethodCall = Steep::TypeInference::MethodCall

class Steep::Services::SignatureHelpProvider
end

class Steep::Services::SignatureService
  def add_descendants(graph:, names:, set:); end

  def add_nested_decls(env:, names:, set:); end

  def apply_changes(files, changes); end

  def const_decls(paths:, env:); end

  def current_subtyping(); end

  def each_rbs_path(&block); end

  def env_rbs_paths(); end

  def files(); end

  def global_decls(paths:, env: T.unsafe(nil)); end

  def initialize(env:); end

  def latest_builder(); end

  def latest_constant_resolver(); end

  def latest_env(); end

  def latest_rbs_index(); end

  def pending_changed_paths(); end

  def rescue_rbs_error(errors); end

  def status(); end

  def type_name_from_decl(decl, set:); end

  def type_names(paths:, env:); end

  def update(changes); end

  def update_builder(ancestor_builder:, paths:); end

  def update_env(updated_files, paths:); end
end

class Steep::Services::SignatureService::AncestorErrorStatus
  def changed_paths(); end

  def constant_resolver(); end

  def diagnostics(); end

  def files(); end

  def initialize(files:, changed_paths:, diagnostics:, last_builder:); end

  def last_builder(); end

  def rbs_index(); end
end

class Steep::Services::SignatureService::AncestorErrorStatus
end

class Steep::Services::SignatureService::FileStatus
  def content(); end

  def content=(_); end

  def path(); end

  def path=(_); end

  def signature(); end

  def signature=(_); end
end

class Steep::Services::SignatureService::FileStatus
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::SignatureService::LoadedStatus
  def builder(); end

  def constant_resolver(); end

  def files(); end

  def initialize(files:, builder:); end

  def rbs_index(); end

  def subtyping(); end
end

class Steep::Services::SignatureService::LoadedStatus
end

class Steep::Services::SignatureService::SyntaxErrorStatus
  def changed_paths(); end

  def constant_resolver(); end

  def diagnostics(); end

  def files(); end

  def initialize(files:, changed_paths:, diagnostics:, last_builder:); end

  def last_builder(); end

  def rbs_index(); end
end

class Steep::Services::SignatureService::SyntaxErrorStatus
end

class Steep::Services::SignatureService
  def self.load_from(loader); end
end

class Steep::Services::StatsCalculator
  def calc_stats(target, file:); end

  def initialize(service:); end

  def project(); end

  def service(); end
end

class Steep::Services::StatsCalculator::ErrorStats
  def as_json(); end
end

class Steep::Services::StatsCalculator::ErrorStats
end

class Steep::Services::StatsCalculator::SuccessStats
  def as_json(); end
end

class Steep::Services::StatsCalculator::SuccessStats
end

class Steep::Services::StatsCalculator
end

class Steep::Services::TypeCheckService
  def app_signature_file?(path); end

  def diagnostics(); end

  def each_diagnostics(&block); end

  def has_diagnostics?(); end

  def initialize(project:); end

  def lib_signature_file?(path); end

  def project(); end

  def signature_diagnostics(); end

  def signature_file?(path); end

  def signature_services(); end

  def signature_validation_diagnostics(); end

  def source_file?(path); end

  def source_files(); end

  def type_check_file(target:, subtyping:, path:, text:); end

  def typecheck_source(path:, target: T.unsafe(nil), &block); end

  def update(changes:); end

  def update_and_check(changes:, assignment:, &block); end

  def update_signature(changes:, requests:); end

  def update_sources(changes:, requests:); end

  def validate_signature(path:, &block); end
end

class Steep::Services::TypeCheckService::SourceFile
  def content(); end

  def diagnostics(); end

  def errors(); end

  def ignores(); end

  def initialize(path:, node:, content:, typing:, ignores:, errors:); end

  def node(); end

  def path(); end

  def target(); end

  def typing(); end

  def update_content(content); end
end

class Steep::Services::TypeCheckService::SourceFile
  def self.no_data(path:, content:); end

  def self.with_syntax_error(path:, content:, error:); end

  def self.with_typing(path:, content:, typing:, node:, ignores:); end
end

class Steep::Services::TypeCheckService::TargetRequest
  def ==(other); end

  def empty?(); end

  def eql?(other); end

  def initialize(target:); end

  def signature_updated!(value=T.unsafe(nil)); end

  def signature_updated?(); end

  def source_paths(); end

  def target(); end
end

class Steep::Services::TypeCheckService::TargetRequest
end

class Steep::Services::TypeCheckService
  def self.type_check(source:, subtyping:, constant_resolver:); end
end

class Steep::Services::TypeNameCompletion
  def context(); end

  def each_outer_module(context=T.unsafe(nil), &block); end

  def each_type_name(&block); end

  def each_type_name_under(module_name, normalized_name, table:, &block); end

  def env(); end

  def find_type_names(prefix); end

  def initialize(env:, context:, dirs:); end

  def map(); end

  def resolve_name_in_context(name); end

  def resolve_used_name(name); end

  def type_name_resolver(); end
end

module Steep::Services::TypeNameCompletion::Prefix
end

class Steep::Services::TypeNameCompletion::Prefix::NamespacePrefix
  def namespace(); end

  def namespace=(_); end

  def size=(_); end
end

class Steep::Services::TypeNameCompletion::Prefix::NamespacePrefix
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::TypeNameCompletion::Prefix::NamespacedIdentPrefix
  def const_name?(); end

  def ident(); end

  def ident=(_); end

  def namespace(); end

  def namespace=(_); end

  def size=(_); end
end

class Steep::Services::TypeNameCompletion::Prefix::NamespacedIdentPrefix
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Services::TypeNameCompletion::Prefix::RawIdentPrefix
  def const_name?(); end

  def ident(); end

  def ident=(_); end
end

class Steep::Services::TypeNameCompletion::Prefix::RawIdentPrefix
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Steep::Services::TypeNameCompletion::Prefix
  def self.parse(buffer, line:, column:); end
end

class Steep::Services::TypeNameCompletion
end

module Steep::Services
end

module Steep::Signature
end

class Steep::Signature::Validator
  def ancestor_to_type(ancestor); end

  def builder(); end

  def checker(); end

  def context(); end

  def each_error(&block); end

  def each_method_type(definition); end

  def each_variable_type(definition); end

  def env(); end

  def factory(); end

  def has_error?(); end

  def initialize(checker:); end

  def latest_context(); end

  def mixin_constraints(definition, mixin_ancestors, immediate_self_types:); end

  def no_error?(); end

  def push_context(self_type: T.unsafe(nil), class_type: T.unsafe(nil), instance_type: T.unsafe(nil)); end

  def rescue_validation_errors(type_name=T.unsafe(nil)); end

  def type_name_resolver(); end

  def validate(); end

  def validate_alias(); end

  def validate_ancestor_application(name, ancestor); end

  def validate_const(); end

  def validate_decl(); end

  def validate_definition_type(definition); end

  def validate_global(); end

  def validate_one_alias(name, entry=T.unsafe(nil)); end

  def validate_one_class(name); end

  def validate_one_class_alias(name, entry); end

  def validate_one_class_decl(name, entry); end

  def validate_one_constant(name, entry); end

  def validate_one_global(name, entry); end

  def validate_one_interface(name); end

  def validate_type(type); end

  def validate_type_application(type); end

  def validate_type_application_constraints(type_name, type_params, type_args, location:); end

  def validator(); end
end

Steep::Signature::Validator::Declarations = RBS::AST::Declarations

Steep::Signature::Validator::Location = RBS::Location

class Steep::Signature::Validator
end

module Steep::Signature
end

class Steep::SingletonMethodName
  def method_name(); end

  def method_name=(_); end

  def relative(); end

  def type_name(); end

  def type_name=(_); end
end

class Steep::SingletonMethodName
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Source
  def annotations(block:, factory:, context:); end

  def buffer(); end

  def comments(); end

  def each_annotation(&block); end

  def each_heredoc_node(node=T.unsafe(nil), parents=T.unsafe(nil), &block); end

  def find_comment(line:, column:); end

  def find_heredoc_nodes(line, column, position); end

  def find_nodes(line:, column:); end

  def find_nodes_loc(node, position, parents); end

  def ignores(); end

  def initialize(buffer:, path:, node:, mapping:, comments:, ignores:); end

  def mapping(); end

  def node(); end

  def path(); end

  def without_unrelated_defs(line:, column:); end
end

class Steep::Source::Builder
end

class Steep::Source::Builder
end

class Steep::Source::IgnoreRanges
  def all_ignores(); end

  def error_ignores(); end

  def ignore?(start_line, end_line, code); end

  def ignore_code?(line, code); end

  def ignored_lines(); end

  def ignored_ranges(); end

  def initialize(ignores:); end
end

class Steep::Source::IgnoreRanges
end

class Steep::Source
  extend ::Steep::NodeHelper
  def self.adjust_location(node); end

  def self.assertion_node(node, type); end

  def self.construct_mapping(node:, annotations:, mapping:, line_range: T.unsafe(nil)); end

  def self.delete_defs(node, allow_list); end

  def self.insert_type_node(node, comments); end

  def self.map_child_node(node, type=T.unsafe(nil), skip: T.unsafe(nil)); end

  def self.new_parser(); end

  def self.parse(source_code, path:, factory:); end

  def self.sendish_node?(node); end

  def self.type_application_node(node, tapp); end
end

module Steep::Subtyping
end

class Steep::Subtyping::Cache
  def [](relation, self_type, instance_type, class_type, bounds); end

  def []=(relation, self_type, instance_type, class_type, bounds, value); end

  def no_subtype_cache?(); end

  def subtype(relation, self_type, instance_type, class_type, bounds); end

  def subtypes(); end
end

class Steep::Subtyping::Cache
end

class Steep::Subtyping::Check
  include ::Steep::Subtyping::Result::Helper
  def Relation(sub, sup); end

  def alias?(type); end

  def arg_type?(type); end

  def assumptions(); end

  def builder(); end

  def cache(); end

  def cache_bounds(relation); end

  def cacheable?(relation); end

  def check(relation, constraints:, self_type:, instance_type:, class_type:); end

  def check_constraints(relation, variables:, variance:); end

  def check_function(name, relation); end

  def check_generic_method_type(name, relation); end

  def check_interface(relation); end

  def check_method(name, relation); end

  def check_method_params(name, relation); end

  def check_method_type(name, relation); end

  def check_self_type_binding(relation, sub_self, super_self); end

  def check_type(relation); end

  def check_type0(relation); end

  def check_type_arg(relation); end

  def class_type(); end

  def constraints(); end

  def definition_for_type(type); end

  def each_ancestor(ancestors, &block); end

  def expand_alias(type, &block); end

  def expand_block_given(name, relation, &block); end

  def factory(); end

  def false_type?(type); end

  def hole_path(type, path=T.unsafe(nil)); end

  def initialize(builder:); end

  def instance_super_types(type_name, args:); end

  def instance_type(); end

  def match_method_type_fails?(name, type1, type2); end

  def match_params(name, relation); end

  def push_assumption(relation); end

  def push_variable_bounds(params); end

  def same_type?(relation); end

  def self_type(); end

  def singleton_super_types(type_name); end

  def true_type?(type); end

  def variable_upper_bound(name); end

  def variable_upper_bounds(); end

  def with_context(self_type:, instance_type:, class_type:, constraints:); end
  ABORT_LIMIT = ::T.let(nil, ::T.untyped)
end

class Steep::Subtyping::Check
end

class Steep::Subtyping::Constraints
  def add(var, sub_type: T.unsafe(nil), super_type: T.unsafe(nil), skip: T.unsafe(nil)); end

  def add_var(*vars); end

  def dictionary(); end

  def each(&blk); end

  def eliminate_variable(type, to:); end

  def empty?(); end

  def has_constraint?(var); end

  def initialize(unknowns:); end

  def lower_bound(var, skip: T.unsafe(nil)); end

  def lower_bound_types(var_name); end

  def solution(checker, variables:, variance: T.unsafe(nil), self_type: T.unsafe(nil), instance_type: T.unsafe(nil), class_type: T.unsafe(nil), context: T.unsafe(nil)); end

  def unknown!(var); end

  def unknown?(var); end

  def unknowns(); end

  def upper_bound(var, skip: T.unsafe(nil)); end

  def upper_bound_types(var_name); end

  def vars(); end
end

class Steep::Subtyping::Constraints::Context
  def class_type(); end

  def class_type=(_); end

  def instance_type(); end

  def instance_type=(_); end

  def self_type(); end

  def self_type=(_); end

  def variance(); end

  def variance=(_); end
end

class Steep::Subtyping::Constraints::Context
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::Subtyping::Constraints::UnsatisfiableConstraint
  def initialize(var:, sub_type:, super_type:, result:); end

  def result(); end

  def sub_type(); end

  def super_type(); end

  def var(); end
end

class Steep::Subtyping::Constraints::UnsatisfiableConstraint
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError
  def constraints(); end

  def initialize(reason:, constraints:); end

  def reason(); end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::UnknownsFreeVariableNotDisjoint
  def initialize(var:, lower_bound:, upper_bound:); end

  def lower_bound(); end

  def message(); end

  def upper_bound(); end

  def var(); end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::UnknownsFreeVariableNotDisjoint
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesFreeVariablesNotDisjoint
  def initialize(var: T.unsafe(nil), lower_bound: T.unsafe(nil), upper_bound: T.unsafe(nil)); end

  def lower_bound(); end

  def message(); end

  def upper_bound(); end

  def var(); end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesFreeVariablesNotDisjoint
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesUnknownsNotDisjoint
  def initialize(vars:); end

  def message(); end

  def vars(); end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesUnknownsNotDisjoint
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError
end

class Steep::Subtyping::Constraints
  def self.empty(); end
end

class Steep::Subtyping::Relation
  def ==(other); end

  def assert_type(type); end

  def block!(); end

  def block?(); end

  def eql?(other); end

  def flip(); end

  def function!(); end

  def function?(); end

  def initialize(sub_type:, super_type:); end

  def interface!(); end

  def interface?(); end

  def map(); end

  def method!(); end

  def method?(); end

  def params!(); end

  def params?(); end

  def sub_type(); end

  def super_type(); end

  def to_ary(); end

  def type!(); end

  def type?(); end
end

class Steep::Subtyping::Relation
end

module Steep::Subtyping::Result
end

class Steep::Subtyping::Result::All
  def add(*relations, &block); end

  def add_result(result); end

  def branches(); end

  def success?(); end
end

class Steep::Subtyping::Result::All
end

class Steep::Subtyping::Result::Any
  def add(*relations, &block); end

  def branches(); end

  def success?(); end
end

class Steep::Subtyping::Result::Any
end

class Steep::Subtyping::Result::Base
  def else(); end

  def failure?(); end

  def failure_path(path=T.unsafe(nil)); end

  def initialize(relation); end

  def relation(); end
end

class Steep::Subtyping::Result::Base
end

class Steep::Subtyping::Result::Expand
  def child(); end

  def initialize(relation, &block); end

  def success?(); end
end

class Steep::Subtyping::Result::Expand
end

class Steep::Subtyping::Result::Failure
  def error(); end

  def initialize(relation, error); end

  def success?(); end
end

class Steep::Subtyping::Result::Failure::BlockMismatchError
  def initialize(name:); end

  def message(); end

  def name(); end
end

class Steep::Subtyping::Result::Failure::BlockMismatchError
end

class Steep::Subtyping::Result::Failure::LoopAbort
  def message(); end
end

class Steep::Subtyping::Result::Failure::LoopAbort
end

class Steep::Subtyping::Result::Failure::MethodMissingError
  def initialize(name:); end

  def message(); end

  def name(); end
end

class Steep::Subtyping::Result::Failure::MethodMissingError
end

class Steep::Subtyping::Result::Failure::ParameterMismatchError
  def initialize(name:); end

  def message(); end

  def name(); end
end

class Steep::Subtyping::Result::Failure::ParameterMismatchError
end

class Steep::Subtyping::Result::Failure::PolyMethodSubtyping
  def initialize(name:); end

  def message(); end

  def name(); end
end

class Steep::Subtyping::Result::Failure::PolyMethodSubtyping
end

class Steep::Subtyping::Result::Failure::SelfBindingMismatch
  def message(); end
end

class Steep::Subtyping::Result::Failure::SelfBindingMismatch
end

class Steep::Subtyping::Result::Failure::UnknownPairError
  def initialize(relation:); end

  def message(); end

  def relation(); end
end

class Steep::Subtyping::Result::Failure::UnknownPairError
end

class Steep::Subtyping::Result::Failure::UnsatisfiedConstraints
  def error(); end

  def initialize(error); end

  def message(); end

  def result(); end

  def sub_type(); end

  def super_type(); end

  def var(); end
end

class Steep::Subtyping::Result::Failure::UnsatisfiedConstraints
end

class Steep::Subtyping::Result::Failure
end

module Steep::Subtyping::Result::Helper
  def All(relation, &block); end

  def Any(relation, &block); end

  def Expand(relation, &block); end

  def Failure(relation, error=T.unsafe(nil)); end

  def Skip(relation); end

  def Success(relation); end

  def success(relation); end
end

module Steep::Subtyping::Result::Helper
end

class Steep::Subtyping::Result::Skip
  def success?(); end
end

class Steep::Subtyping::Result::Skip
end

class Steep::Subtyping::Result::Success
  def success?(); end
end

class Steep::Subtyping::Result::Success
end

module Steep::Subtyping::Result
end

class Steep::Subtyping::VariableVariance
  def contravariant?(var); end

  def contravariants(); end

  def covariant?(var); end

  def covariants(); end

  def initialize(covariants:, contravariants:); end

  def invariant?(var); end
end

class Steep::Subtyping::VariableVariance
  def self.add_params(params, block:, covariants:, contravariants:); end

  def self.add_type(type, variance:, covariants:, contravariants:); end

  def self.from_method_type(method_type); end

  def self.from_type(type); end
end

module Steep::Subtyping
end

class Steep::ThreadWaiter
  def initialize(objects); end

  def objects(); end

  def queue(); end

  def wait_one(); end

  def waiter_threads(); end
end

class Steep::ThreadWaiter
end

class Steep::TypeConstruction
  include ::Steep::NodeHelper
  include ::Steep::ModuleHelper
  def absolute_name(name); end

  def add_call(call); end

  def add_typing(node, type:, constr: T.unsafe(nil)); end

  def annotations(); end

  def apply_solution(errors, node:, method_type:); end

  def arrayish_type?(type, untyped_is: T.unsafe(nil)); end

  def block_context(); end

  def block_context!(); end

  def break_context(); end

  def builder_config(); end

  def bypass_splat(node); end

  def calculate_interface(type, method_name=T.unsafe(nil), private:); end

  def check(node, type, constraints: T.unsafe(nil)); end

  def check_relation(sub_type:, super_type:, constraints: T.unsafe(nil)); end

  def checker(); end

  def context(); end

  def deep_expand_alias(type); end

  def default_module_context(implement_module_name, nesting:); end

  def eliminate_vars(type, variables, to: T.unsafe(nil)); end

  def expand_alias(type, &block); end

  def expand_self(type); end

  def fallback_to_any(node); end

  def flatten_array_elements(type); end

  def flatten_union(type); end

  def for_block(body_node, block_params:, block_param_hint:, block_type_hint:, block_block_hint:, block_annotations:, node_type_hint:, block_self_hint:); end

  def for_branch(node, break_context: T.unsafe(nil)); end

  def for_class(node, new_class_name, super_class_name); end

  def for_module(node, new_module_name); end

  def for_new_method(method_name, node, args:, self_type:, definition:); end

  def for_sclass(node, type); end

  def gvasgn(node, rhs_type); end

  def implement_module(module_name:, annotations:, super_name: T.unsafe(nil)); end

  def initialize(checker:, source:, annotations:, typing:, context:); end

  def instance_type(type); end

  def ivasgn(node, rhs_type); end

  def lvasgn(node, type); end

  def masgn_lhs?(lhs); end

  def meta_type(type); end

  def method_context(); end

  def method_context!(); end

  def module_context(); end

  def namespace_module?(node); end

  def nesting(); end

  def no_subtyping?(sub_type:, super_type:, constraints: T.unsafe(nil)); end

  def optional_proc?(type); end

  def partition_flatten_types(type, &block); end

  def pick_one_of(types, range:); end

  def pure_send?(call, receiver, arguments); end

  def save_typing(); end

  def select_flatten_types(type, &block); end

  def self_class?(node); end

  def self_type(); end

  def semantically_arrayish_type?(type); end

  def set_up_block_mlhs_params_env(node, type, hash, &block); end

  def singleton_type(type); end

  def source(); end

  def synthesize(node, hint: T.unsafe(nil), condition: T.unsafe(nil)); end

  def synthesize_block(node:, block_type_hint:, block_body:); end

  def synthesize_children(node, skips: T.unsafe(nil)); end

  def synthesize_constant(node, parent_node, constant_name); end

  def synthesize_constant_decl(node, parent_node, constant_name, &block); end

  def synthesize_sendish(node, hint:, tapp:); end

  def test_literal_type(literal, hint); end

  def to_instance_type(type, args: T.unsafe(nil)); end

  def try_array_type(node, hint); end

  def try_convert(type, method); end

  def try_convert_to_array(type); end

  def try_method_type(node, receiver_type:, method_name:, method_type:, arguments:, block_params:, block_body:, tapp:, hint:); end

  def try_special_method(node, receiver_type:, method_name:, method_type:, arguments:, block_params:, block_body:, hint:); end

  def try_tuple_type(array_node, hint); end

  def try_tuple_type!(node, hint: T.unsafe(nil)); end

  def type_any_rec(node, only_children: T.unsafe(nil)); end

  def type_block_without_hint(node:, block_annotations:, block_params:, block_body:); end

  def type_check_args(method_name, args, constraints, errors); end

  def type_check_argument(node, type:, constraints:, errors:, report_node: T.unsafe(nil)); end

  def type_check_untyped_args(arguments); end

  def type_hash(hash_node, hint:); end

  def type_hash_record(hash_node, record_type); end

  def type_lambda(node, params_node:, body_node:, type_hint:); end

  def type_masgn(node); end

  def type_masgn_type(mlhs_node, rhs_type, masgn:, optional:); end

  def type_method_call(node, method_name:, receiver_type:, method:, arguments:, block_params:, block_body:, tapp:, hint:); end

  def type_name(type); end

  def type_send(node, send_node:, block_params:, block_body:, tapp:, hint:, unwrap: T.unsafe(nil)); end

  def type_send_interface(node, interface:, receiver:, receiver_type:, method_name:, arguments:, block_params:, block_body:, tapp:, hint:); end

  def typing(); end

  def union_of_tuple_to_tuple_of_union(type); end

  def union_type(*types); end

  def union_type_unify(*types); end

  def unwrap(type); end

  def update_context(); end

  def update_type_env(); end

  def validate_method_definitions(node, module_name); end

  def variable_context(); end

  def with(annotations: T.unsafe(nil), context: T.unsafe(nil), typing: T.unsafe(nil)); end

  def with_child_typing(range:); end

  def with_class_constr(node, new_class_name, super_class_name); end

  def with_method_constr(method_name, node, args:, self_type:, definition:); end

  def with_module_constr(node, module_name); end

  def with_new_typing(typing); end

  def with_sclass_constr(node, type); end

  def with_updated_context(type_env: T.unsafe(nil)); end
  KNOWN_PURE_METHODS = ::T.let(nil, ::T.untyped)
  SPECIAL_LVAR_NAMES = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Steep::TypeConstruction::Pair
  def +(other); end

  def constr(); end

  def context(); end

  def initialize(type:, constr:); end

  def to_ary(); end

  def type(); end

  def with(type: T.unsafe(nil), constr: T.unsafe(nil)); end
end

class Steep::TypeConstruction::Pair
end

class Steep::TypeConstruction
end

module Steep::TypeInference
end

class Steep::TypeInference::BlockParams
  def block_param(); end

  def each(&block); end

  def each_single_param(); end

  def expandable?(); end

  def expandable_params?(params_type, factory); end

  def initialize(leading_params:, optional_params:, rest_param:, trailing_params:, block_param:); end

  def leading_params(); end

  def optional_params(); end

  def params(); end

  def params_type(hint: T.unsafe(nil)); end

  def params_type0(hint:); end

  def rest_param(); end

  def trailing_params(); end

  def untyped_args?(params); end

  def zip(params_type, block, factory:); end
end

class Steep::TypeInference::BlockParams::MultipleParam
  def ==(other); end

  def each_param(&block); end

  def eql?(other); end

  def initialize(node:, params:); end

  def node(); end

  def params(); end

  def type(); end

  def variable_types(); end
end

class Steep::TypeInference::BlockParams::MultipleParam
end

class Steep::TypeInference::BlockParams::Param
  def ==(other); end

  def each_param(&block); end

  def eql?(other); end

  def initialize(var:, type:, value:, node:); end

  def node(); end

  def type(); end

  def value(); end

  def var(); end
end

class Steep::TypeInference::BlockParams::Param
end

class Steep::TypeInference::BlockParams
  def self.from_multiple(node, annotations); end

  def self.from_node(node, annotations:); end
end

class Steep::TypeInference::CaseWhen
  include ::Steep::NodeHelper
  def assignment_node(); end

  def clause_results(); end

  def condition_node(); end

  def else_clause(); end

  def else_node(); end

  def else_result(); end

  def has_else_clause?(); end

  def initial_constr(); end

  def initialize(node, logic); end

  def latest_result(); end

  def location(); end

  def logic(); end

  def node(); end

  def propagate_value_node_type(env); end

  def result(); end

  def rewrite_condition_node(var_name, node); end

  def typing(); end

  def value_node(); end

  def var_name(); end

  def when_clauses(); end

  def when_nodes(); end
end

class Steep::TypeInference::CaseWhen::WhenPatterns
  include ::Steep::NodeHelper
  def add_pattern(pat); end

  def assignment_node(); end

  def body_result(); end

  def falsy_result(); end

  def initial_constr(); end

  def initialize(logic, initial_constr, unreachable_clause, assignment_node); end

  def latest_result(); end

  def logic(); end

  def pattern_results(); end

  def unreachable_clause(); end
end

class Steep::TypeInference::CaseWhen::WhenPatterns
end

class Steep::TypeInference::CaseWhen
  extend ::Steep::NodeHelper
  def self.type_check(constr, node, logic, hint:, condition:); end
end

class Steep::TypeInference::ConstantEnv
  def children(module_name); end

  def constants(); end

  def context(); end

  def decompose_constant(constant); end

  def decompose_constant!(constant); end

  def factory(); end

  def initialize(factory:, context:, resolver:); end

  def resolve(name); end

  def resolve_child(module_name, constant_name); end

  def resolver(); end

  def toplevel(name); end
end

class Steep::TypeInference::ConstantEnv
end

class Steep::TypeInference::Context
  def block_context(); end

  def break_context(); end

  def call_context(); end

  def env(); end

  def factory(); end

  def initialize(method_context:, block_context:, break_context:, module_context:, self_type:, type_env:, call_context:, variable_context:); end

  def method_context(); end

  def module_context(); end

  def self_type(); end

  def type_env(); end

  def variable_context(); end

  def with(method_context: T.unsafe(nil), block_context: T.unsafe(nil), break_context: T.unsafe(nil), module_context: T.unsafe(nil), self_type: T.unsafe(nil), type_env: T.unsafe(nil), call_context: T.unsafe(nil), variable_context: T.unsafe(nil)); end
end

class Steep::TypeInference::Context::BlockContext
  def body_type(); end

  def initialize(body_type:); end

  def subst(s); end
end

class Steep::TypeInference::Context::BlockContext
end

class Steep::TypeInference::Context::BreakContext
  def break_type(); end

  def initialize(break_type:, next_type:); end

  def next_type(); end

  def subst(s); end
end

class Steep::TypeInference::Context::BreakContext
end

class Steep::TypeInference::Context::MethodContext
  def attribute_setter?(); end

  def block_type(); end

  def forward_arg_type(); end

  def initialize(name:, method:, method_type:, return_type:, super_method:, forward_arg_type:); end

  def method(); end

  def method_type(); end

  def name(); end

  def return_type(); end

  def super_method(); end
end

class Steep::TypeInference::Context::MethodContext
end

class Steep::TypeInference::Context::ModuleContext
  def class_name(); end

  def class_variables(); end

  def defined_instance_methods(); end

  def defined_module_methods(); end

  def implement_name(); end

  def initialize(instance_type:, module_type:, implement_name:, class_name:, nesting:, instance_definition: T.unsafe(nil), module_definition: T.unsafe(nil)); end

  def instance_definition(); end

  def instance_type(); end

  def module_definition(); end

  def module_type(); end

  def nesting(); end

  def update(instance_type: T.unsafe(nil), module_type: T.unsafe(nil), implement_name: T.unsafe(nil), class_name: T.unsafe(nil), instance_definition: T.unsafe(nil), module_definition: T.unsafe(nil), nesting: T.unsafe(nil)); end
end

class Steep::TypeInference::Context::ModuleContext
end

class Steep::TypeInference::Context::TypeVariableContext
  def [](name); end

  def initialize(type_params, parent_context: T.unsafe(nil)); end

  def table(); end

  def type_params(); end

  def upper_bounds(); end
end

class Steep::TypeInference::Context::TypeVariableContext
  def self.empty(); end
end

class Steep::TypeInference::Context
end

class Steep::TypeInference::ContextArray
  def [](index); end

  def at(line:, column:); end

  def buffer(); end

  def context_at(index, entry: T.unsafe(nil)); end

  def each_entry(&block); end

  def initialize(buffer:, context:, range: T.unsafe(nil)); end

  def insert_context(range, context:, entry: T.unsafe(nil)); end

  def merge(subtree); end

  def range(); end

  def root(); end
end

class Steep::TypeInference::ContextArray::Entry
  def context(); end

  def initialize(range:, context:); end

  def range(); end

  def sub_entries(); end
end

class Steep::TypeInference::ContextArray::Entry
end

class Steep::TypeInference::ContextArray
  def self.from_source(source:, context:, range: T.unsafe(nil)); end
end

class Steep::TypeInference::LogicTypeInterpreter
  def config(); end

  def decompose_value(node); end

  def eval(env:, node:); end

  def evaluate_assignment(assignment_node, env, rhs_type); end

  def evaluate_method_call(env:, type:, receiver:, arguments:); end

  def evaluate_node(env:, node:, type: T.unsafe(nil)); end

  def factory(); end

  def guess_type_from_method(node); end

  def initialize(subtyping:, typing:, config:); end

  def literal_var_type_case_select(value_node, arg_type); end

  def no_subtyping?(sub_type:, super_type:); end

  def refine_node_type(env:, node:, truthy_type:, falsy_type:); end

  def subtyping(); end

  def subtyping?(sub_type:, super_type:); end

  def try_convert(type, method); end

  def type_case_select(type, klass); end

  def type_case_select0(type, klass); end

  def typing(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BOT = ::T.let(nil, ::T.untyped)
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
  UNTYPED = ::T.let(nil, ::T.untyped)
end

class Steep::TypeInference::LogicTypeInterpreter::Result
  def unreachable!(); end

  def update_env(); end

  def update_type(); end
end

class Steep::TypeInference::LogicTypeInterpreter::Result
end

class Steep::TypeInference::LogicTypeInterpreter
end

module Steep::TypeInference::MethodCall
end

class Steep::TypeInference::MethodCall::Base
  def ==(other); end

  def context(); end

  def eql?(other); end

  def initialize(node:, context:, method_name:, receiver_type:, return_type:); end

  def method_name(); end

  def node(); end

  def receiver_type(); end

  def return_type(); end

  def with_return_type(new_type); end
end

class Steep::TypeInference::MethodCall::Base
end

class Steep::TypeInference::MethodCall::Error
  def errors(); end

  def initialize(node:, context:, method_name:, receiver_type:, errors:, method_decls: T.unsafe(nil), return_type: T.unsafe(nil)); end

  def method_decls(); end
end

class Steep::TypeInference::MethodCall::Error
end

class Steep::TypeInference::MethodCall::MethodContext
  def method_name(); end

  def method_name=(_); end
end

class Steep::TypeInference::MethodCall::MethodContext
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::TypeInference::MethodCall::MethodDecl
  def ==(other); end

  def eql?(other); end

  def initialize(method_name:, method_def:); end

  def method_def(); end

  def method_name(); end

  def method_type(); end
end

class Steep::TypeInference::MethodCall::MethodDecl
end

class Steep::TypeInference::MethodCall::ModuleContext
  def type_name(); end

  def type_name=(_); end
end

class Steep::TypeInference::MethodCall::ModuleContext
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::TypeInference::MethodCall::NoMethodError
  def error(); end

  def initialize(node:, context:, method_name:, receiver_type:, error:); end
end

class Steep::TypeInference::MethodCall::NoMethodError
end

class Steep::TypeInference::MethodCall::Special
end

class Steep::TypeInference::MethodCall::Special
end

class Steep::TypeInference::MethodCall::TopLevelContext
  def ==(other); end

  def eql?(other); end
end

class Steep::TypeInference::MethodCall::TopLevelContext
end

class Steep::TypeInference::MethodCall::Typed
  def actual_method_type(); end

  def initialize(node:, context:, method_name:, receiver_type:, actual_method_type:, method_decls:, return_type:); end

  def method_decls(); end

  def pure?(); end

  def update(node: T.unsafe(nil), return_type: T.unsafe(nil)); end
end

class Steep::TypeInference::MethodCall::Typed
end

class Steep::TypeInference::MethodCall::UnknownContext
  def ==(other); end

  def eql?(other); end
end

class Steep::TypeInference::MethodCall::UnknownContext
end

class Steep::TypeInference::MethodCall::Untyped
  def initialize(node:, context:, method_name:); end
end

class Steep::TypeInference::MethodCall::Untyped
end

module Steep::TypeInference::MethodCall
end

class Steep::TypeInference::MethodParams
  def [](name); end

  def args(); end

  def each(&blk); end

  def each_param(&block); end

  def errors(); end

  def forward_arg_type(); end

  def initialize(args:, method_type:, forward_arg_type:); end

  def method_type(); end

  def param?(name); end

  def params(); end

  def size(); end

  def update(forward_arg_type: T.unsafe(nil)); end
end

class Steep::TypeInference::MethodParams::BaseParameter
  def ==(other); end

  def eql?(other); end

  def initialize(name:, type:, node:); end

  def name(); end

  def node(); end

  def optional?(); end

  def type(); end

  def untyped?(); end

  def value(); end

  def var_type(); end
end

class Steep::TypeInference::MethodParams::BaseParameter
end

class Steep::TypeInference::MethodParams::BaseRestParameter
  def ==(other); end

  def eql?(other); end

  def initialize(name:, type:, node:); end

  def name(); end

  def node(); end

  def type(); end
end

class Steep::TypeInference::MethodParams::BaseRestParameter
end

class Steep::TypeInference::MethodParams::BlockParameter
  def ==(other); end

  def eql?(other); end

  def initialize(name:, type:, node:, optional:, self_type:); end

  def name(); end

  def node(); end

  def optional?(); end

  def self_type(); end

  def type(); end

  def var_type(); end
end

class Steep::TypeInference::MethodParams::BlockParameter
end

class Steep::TypeInference::MethodParams::KeywordParameter
end

class Steep::TypeInference::MethodParams::KeywordParameter
end

class Steep::TypeInference::MethodParams::KeywordRestParameter
  def var_type(); end
end

class Steep::TypeInference::MethodParams::KeywordRestParameter
end

class Steep::TypeInference::MethodParams::PositionalParameter
end

class Steep::TypeInference::MethodParams::PositionalParameter
end

class Steep::TypeInference::MethodParams::PositionalRestParameter
  def var_type(); end
end

class Steep::TypeInference::MethodParams::PositionalRestParameter
end

class Steep::TypeInference::MethodParams
  def self.build(node:, method_type:); end

  def self.empty(node:); end
end

class Steep::TypeInference::MultipleAssignment
  def expand(mlhs, rhs_type, optional); end

  def expand_any(nodes, rhs_type, element_type, optional); end

  def expand_array(lhss, rhs_type, optional); end

  def expand_tuple(lhss, rhs_type, tuples, optional); end

  def hint_for_mlhs(mlhs, env); end
end

class Steep::TypeInference::MultipleAssignment::Assignments
  def each(&block); end

  def leading_assignments(); end

  def leading_assignments=(_); end

  def optional(); end

  def optional=(_); end

  def rhs_type(); end

  def rhs_type=(_); end

  def splat_assignment(); end

  def splat_assignment=(_); end

  def trailing_assignments(); end

  def trailing_assignments=(_); end
end

class Steep::TypeInference::MultipleAssignment::Assignments
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Steep::TypeInference::MultipleAssignment
end

class Steep::TypeInference::SendArgs
  def arguments(); end

  def block(); end

  def block_pass_arg(); end

  def each(&blk); end

  def forwarded_args_node(); end

  def initialize(node:, arguments:, type:); end

  def keyword_args(); end

  def keyword_params(); end

  def kwargs_node(); end

  def node(); end

  def params(); end

  def positional_arg(); end

  def positional_params(); end

  def type(); end
end

class Steep::TypeInference::SendArgs::BlockPassArg
  include ::Steep::Equatable
  def block(); end

  def block_missing?(); end

  def compatible?(); end

  def initialize(node:, block:); end

  def no_block?(); end

  def node(); end

  def node_type(); end

  def pair(); end

  def unexpected_block?(); end
end

class Steep::TypeInference::SendArgs::BlockPassArg
end

class Steep::TypeInference::SendArgs::ForwardedArgs
  def initialize(node:, params:); end

  def node(); end

  def params(); end
end

class Steep::TypeInference::SendArgs::ForwardedArgs
end

class Steep::TypeInference::SendArgs::KeywordArgs
  def all_keys(); end

  def all_values(); end

  def consume_keys(keys, node:); end

  def consumed_keywords(); end

  def index(); end

  def initialize(kwarg_nodes:, keyword_params:, index: T.unsafe(nil), consumed_keywords: T.unsafe(nil)); end

  def keyword_pair(); end

  def keyword_params(); end

  def keyword_type(key); end

  def kwarg_nodes(); end

  def next(); end

  def optional_keywords(); end

  def possible_key_type(); end

  def possible_value_type(); end

  def required_keywords(); end

  def rest_type(); end

  def update(index: T.unsafe(nil), consumed_keywords: T.unsafe(nil)); end
end

class Steep::TypeInference::SendArgs::KeywordArgs::ArgTypePairs
  include ::Steep::Equatable
  def [](index); end

  def initialize(pairs:); end

  def pairs(); end

  def size(); end
end

class Steep::TypeInference::SendArgs::KeywordArgs::ArgTypePairs
end

class Steep::TypeInference::SendArgs::KeywordArgs::MissingKeyword
  include ::Steep::Equatable
  def initialize(keywords:); end

  def keywords(); end
end

class Steep::TypeInference::SendArgs::KeywordArgs::MissingKeyword
end

class Steep::TypeInference::SendArgs::KeywordArgs::SplatArg
  include ::Steep::Equatable
  def initialize(node:); end

  def node(); end

  def type(); end

  def type=(type); end
end

class Steep::TypeInference::SendArgs::KeywordArgs::SplatArg
end

class Steep::TypeInference::SendArgs::KeywordArgs::UnexpectedKeyword
  include ::Steep::Equatable
  def initialize(keyword:, node:); end

  def key_node(); end

  def keyword(); end

  def node(); end

  def value_node(); end
end

class Steep::TypeInference::SendArgs::KeywordArgs::UnexpectedKeyword
end

class Steep::TypeInference::SendArgs::KeywordArgs
end

class Steep::TypeInference::SendArgs::PositionalArgs
  def args(); end

  def consume(n, node:); end

  def consume0(n, node:, params:, ps:); end

  def following_args(); end

  def index(); end

  def initialize(args:, index:, positional_params:, uniform: T.unsafe(nil)); end

  def next(); end

  def node(); end

  def param(); end

  def positional_params(); end

  def uniform(); end

  def uniform_type(); end

  def update(index: T.unsafe(nil), positional_params: T.unsafe(nil), uniform: T.unsafe(nil)); end
end

class Steep::TypeInference::SendArgs::PositionalArgs::MissingArg
  include ::Steep::Equatable
  def initialize(params:); end

  def params(); end
end

class Steep::TypeInference::SendArgs::PositionalArgs::MissingArg
end

class Steep::TypeInference::SendArgs::PositionalArgs::NodeParamPair
  include ::Steep::Equatable
  def initialize(node:, param:); end

  def node(); end

  def param(); end

  def to_ary(); end
end

class Steep::TypeInference::SendArgs::PositionalArgs::NodeParamPair
end

class Steep::TypeInference::SendArgs::PositionalArgs::NodeTypePair
  include ::Steep::Equatable
  def initialize(node:, type:); end

  def node(); end

  def node_type(); end

  def type(); end
end

class Steep::TypeInference::SendArgs::PositionalArgs::NodeTypePair
end

class Steep::TypeInference::SendArgs::PositionalArgs::SplatArg
  include ::Steep::Equatable
  def initialize(node:); end

  def node(); end

  def type(); end

  def type=(type); end
end

class Steep::TypeInference::SendArgs::PositionalArgs::SplatArg
end

class Steep::TypeInference::SendArgs::PositionalArgs::UnexpectedArg
  include ::Steep::Equatable
  def initialize(node:); end

  def node(); end
end

class Steep::TypeInference::SendArgs::PositionalArgs::UnexpectedArg
end

class Steep::TypeInference::SendArgs::PositionalArgs
end

class Steep::TypeInference::SendArgs
end

class Steep::TypeInference::TypeEnv
  include ::Steep::NodeHelper
  def [](name); end

  def add_pure_call(node, call, type); end

  def annotated_constant(name); end

  def assign_local_variable(name, var_type, enforced_type); end

  def assign_local_variables(assignments); end

  def constant(arg1, arg2); end

  def constant_env(); end

  def constant_types(); end

  def enforced_type(name); end

  def global_name?(name); end

  def global_types(); end

  def initialize(constant_env, local_variable_types: T.unsafe(nil), instance_variable_types: T.unsafe(nil), global_types: T.unsafe(nil), constant_types: T.unsafe(nil), pure_method_calls: T.unsafe(nil)); end

  def instance_variable_name?(name); end

  def instance_variable_types(); end

  def invalidate_pure_node(node); end

  def invalidated_pure_nodes(invalidated_node); end

  def join(*envs); end

  def local_variable_name!(name); end

  def local_variable_name?(name); end

  def local_variable_types(); end

  def merge(local_variable_types: T.unsafe(nil), instance_variable_types: T.unsafe(nil), global_types: T.unsafe(nil), constant_types: T.unsafe(nil), pure_method_calls: T.unsafe(nil)); end

  def pin_local_variables(names); end

  def pure_method_calls(); end

  def pure_node_invalidation(invalidated_nodes); end

  def refine_types(local_variable_types: T.unsafe(nil), pure_call_types: T.unsafe(nil)); end

  def replace_pure_call_type(node, type); end

  def subst(s); end

  def unpin_local_variables(names); end

  def update(local_variable_types: T.unsafe(nil), instance_variable_types: T.unsafe(nil), global_types: T.unsafe(nil), constant_types: T.unsafe(nil), pure_method_calls: T.unsafe(nil)); end
end

class Steep::TypeInference::TypeEnv
end

class Steep::TypeInference::TypeEnvBuilder
  def build(type_env); end

  def commands(); end

  def initialize(*commands); end
end

module Steep::TypeInference::TypeEnvBuilder::Command
end

class Steep::TypeInference::TypeEnvBuilder::Command::AnnotationsBase
  def annotations(); end

  def initialize(annotations); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::AnnotationsBase
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportConstantAnnotations
  def call(env); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportConstantAnnotations
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportGlobalDeclarations
  def call(env); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportGlobalDeclarations
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportInstanceVariableAnnotations
  def call(env); end

  def merge!(merge=T.unsafe(nil)); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportInstanceVariableAnnotations
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportInstanceVariableDefinition
  def call(env); end

  def definition(); end

  def factory(); end

  def initialize(definition, factory); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportInstanceVariableDefinition
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportLocalVariableAnnotations
  def call(env); end

  def merge!(merge=T.unsafe(nil)); end

  def on_duplicate(); end

  def on_duplicate!(&block); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::ImportLocalVariableAnnotations
end

class Steep::TypeInference::TypeEnvBuilder::Command::RBSBase
  def environment(); end

  def factory(); end

  def initialize(factory); end
end

class Steep::TypeInference::TypeEnvBuilder::Command::RBSBase
end

module Steep::TypeInference::TypeEnvBuilder::Command
end

class Steep::TypeInference::TypeEnvBuilder
end

module Steep::TypeInference
end

class Steep::Typing
  def add_call(node, call); end

  def add_context(range, context:); end

  def add_context_for_body(node, context:); end

  def add_context_for_node(node, context:); end

  def add_error(error); end

  def add_typing(node, type, _context); end

  def block_range(node); end

  def call_of(node:); end

  def context_at(line:, column:); end

  def contexts(); end

  def dump(io); end

  def each_typing(&block); end

  def errors(); end

  def has_type?(node); end

  def initialize(source:, root_context:, parent: T.unsafe(nil), parent_last_update: T.unsafe(nil), contexts: T.unsafe(nil), source_index: T.unsafe(nil)); end

  def last_update(); end

  def method_calls(); end

  def new_child(range); end

  def parent(); end

  def parent_last_update(); end

  def root_context(); end

  def save!(); end

  def should_update(); end

  def source(); end

  def source_index(); end

  def type_of(node:); end

  def typing(); end
end

class Steep::Typing::UnknownNodeError
  def initialize(op, node:); end

  def node(); end

  def op(); end
end

class Steep::Typing::UnknownNodeError
end

class Steep::Typing
  def self.summary(node); end
end

class String
  def dedup(); end

  def downcase_first(); end

  def parse_csv(**options); end

  def truncate_bytes(truncate_to, omission: T.unsafe(nil)); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class String
  def self.new(*arg); end
end

class StringIO
  def pread(*arg); end

  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct
  def self.new(*arg); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module TSort
  VERSION = ::T.let(nil, ::T.untyped)
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

class TZInfo::AbsoluteDayOfYearTransitionRule
  def get_day(offset, year); end

  def initialize(day, transition_at=T.unsafe(nil)); end

  def is_always_first_day_of_year?(); end

  def is_always_last_day_of_year?(); end
end

class TZInfo::AbsoluteDayOfYearTransitionRule
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def =~(regexp); end

  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def initialize(info); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.get(code); end
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def eager_load!(); end

  def get_country_info(code); end

  def get_timezone_info(identifier); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def lookup_country_info(hash, code, encoding=T.unsafe(nil)); end

  def timezone_identifier_encoding(); end

  def timezone_identifiers(); end

  def validate_timezone_identifier(identifier); end
end

class TZInfo::DataSource
  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

module TZInfo::DataSources
end

class TZInfo::DataSources::ConstantOffsetDataTimezoneInfo
  def constant_offset(); end

  def initialize(identifier, constant_offset); end
end

class TZInfo::DataSources::ConstantOffsetDataTimezoneInfo
end

class TZInfo::DataSources::CountryInfo
  def code(); end

  def initialize(code, name, zones); end

  def name(); end

  def zones(); end
end

class TZInfo::DataSources::CountryInfo
end

class TZInfo::DataSources::DataTimezoneInfo
  def period_for(timestamp); end

  def periods_for_local(local_timestamp); end

  def transitions_up_to(to_timestamp, from_timestamp=T.unsafe(nil)); end
end

class TZInfo::DataSources::DataTimezoneInfo
end

class TZInfo::DataSources::InvalidZoneinfoDirectory
end

class TZInfo::DataSources::InvalidZoneinfoDirectory
end

class TZInfo::DataSources::InvalidZoneinfoFile
end

class TZInfo::DataSources::InvalidZoneinfoFile
end

class TZInfo::DataSources::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::DataSources::LinkedTimezoneInfo
end

class TZInfo::DataSources::RubyDataSource
end

class TZInfo::DataSources::RubyDataSource
end

class TZInfo::DataSources::TZInfoDataNotFound
end

class TZInfo::DataSources::TZInfoDataNotFound
end

class TZInfo::DataSources::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::DataSources::TimezoneInfo
end

class TZInfo::DataSources::TransitionsDataTimezoneInfo
  def initialize(identifier, transitions); end

  def transitions(); end
end

class TZInfo::DataSources::TransitionsDataTimezoneInfo
end

class TZInfo::DataSources::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
end

class TZInfo::DataSources::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::DataSources::ZoneinfoDirectoryNotFound
end

class TZInfo::DataSources::ZoneinfoDirectoryNotFound
end

module TZInfo::DataSources
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DateTimeWithOffset
  include ::TZInfo::WithOffset
  def clear_timezone_offset(); end

  def downto(min); end

  def new_start(start=T.unsafe(nil)); end

  def set_timezone_offset(timezone_offset); end

  def step(limit, step=T.unsafe(nil)); end

  def timezone_offset(); end

  def upto(max); end
end

class TZInfo::DateTimeWithOffset
end

class TZInfo::DayOfYearTransitionRule
  def initialize(day, transition_at); end

  def seconds(); end
end

class TZInfo::DayOfYearTransitionRule
end

class TZInfo::InfoTimezone
  def info(); end

  def initialize(info); end
end

class TZInfo::InfoTimezone
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::OffsetTimezonePeriod
  def ==(p); end

  def eql?(p); end
end

class TZInfo::OffsetTimezonePeriod
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

class TZInfo::TimeWithOffset
  include ::TZInfo::WithOffset
  def clear_timezone_offset(); end

  def getlocal(*args); end

  def localtime(*args); end

  def round(ndigits=T.unsafe(nil)); end

  def set_timezone_offset(timezone_offset); end

  def timezone_offset(); end
end

class TZInfo::TimeWithOffset
end

class TZInfo::Timestamp
  include ::Comparable
  def add_and_set_utc_offset(seconds, utc_offset); end

  def initialize(value, sub_second=T.unsafe(nil), utc_offset=T.unsafe(nil)); end

  def new_datetime(klass=T.unsafe(nil)); end

  def new_time(klass=T.unsafe(nil)); end

  def strftime(format); end

  def sub_second(); end

  def to_datetime(); end

  def to_i(); end

  def to_time(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end

  def value(); end
end

class TZInfo::Timestamp
  def self.create(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), utc_offset=T.unsafe(nil)); end

  def self.for(value, offset=T.unsafe(nil)); end

  def self.utc(value, sub_second=T.unsafe(nil)); end
end

class TZInfo::TimestampWithOffset
  include ::TZInfo::WithOffset
  def set_timezone_offset(timezone_offset); end

  def timezone_offset(); end
end

class TZInfo::TimestampWithOffset
  def self.set_timezone_offset(timestamp, timezone_offset); end
end

class TZInfo::Timezone
  include ::Comparable
  def =~(regexp); end

  def _dump(limit); end

  def abbr(time=T.unsafe(nil)); end

  def abbreviation(time=T.unsafe(nil)); end

  def base_utc_offset(time=T.unsafe(nil)); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def dst?(time=T.unsafe(nil)); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_datetime(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), dst=T.unsafe(nil), &block); end

  def local_time(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), dst=T.unsafe(nil), &block); end

  def local_timestamp(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), dst=T.unsafe(nil), &block); end

  def local_to_utc(local_time, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def observed_utc_offset(time=T.unsafe(nil)); end

  def offsets_up_to(to, from=T.unsafe(nil)); end

  def period_for(time); end

  def period_for_local(local_time, dst=T.unsafe(nil)); end

  def period_for_utc(utc_time); end

  def periods_for_local(local_time); end

  def strftime(format, time=T.unsafe(nil)); end

  def to_local(time); end

  def transitions_up_to(to, from=T.unsafe(nil)); end

  def utc_offset(time=T.unsafe(nil)); end

  def utc_to_local(utc_time); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxy(identifier); end
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbr(); end

  def abbreviation(); end

  def base_utc_offset(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(base_utc_offset, std_offset, abbreviation); end

  def observed_utc_offset(); end

  def std_offset(); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def abbr(); end

  def abbreviation(); end

  def base_utc_offset(); end

  def dst?(); end

  def end_transition(); end

  def ends_at(); end

  def initialize(offset); end

  def local_ends_at(); end

  def local_starts_at(); end

  def observed_utc_offset(); end

  def offset(); end

  def start_transition(); end

  def starts_at(); end

  def std_offset(); end

  def utc_offset(); end

  def utc_total_offset(); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def initialize(identifier); end
end

class TZInfo::TimezoneProxy
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def eql?(tti); end

  def initialize(offset, previous_offset, timestamp_value); end

  def local_end_at(); end

  def local_start_at(); end

  def offset(); end

  def previous_offset(); end

  def timestamp_value(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TransitionRule
  def ==(r); end

  def at(offset, year); end

  def eql?(r); end

  def hash_args(); end

  def initialize(transition_at); end

  def transition_at(); end
end

class TZInfo::TransitionRule
end

class TZInfo::TransitionsTimezonePeriod
  def ==(p); end

  def eql?(p); end

  def initialize(start_transition, end_transition); end
end

class TZInfo::TransitionsTimezonePeriod
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

module TZInfo::WithOffset
  def if_timezone_offset(result=T.unsafe(nil)); end

  def strftime(format); end
end

module TZInfo::WithOffset
end

class Terminal::Table
  def <<(array); end

  def ==(other); end

  def add_row(array); end

  def add_separator(border_type: T.unsafe(nil)); end

  def align_column(n, alignment); end

  def cell_padding(); end

  def cell_spacing(); end

  def column(n, method=T.unsafe(nil), array=T.unsafe(nil)); end

  def column_width(n); end

  def column_with_headings(n, method=T.unsafe(nil)); end

  def columns(); end

  def elaborate_rows(); end

  def headings(); end

  def headings=(arrays); end

  def initialize(options=T.unsafe(nil), &block); end

  def length_of_column(n); end

  def number_of_columns(); end

  def render(); end

  def rows(); end

  def rows=(array); end

  def style(); end

  def style=(options); end

  def title(); end

  def title=(title); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::AsciiBorder
  def horizontal(_type); end

  def vertical(); end
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::AsciiBorder
end

class Terminal::Table::Border
  def [](key); end

  def []=(key, val); end

  def bottom(); end

  def bottom=(bottom); end

  def data(); end

  def data=(data); end

  def left(); end

  def left=(left); end

  def maybeleft(key); end

  def mayberight(key); end

  def remove_horizontals(); end

  def remove_verticals(); end

  def right(); end

  def right=(right); end

  def top(); end

  def top=(top); end
end

class Terminal::Table::Border
end

class Terminal::Table::Cell
  def align(val, position, length); end

  def alignment(); end

  def alignment=(val); end

  def alignment?(); end

  def colspan(); end

  def initialize(options=T.unsafe(nil)); end

  def lines(); end

  def render(line=T.unsafe(nil)); end

  def to_s(line=T.unsafe(nil)); end

  def value(); end

  def value_for_column_width_recalc(); end

  def width(); end
end

class Terminal::Table::Cell
end

class Terminal::Table::MarkdownBorder
end

class Terminal::Table::MarkdownBorder
end

class Terminal::Table::Row
  def <<(item); end

  def [](index); end

  def add_cell(item); end

  def cells(); end

  def crossings(); end

  def height(); end

  def initialize(table, array=T.unsafe(nil), **_kwargs); end

  def number_of_columns(); end

  def render(); end

  def table(); end
end

class Terminal::Table::Row
end

class Terminal::Table::Separator
  def border_type(); end

  def border_type=(border_type); end

  def implicit(); end

  def initialize(*args, border_type: T.unsafe(nil), implicit: T.unsafe(nil)); end

  def save_adjacent_rows(prevrow, nextrow); end
end

class Terminal::Table::Separator
end

class Terminal::Table::Style
  def alignment(); end

  def alignment=(alignment); end

  def all_separators(); end

  def all_separators=(all_separators); end

  def apply(options); end

  def border(); end

  def border=(val); end

  def border_bottom(); end

  def border_bottom=(val); end

  def border_i=(val); end

  def border_left(); end

  def border_left=(val); end

  def border_right(); end

  def border_right=(val); end

  def border_top(); end

  def border_top=(val); end

  def border_x=(val); end

  def border_y(); end

  def border_y=(val); end

  def border_y_width(); end

  def horizontal(*args, **arg, &block); end

  def initialize(options=T.unsafe(nil)); end

  def margin_left(); end

  def margin_left=(margin_left); end

  def on_change(attr); end

  def padding_left(); end

  def padding_left=(padding_left); end

  def padding_right(); end

  def padding_right=(padding_right); end

  def remove_horizontals(*args, **arg, &block); end

  def remove_verticals(*args, **arg, &block); end

  def vertical(*args, **arg, &block); end

  def width(); end

  def width=(width); end
end

class Terminal::Table::Style
  extend ::Forwardable
  def self.defaults(); end

  def self.defaults=(options); end
end

module Terminal::Table::TableHelper
  def table(headings=T.unsafe(nil), *rows, &block); end
end

module Terminal::Table::TableHelper
end

class Terminal::Table::UnicodeBorder
  def horizontal(type); end

  def vertical(); end
  ALLOWED_SEPARATOR_BORDER_STYLES = ::T.let(nil, ::T.untyped)
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::UnicodeBorder
end

class Terminal::Table::UnicodeRoundBorder
end

class Terminal::Table::UnicodeRoundBorder
end

class Terminal::Table::UnicodeThickEdgeBorder
end

class Terminal::Table::UnicodeThickEdgeBorder
end

module Terminal::Table::Util
end

module Terminal::Table::Util
  def self.ansi_escape(line); end
end

class Thread
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  include ::DateAndTime::Zones
  def acts_like_time?(); end

  def ago(seconds); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(arg); end

  def deconstruct_keys(arg); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(arg); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(arg); end

  def next_day(days=T.unsafe(nil)); end

  def next_month(months=T.unsafe(nil)); end

  def next_year(years=T.unsafe(nil)); end

  def plus_with_duration(other); end

  def plus_without_duration(arg); end

  def prev_day(days=T.unsafe(nil)); end

  def prev_month(months=T.unsafe(nil)); end

  def prev_year(years=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_fs(format=T.unsafe(nil)); end
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Time
  def self.===(other); end

  def self.at_with_coercion(time_or_number, *args, **arg); end

  def self.at_without_coercion(time, subsec=T.unsafe(nil), unit=T.unsafe(nil), in: T.unsafe(nil)); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.days_in_year(year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.rfc3339(str); end

  def self.use_zone(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Timeout::Error
  def self.handle_timeout(message); end
end

class Timeout::ExitException
  def exception(*arg); end
end

class Timeout::ExitException
end

module Timeout
  def self.ensure_timeout_thread_created(); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module TypeProf
  VERSION = ::T.let(nil, ::T.untyped)
end

class TypeProf::CodePosition
  include ::Comparable
  def ==(other); end

  def column(); end

  def eql?(other); end

  def initialize(lineno, column); end

  def left(); end

  def lineno(); end

  def right(); end

  def to_lsp(); end
end

class TypeProf::CodePosition
  def self.from_lsp(pos); end
end

class TypeProf::CodeRange
  def ==(other); end

  def eql?(other); end

  def first(); end

  def include?(pos); end

  def initialize(first, last); end

  def last(); end

  def to_lsp(); end
end

class TypeProf::CodeRange
  def self.[](a, b, c, d); end

  def self.from_node(node, encoding=T.unsafe(nil)); end
end

module TypeProf::Core
end

class TypeProf::Core::AST
end

class TypeProf::Core::AST::AliasGlobalVariableNode
  def install0(genv); end
end

class TypeProf::Core::AST::AliasGlobalVariableNode
end

class TypeProf::Core::AST::AliasNode
  def install0(genv); end

  def new_mid(); end

  def old_mid(); end
end

class TypeProf::Core::AST::AliasNode
end

class TypeProf::Core::AST::AltPatternNode
  def install0(genv); end

  def left(); end

  def right(); end
end

class TypeProf::Core::AST::AltPatternNode
end

class TypeProf::Core::AST::AndNode
  def e1(); end

  def e2(); end

  def initialize(raw_node, e1=T.unsafe(nil), raw_e2=T.unsafe(nil), lenv); end

  def install0(genv); end
end

class TypeProf::Core::AST::AndNode
end

class TypeProf::Core::AST::ArrayNode
  def elems(); end

  def initialize(raw_node, lenv, elems=T.unsafe(nil)); end

  def install0(genv); end

  def splat(); end
end

class TypeProf::Core::AST::ArrayNode
end

class TypeProf::Core::AST::ArrayPatternNode
  def install0(genv); end

  def posts(); end

  def requireds(); end

  def rest(); end

  def rest_pattern(); end
end

class TypeProf::Core::AST::ArrayPatternNode
end

class TypeProf::Core::AST::AttrAccessorMetaNode
  def args(); end

  def install0(genv); end

  def mname_code_range(name); end
end

class TypeProf::Core::AST::AttrAccessorMetaNode
end

class TypeProf::Core::AST::AttrReaderMetaNode
  def args(); end

  def install0(genv); end

  def mname_code_range(name); end

  def opt_keywords(); end

  def opt_positionals(); end

  def post_positionals(); end

  def req_keywords(); end

  def req_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end
end

class TypeProf::Core::AST::AttrReaderMetaNode
end

class TypeProf::Core::AST::BeginNode
  def body(); end

  def else_clause(); end

  def ensure_clause(); end

  def install0(genv); end

  def rescue_clauses(); end

  def rescue_conds(); end
end

class TypeProf::Core::AST::BeginNode
end

class TypeProf::Core::AST::BranchNode
  def cond(); end

  def else(); end

  def install0(genv); end
end

class TypeProf::Core::AST::BranchNode
end

class TypeProf::Core::AST::BreakNode
  def arg(); end

  def install0(genv); end
end

class TypeProf::Core::AST::BreakNode
end

class TypeProf::Core::AST::CallBaseNode
  def block_body(); end

  def block_f_args(); end

  def block_last_stmt_code_range(); end

  def block_pass(); end

  def block_tbl(); end

  def initialize(raw_node, recv, mid, mid_code_range, raw_args, last_arg, raw_block, lenv); end

  def install0(genv); end

  def keyword_args(); end

  def mid(); end

  def mid_code_range(); end

  def positional_args(); end

  def recv(); end

  def splat_flags(); end

  def yield(); end
end

class TypeProf::Core::AST::CallBaseNode
end

class TypeProf::Core::AST::CallNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::CallNode
end

class TypeProf::Core::AST::CallReadNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::CallReadNode
end

class TypeProf::Core::AST::CallWriteNode
  def initialize(raw_node, rhs, lenv); end

  def rhs(); end
end

class TypeProf::Core::AST::CallWriteNode
end

class TypeProf::Core::AST::CapturePatternNode
  def install0(genv); end

  def target(); end

  def value(); end
end

class TypeProf::Core::AST::CapturePatternNode
end

class TypeProf::Core::AST::CaseMatchNode
  def clauses(); end

  def else_clause(); end

  def install0(genv); end

  def patterns(); end

  def pivot(); end
end

class TypeProf::Core::AST::CaseMatchNode
end

class TypeProf::Core::AST::CaseNode
  def clauses(); end

  def else_clause(); end

  def install0(genv); end

  def pivot(); end

  def whens(); end
end

class TypeProf::Core::AST::CaseNode
end

class TypeProf::Core::AST::ClassNode
  def initialize(raw_node, lenv, use_result); end

  def superclass_cpath(); end
end

class TypeProf::Core::AST::ClassNode
end

class TypeProf::Core::AST::ClassVariableReadNode
  def install0(genv); end

  def retrieve_at(pos); end

  def var(); end
end

class TypeProf::Core::AST::ClassVariableReadNode
end

class TypeProf::Core::AST::ClassVariableWriteNode
  def initialize(raw_node, rhs, lenv); end

  def install0(genv); end

  def rhs(); end

  def var(); end

  def var_code_range(); end
end

class TypeProf::Core::AST::ClassVariableWriteNode
end

class TypeProf::Core::AST::ComplexNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::ComplexNode
end

class TypeProf::Core::AST::ConstantReadNode
  def cbase(); end

  def cname(); end

  def cname_code_range(); end

  def install0(genv); end

  def toplevel(); end
end

class TypeProf::Core::AST::ConstantReadNode
end

class TypeProf::Core::AST::ConstantWriteNode
  def cname_code_range(); end

  def cpath(); end

  def initialize(raw_node, rhs, lenv); end

  def install0(genv); end

  def rhs(); end

  def static_cpath(); end
end

class TypeProf::Core::AST::ConstantWriteNode
end

class TypeProf::Core::AST::DefNode
  def block(); end

  def body(); end

  def initialize(raw_node, lenv, use_result); end

  def install0(genv); end

  def last_stmt_code_range(); end

  def mid(); end

  def mid_code_range(); end

  def mname_code_range(_name); end

  def opt_keyword_defaults(); end

  def opt_keywords(); end

  def opt_positional_defaults(); end

  def opt_positionals(); end

  def post_positionals(); end

  def rbs_method_type(); end

  def req_keywords(); end

  def req_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end

  def reusable(); end

  def singleton(); end

  def tbl(); end
end

class TypeProf::Core::AST::DefNode
end

class TypeProf::Core::AST::DefinedNode
  def arg(); end

  def install0(genv); end
end

class TypeProf::Core::AST::DefinedNode
end

class TypeProf::Core::AST::DummyNilNode
  def initialize(code_range, lenv); end

  def install0(genv); end
end

class TypeProf::Core::AST::DummyNilNode
end

class TypeProf::Core::AST::DummyRHSNode
  def initialize(code_range, lenv); end
end

class TypeProf::Core::AST::DummyRHSNode
end

class TypeProf::Core::AST::DummySymbolNode
  def boxes(_); end

  def initialize(sym, code_range, ret); end

  def lenv(); end

  def prev_node(); end

  def ret(); end
end

class TypeProf::Core::AST::DummySymbolNode
end

class TypeProf::Core::AST::FalseNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::FalseNode
end

class TypeProf::Core::AST::FindPatternNode
  def install0(genv); end

  def left(); end

  def requireds(); end

  def right(); end
end

class TypeProf::Core::AST::FindPatternNode
end

class TypeProf::Core::AST::FlipFlopNode
  def e1(); end

  def e2(); end

  def install0(genv); end
end

class TypeProf::Core::AST::FlipFlopNode
end

class TypeProf::Core::AST::FloatNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::FloatNode
end

class TypeProf::Core::AST::ForNode
  def body(); end

  def expr(); end

  def install0(genv); end
end

class TypeProf::Core::AST::ForNode
end

class TypeProf::Core::AST::ForwardingSuperNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::ForwardingSuperNode
end

class TypeProf::Core::AST::GlobalVariableReadNode
  def install0(genv); end

  def retrieve_at(pos); end

  def var(); end
end

class TypeProf::Core::AST::GlobalVariableReadNode
end

class TypeProf::Core::AST::GlobalVariableWriteNode
  def initialize(raw_node, rhs, lenv); end

  def install0(genv); end

  def rhs(); end

  def var(); end

  def var_code_range(); end
end

class TypeProf::Core::AST::GlobalVariableWriteNode
end

class TypeProf::Core::AST::HashNode
  def initialize(raw_node, lenv, keywords); end

  def install0(genv); end

  def keys(); end

  def keywords(); end

  def splat(); end

  def vals(); end
end

class TypeProf::Core::AST::HashNode
end

class TypeProf::Core::AST::HashPatternNode
  def install0(genv); end

  def keys(); end

  def rest(); end

  def rest_pattern(); end

  def values(); end
end

class TypeProf::Core::AST::HashPatternNode
end

class TypeProf::Core::AST::IfNode
end

class TypeProf::Core::AST::IfNode
end

class TypeProf::Core::AST::IfPatternNode
  def body(); end

  def cond(); end

  def install0(genv); end
end

class TypeProf::Core::AST::IfPatternNode
end

class TypeProf::Core::AST::IncludeMetaNode
  def args(); end

  def install0(genv); end
end

class TypeProf::Core::AST::IncludeMetaNode
end

class TypeProf::Core::AST::IndexReadNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::IndexReadNode
end

class TypeProf::Core::AST::IndexWriteNode
  def initialize(raw_node, rhs, lenv); end

  def rhs(); end
end

class TypeProf::Core::AST::IndexWriteNode
end

class TypeProf::Core::AST::InstanceVariableReadNode
  def install0(genv); end

  def retrieve_at(pos); end

  def var(); end
end

class TypeProf::Core::AST::InstanceVariableReadNode
end

class TypeProf::Core::AST::InstanceVariableWriteNode
  def initialize(raw_node, rhs, lenv); end

  def install0(genv); end

  def rhs(); end

  def var(); end

  def var_code_range(); end
end

class TypeProf::Core::AST::InstanceVariableWriteNode
end

class TypeProf::Core::AST::IntegerNode
  def initialize(raw_node, lenv, lit=T.unsafe(nil)); end
end

class TypeProf::Core::AST::IntegerNode
end

class TypeProf::Core::AST::InterpolatedMatchLastLineNode
  def install0(genv); end

  def parts(); end
end

class TypeProf::Core::AST::InterpolatedMatchLastLineNode
end

class TypeProf::Core::AST::InterpolatedRegexpNode
  def install0(genv); end

  def parts(); end
end

class TypeProf::Core::AST::InterpolatedRegexpNode
end

class TypeProf::Core::AST::InterpolatedStringNode
  def install0(genv); end

  def parts(); end
end

class TypeProf::Core::AST::InterpolatedStringNode
end

class TypeProf::Core::AST::InterpolatedSymbolNode
  def install0(genv); end

  def parts(); end
end

class TypeProf::Core::AST::InterpolatedSymbolNode
end

class TypeProf::Core::AST::LambdaNode
  def install0(genv); end
end

class TypeProf::Core::AST::LambdaNode
end

class TypeProf::Core::AST::LiteralNode
  def initialize(raw_node, lenv, lit); end

  def install0(genv); end

  def lit(); end
end

class TypeProf::Core::AST::LiteralNode
end

class TypeProf::Core::AST::LocalVariableReadNode
  def install0(genv); end

  def retrieve_at(pos); end

  def var(); end
end

class TypeProf::Core::AST::LocalVariableReadNode
end

class TypeProf::Core::AST::LocalVariableWriteNode
  def initialize(raw_node, rhs, lenv); end

  def install0(genv); end

  def rhs(); end

  def var(); end

  def var_code_range(); end
end

class TypeProf::Core::AST::LocalVariableWriteNode
end

class TypeProf::Core::AST::LoopNode
  def body(); end

  def cond(); end

  def install0(genv); end
end

class TypeProf::Core::AST::LoopNode
end

class TypeProf::Core::AST::MatchLastLineNode
  def install0(genv); end
end

class TypeProf::Core::AST::MatchLastLineNode
end

class TypeProf::Core::AST::MatchPreidcateNode
  def install0(genv); end

  def pat(); end

  def value(); end
end

class TypeProf::Core::AST::MatchPreidcateNode
end

class TypeProf::Core::AST::MatchRequiredNode
  def install0(genv); end

  def pat(); end

  def value(); end
end

class TypeProf::Core::AST::MatchRequiredNode
end

class TypeProf::Core::AST::MatchWriteNode
  def call(); end

  def install0(genv); end

  def targets(); end
end

class TypeProf::Core::AST::MatchWriteNode
end

class TypeProf::Core::AST::ModuleBaseNode
  def body(); end

  def cname_code_range(); end

  def cpath(); end

  def initialize(raw_node, lenv, raw_cpath, meta, raw_scope, use_result); end

  def install0(genv); end

  def static_cpath(); end

  def tbl(); end
end

class TypeProf::Core::AST::ModuleBaseNode
end

class TypeProf::Core::AST::ModuleNode
  def initialize(raw_node, lenv, use_result); end
end

class TypeProf::Core::AST::ModuleNode
end

class TypeProf::Core::AST::MultiWriteNode
  def install0(genv); end

  def lefts(); end

  def rest(); end

  def rest_exist(); end

  def rights(); end

  def value(); end
end

class TypeProf::Core::AST::MultiWriteNode
end

class TypeProf::Core::AST::NextNode
  def arg(); end

  def install0(genv); end
end

class TypeProf::Core::AST::NextNode
end

class TypeProf::Core::AST::NilNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::NilNode
end

class TypeProf::Core::AST::Node
  def attrs(); end

  def boxes(key); end

  def changes(); end

  def code_range(); end

  def define(genv); end

  def define0(genv); end

  def define_copy(genv); end

  def diagnostics(genv, &blk); end

  def diff(prev_node); end

  def each_subnode(); end

  def get_vertexes(vtxs); end

  def initialize(raw_node, lenv); end

  def install(genv); end

  def install0(_); end

  def install_copy(genv); end

  def lenv(); end

  def modified_vars(tbl, vars); end

  def prev_node(); end

  def ret(); end

  def retrieve_at(pos, &blk); end

  def static_ret(); end

  def subnodes(); end

  def traverse(&blk); end

  def undefine(genv); end

  def undefine0(genv); end

  def uninstall(genv); end
end

class TypeProf::Core::AST::Node
end

class TypeProf::Core::AST::OperatorNode
  def initialize(raw_node, recv, lenv); end
end

class TypeProf::Core::AST::OperatorNode
end

class TypeProf::Core::AST::OrNode
  def e1(); end

  def e2(); end

  def initialize(raw_node, e1=T.unsafe(nil), raw_e2=T.unsafe(nil), lenv); end

  def install0(genv); end
end

class TypeProf::Core::AST::OrNode
end

class TypeProf::Core::AST::PinnedPatternNode
  def expr(); end

  def install0(genv); end
end

class TypeProf::Core::AST::PinnedPatternNode
end

class TypeProf::Core::AST::PostExecutionNode
  def body(); end

  def install0(genv); end
end

class TypeProf::Core::AST::PostExecutionNode
end

class TypeProf::Core::AST::ProgramNode
  def body(); end

  def install0(genv); end

  def tbl(); end
end

class TypeProf::Core::AST::ProgramNode
end

class TypeProf::Core::AST::RangeNode
  def begin(); end

  def end(); end

  def install0(genv); end
end

class TypeProf::Core::AST::RangeNode
end

class TypeProf::Core::AST::RationalNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::RationalNode
end

class TypeProf::Core::AST::RedoNode
  def install0(genv); end
end

class TypeProf::Core::AST::RedoNode
end

class TypeProf::Core::AST::RegexpNode
  def install0(genv); end
end

class TypeProf::Core::AST::RegexpNode
end

class TypeProf::Core::AST::RegexpReferenceReadNode
  def install0(genv); end

  def var(); end
end

class TypeProf::Core::AST::RegexpReferenceReadNode
end

class TypeProf::Core::AST::RescueModifierNode
  def expression(); end

  def install0(genv); end

  def rescue_expression(); end
end

class TypeProf::Core::AST::RescueModifierNode
end

class TypeProf::Core::AST::RetryNode
  def install0(genv); end
end

class TypeProf::Core::AST::RetryNode
end

class TypeProf::Core::AST::ReturnNode
  def arg(); end

  def install0(genv); end
end

class TypeProf::Core::AST::ReturnNode
end

class TypeProf::Core::AST::SelfNode
  def install0(genv); end
end

class TypeProf::Core::AST::SelfNode
end

class TypeProf::Core::AST::SigAliasNode
  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def instance(); end

  def new_mid(); end

  def old_mid(); end

  def singleton(); end
end

class TypeProf::Core::AST::SigAliasNode
end

class TypeProf::Core::AST::SigAttrAccessorNode
  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def reader(); end

  def writer(); end
end

class TypeProf::Core::AST::SigAttrAccessorNode
end

class TypeProf::Core::AST::SigAttrReaderNode
  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def method_type(); end

  def mid(); end
end

class TypeProf::Core::AST::SigAttrReaderNode
end

class TypeProf::Core::AST::SigAttrWriterNode
  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def method_type(); end

  def mid(); end
end

class TypeProf::Core::AST::SigAttrWriterNode
end

class TypeProf::Core::AST::SigClassNode
  def superclass_args(); end

  def superclass_cpath(); end

  def superclass_toplevel(); end
end

class TypeProf::Core::AST::SigClassNode
end

class TypeProf::Core::AST::SigConstNode
  def cpath(); end

  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def type(); end
end

class TypeProf::Core::AST::SigConstNode
end

class TypeProf::Core::AST::SigDefNode
  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def instance(); end

  def method_types(); end

  def mid(); end

  def overloading(); end

  def singleton(); end
end

class TypeProf::Core::AST::SigDefNode
end

class TypeProf::Core::AST::SigFuncType
  def block(); end

  def block_required(); end

  def initialize(raw_decl, raw_type_params, raw_block, lenv); end

  def opt_keywords(); end

  def opt_positionals(); end

  def post_positionals(); end

  def req_keywords(); end

  def req_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end

  def return_type(); end

  def type_params(); end
end

class TypeProf::Core::AST::SigFuncType
end

class TypeProf::Core::AST::SigGlobalVariableNode
  def cpath(); end

  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def type(); end
end

class TypeProf::Core::AST::SigGlobalVariableNode
end

class TypeProf::Core::AST::SigIncludeNode
  def args(); end

  def cpath(); end

  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def toplevel(); end
end

class TypeProf::Core::AST::SigIncludeNode
end

class TypeProf::Core::AST::SigInterfaceNode
end

class TypeProf::Core::AST::SigInterfaceNode
end

class TypeProf::Core::AST::SigModuleBaseNode
  def cpath(); end

  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def members(); end

  def params(); end
end

class TypeProf::Core::AST::SigModuleBaseNode
end

class TypeProf::Core::AST::SigModuleNode
  def self_type_args(); end

  def self_types(); end
end

class TypeProf::Core::AST::SigModuleNode
end

class TypeProf::Core::AST::SigTyAliasNode
  def args(); end

  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def cpath(); end

  def initialize(raw_decl, lenv); end

  def name(); end

  def show(); end

  def toplevel(); end
end

class TypeProf::Core::AST::SigTyAliasNode
end

class TypeProf::Core::AST::SigTyBaseAnyNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseAnyNode
end

class TypeProf::Core::AST::SigTyBaseBoolNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseBoolNode
end

class TypeProf::Core::AST::SigTyBaseBottomNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseBottomNode
end

class TypeProf::Core::AST::SigTyBaseClassNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseClassNode
end

class TypeProf::Core::AST::SigTyBaseInstanceNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseInstanceNode
end

class TypeProf::Core::AST::SigTyBaseNilNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseNilNode
end

class TypeProf::Core::AST::SigTyBaseSelfNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseSelfNode
end

class TypeProf::Core::AST::SigTyBaseTopNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseTopNode
end

class TypeProf::Core::AST::SigTyBaseVoidNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyBaseVoidNode
end

class TypeProf::Core::AST::SigTyInstanceNode
  def args(); end

  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def cpath(); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def toplevel(); end
end

class TypeProf::Core::AST::SigTyInstanceNode
end

class TypeProf::Core::AST::SigTyInterfaceNode
  def args(); end

  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def cpath(); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def toplevel(); end
end

class TypeProf::Core::AST::SigTyInterfaceNode
end

class TypeProf::Core::AST::SigTyIntersectionNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyIntersectionNode
end

class TypeProf::Core::AST::SigTyLiteralNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def get_type(genv); end

  def initialize(raw_decl, lenv); end

  def lit(); end

  def show(); end
end

class TypeProf::Core::AST::SigTyLiteralNode
end

class TypeProf::Core::AST::SigTyNode
  def contravariant_vertex(genv, changes, subst); end

  def covariant_vertex(genv, changes, subst); end
end

class TypeProf::Core::AST::SigTyNode
end

class TypeProf::Core::AST::SigTyOptionalNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def type(); end
end

class TypeProf::Core::AST::SigTyOptionalNode
end

class TypeProf::Core::AST::SigTyProcNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyProcNode
end

class TypeProf::Core::AST::SigTyRecordNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def show(); end
end

class TypeProf::Core::AST::SigTyRecordNode
end

class TypeProf::Core::AST::SigTySingletonNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def cpath(); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def toplevel(); end
end

class TypeProf::Core::AST::SigTySingletonNode
end

class TypeProf::Core::AST::SigTyTupleNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def types(); end
end

class TypeProf::Core::AST::SigTyTupleNode
end

class TypeProf::Core::AST::SigTyUnionNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def types(); end
end

class TypeProf::Core::AST::SigTyUnionNode
end

class TypeProf::Core::AST::SigTyVarNode
  def contravariant_vertex0(genv, changes, vtx, subst); end

  def covariant_vertex0(genv, changes, vtx, subst); end

  def initialize(raw_decl, lenv); end

  def show(); end

  def var(); end
end

class TypeProf::Core::AST::SigTyVarNode
end

class TypeProf::Core::AST::SigTypeAliasNode
  def cpath(); end

  def initialize(raw_decl, lenv); end

  def install0(genv); end

  def name(); end

  def params(); end

  def type(); end
end

class TypeProf::Core::AST::SigTypeAliasNode
end

class TypeProf::Core::AST::SingletonClassNode
  def initialize(raw_node, lenv, use_result); end
end

class TypeProf::Core::AST::SingletonClassNode
end

class TypeProf::Core::AST::SourceEncodingNode
  def install0(genv); end
end

class TypeProf::Core::AST::SourceEncodingNode
end

class TypeProf::Core::AST::SplatNode
  def expr(); end

  def install0(genv); end

  def mid_code_range(); end
end

class TypeProf::Core::AST::SplatNode
end

class TypeProf::Core::AST::StatementsNode
  def initialize(raw_node, lenv, use_result); end

  def install0(genv); end

  def stmts(); end
end

class TypeProf::Core::AST::StatementsNode
end

class TypeProf::Core::AST::StringNode
  def initialize(raw_node, lenv, content); end
end

class TypeProf::Core::AST::StringNode
end

class TypeProf::Core::AST::SuperNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::SuperNode
end

class TypeProf::Core::AST::SymbolNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::SymbolNode
end

class TypeProf::Core::AST::TrueNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::TrueNode
end

class TypeProf::Core::AST::UndefNode
  def install0(genv); end

  def names(); end
end

class TypeProf::Core::AST::UndefNode
end

class TypeProf::Core::AST::UnlessNode
end

class TypeProf::Core::AST::UnlessNode
end

class TypeProf::Core::AST::UntilNode
end

class TypeProf::Core::AST::UntilNode
end

class TypeProf::Core::AST::WhileNode
end

class TypeProf::Core::AST::WhileNode
end

class TypeProf::Core::AST::YieldNode
  def initialize(raw_node, lenv); end
end

class TypeProf::Core::AST::YieldNode
end

class TypeProf::Core::AST
  def self.create_node(raw_node, lenv, use_result=T.unsafe(nil)); end

  def self.create_part_node(raw_part, lenv); end

  def self.create_pattern_node(raw_node, lenv); end

  def self.create_rbs_decl(raw_decl, lenv); end

  def self.create_rbs_func_type(raw_decl, raw_type_params, raw_block, lenv); end

  def self.create_rbs_member(raw_decl, lenv); end

  def self.create_rbs_type(raw_decl, lenv); end

  def self.create_target_node(raw_node, lenv); end

  def self.get_rbs_comment_before(raw_node, lenv); end

  def self.is_a_class(node); end

  def self.parse_cpath(raw_node, cref); end

  def self.parse_params(tbl, raw_args, lenv); end

  def self.parse_rb(path, src); end

  def self.parse_rbs(path, src); end

  def self.parse_return_arguments(raw_node, lenv, code_range); end

  def self.resolve_rbs_name(name, lenv); end
end

class TypeProf::Core::ActualArguments
  def block(); end

  def get_keyword_arg(genv, changes, name); end

  def get_rest_args(genv, start_rest, end_rest); end

  def initialize(positionals, splat_flags, keywords, block); end

  def keywords(); end

  def new_vertexes(genv, node); end

  def positionals(); end

  def splat_flags(); end
end

class TypeProf::Core::ActualArguments
end

class TypeProf::Core::BaseConstRead
  include ::TypeProf::Core::ConstRead
end

class TypeProf::Core::BaseConstRead
end

class TypeProf::Core::BaseStaticRead
  def cref(); end

  def initialize(genv, name, cref); end

  def on_scope_updated(genv); end
end

class TypeProf::Core::BaseStaticRead
end

class TypeProf::Core::BaseTypeAliasRead
  include ::TypeProf::Core::TypeAliasRead
end

class TypeProf::Core::BaseTypeAliasRead
end

class TypeProf::Core::BasicVertex
  def check_match(genv, changes, vtx); end

  def each_type(&blk); end

  def initialize(types); end

  def show(); end

  def types(); end
end

class TypeProf::Core::BasicVertex
end

class TypeProf::Core::Block
  def accept_args(genv, changes, caller_positionals, caller_ret, ret_check); end

  def f_args(); end

  def initialize(node, f_ary_arg, f_args, next_boxes); end

  def node(); end

  def ret(); end
end

class TypeProf::Core::Block
end

class TypeProf::Core::BotFilter
  def base_vtx(); end

  def filter(types); end

  def initialize(genv, node, prev_vtx, base_vtx); end

  def next_vtx(); end

  def on_type_added(genv, src_var, added_types); end

  def on_type_removed(genv, src_var, removed_types); end

  def prev_vtx(); end

  def types(); end
end

class TypeProf::Core::BotFilter
end

class TypeProf::Core::Box
  def changes(); end

  def destroy(genv); end

  def destroyed(); end

  def diagnostics(genv, &blk); end

  def initialize(node); end

  def node(); end

  def on_type_added(genv, src_tyvar, added_types); end

  def on_type_removed(genv, src_tyvar, removed_types); end

  def reuse(new_node); end

  def run(genv); end
end

class TypeProf::Core::Box
end

class TypeProf::Core::Builtin
  def array_aref(changes, node, ty, a_args, ret); end

  def array_aset(changes, node, ty, a_args, ret); end

  def array_push(changes, node, ty, a_args, ret); end

  def class_new(changes, node, ty, a_args, ret); end

  def deploy(); end

  def hash_aref(changes, node, ty, a_args, ret); end

  def hash_aset(changes, node, ty, a_args, ret); end

  def initialize(genv); end

  def object_class(changes, node, ty, a_args, ret); end

  def proc_call(changes, node, ty, a_args, ret); end
end

class TypeProf::Core::Builtin
end

class TypeProf::Core::CRef
  def cpath(); end

  def get_self(genv); end

  def initialize(cpath, scope_level, mid, outer); end

  def mid(); end

  def outer(); end

  def scope_level(); end
  Toplevel = ::T.let(nil, ::T.untyped)
end

class TypeProf::Core::CRef
end

class TypeProf::Core::CVarReadBox
  def const_read(); end

  def initialize(node, genv, cpath, name); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::CVarReadBox
end

class TypeProf::Core::ChangeSet
  def add_const_read_box(genv, static_ret); end

  def add_cvar_read_box(genv, cpath, name); end

  def add_depended_method_entity(me); end

  def add_depended_static_read(static_read); end

  def add_depended_superclass(mod); end

  def add_depended_value_entity(ve); end

  def add_diagnostic(meth, msg); end

  def add_edge(genv, src, dst); end

  def add_escape_box(genv, a_ret, f_ret); end

  def add_gvar_read_box(genv, var); end

  def add_hash_splat_box(genv, arg, unified_key, unified_val); end

  def add_ivar_read_box(genv, cpath, singleton, name); end

  def add_masgn_box(genv, value, lefts, rest_elem, rights); end

  def add_method_alias_box(genv, cpath, singleton, new_mid, old_mid); end

  def add_method_call_box(genv, recv, mid, a_args, subclasses); end

  def add_method_decl_box(genv, cpath, singleton, mid, method_types, overloading); end

  def add_method_def_box(genv, cpath, singleton, mid, f_args, ret_boxes); end

  def add_splat_box(genv, arg); end

  def add_type_read_box(genv, type); end

  def boxes(); end

  def copy_from(other); end

  def covariant_types(); end

  def diagnostics(); end

  def edges(); end

  def initialize(node, target); end

  def new_contravariant_vertex(genv, sig_type_node); end

  def new_covariant_vertex(genv, sig_type_node); end

  def node(); end

  def reinstall(genv); end

  def reuse(new_node); end
end

class TypeProf::Core::ChangeSet
end

module TypeProf::Core::ConstRead
  def cdef(); end

  def check_module(genv, mod); end

  def cpath(); end

  def resolution_failed(genv); end

  def update_module(genv, cpath, cdef); end
end

module TypeProf::Core::ConstRead
end

class TypeProf::Core::ConstReadBox
  def const_read(); end

  def initialize(node, genv, const_read); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::ConstReadBox
end

class TypeProf::Core::EscapeBox
  def a_ret(); end

  def f_ret(); end

  def initialize(node, genv, a_ret, f_ret); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::EscapeBox
end

class TypeProf::Core::Filter
  def destroyed(); end
end

class TypeProf::Core::Filter
end

class TypeProf::Core::FormalArguments
  def block(); end

  def initialize(req_positionals, opt_positionals, rest_positionals, post_positionals, req_keywords, opt_keywords, rest_keywords, block); end

  def opt_keywords(); end

  def opt_positionals(); end

  def post_positionals(); end

  def req_keywords(); end

  def req_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end
  Empty = ::T.let(nil, ::T.untyped)
end

class TypeProf::Core::FormalArguments
end

class TypeProf::Core::GVarReadBox
  def const_read(); end

  def initialize(node, genv, name); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::GVarReadBox
end

class TypeProf::Core::GlobalEnv
  def add_run(obj); end

  def add_static_eval_queue(change_type, arg); end

  def cls_type(); end

  def complex_type(); end

  def define_all(); end

  def each_direct_superclass(mod, singleton); end

  def each_included_module(mod, &blk); end

  def each_superclass(mod, singleton, &blk); end

  def false_type(); end

  def float_type(); end

  def gen_ary_type(elem_vtx); end

  def gen_hash_type(key_vtx, val_vtx); end

  def gen_range_type(elem_vtx); end

  def get_instance_type(mod, type_args, changes, base_ty_env, base_ty); end

  def get_superclass(singleton, mod); end

  def get_superclass_type(ty, changes, base_ty_env); end

  def get_vertexes(vtxs); end

  def int_type(); end

  def load_core_rbs(raw_decls); end

  def mod_ary(); end

  def mod_class(); end

  def mod_hash(); end

  def mod_object(); end

  def mod_range(); end

  def mod_str(); end

  def mod_type(); end

  def nil_type(); end

  def obj_type(); end

  def proc_type(); end

  def rational_type(); end

  def regexp_type(); end

  def resolve_const(cpath); end

  def resolve_cpath(cpath); end

  def resolve_cvar(cpath, name); end

  def resolve_gvar(name); end

  def resolve_ivar(cpath, singleton, name); end

  def resolve_method(cpath, singleton, mid); end

  def resolve_type_alias(cpath, name); end

  def run_all(); end

  def run_count(); end

  def run_count=(run_count); end

  def set_type(); end

  def str_type(); end

  def symbol_type(); end

  def true_type(); end

  def type_table(); end
end

class TypeProf::Core::GlobalEnv
end

class TypeProf::Core::HashSplatBox
  def hsh(); end

  def initialize(node, genv, hsh, unified_key, unified_val); end

  def ret(); end

  def run0(genv, changes); end

  def unified_key(); end

  def unified_val(); end
end

class TypeProf::Core::HashSplatBox
end

class TypeProf::Core::IVarReadBox
  def const_read(); end

  def initialize(node, genv, cpath, singleton, name); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::IVarReadBox
end

class TypeProf::Core::IsAFilter
  def initialize(genv, node, prev_vtx, neg, const_read); end

  def next_vtx(); end

  def on_type_added(genv, src_var, added_types); end

  def on_type_removed(genv, src_var, removed_types); end

  def run(genv); end
end

class TypeProf::Core::IsAFilter
end

class TypeProf::Core::LocalEnv
  def add_next_box(box); end

  def add_return_box(box); end

  def apply_read_filter(genv, node, name, vtx); end

  def break_vtx(); end

  def cref(); end

  def exist_var?(name); end

  def get_break_vtx(); end

  def get_var(name); end

  def initialize(path, cref, locals, return_boxes); end

  def locals(); end

  def new_var(name, node); end

  def next_boxes(); end

  def path(); end

  def pop_read_filter(name); end

  def push_read_filter(name, type); end

  def return_boxes(); end

  def set_var(name, vtx); end
end

class TypeProf::Core::LocalEnv
end

class TypeProf::Core::MAsgnBox
  def initialize(node, genv, value, lefts, rest_elem, rights); end

  def lefts(); end

  def rest_elem(); end

  def ret(); end

  def rights(); end

  def run0(genv, changes); end

  def value(); end
end

class TypeProf::Core::MAsgnBox
end

class TypeProf::Core::MethodAliasBox
  def cpath(); end

  def initialize(node, genv, cpath, singleton, new_mid, old_mid); end

  def new_mid(); end

  def node=(node); end

  def old_mid(); end

  def ret(); end

  def run0(genv, changes); end

  def singleton(); end
end

class TypeProf::Core::MethodAliasBox
end

class TypeProf::Core::MethodCallBox
  def initialize(node, genv, recv, mid, a_args, subclasses); end

  def mid(); end

  def recv(); end

  def resolve(genv, changes, &blk); end

  def resolve_included_modules(genv, changes, base_ty_env, ty, mid, &blk); end

  def resolve_subclasses(genv, changes); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::MethodCallBox
end

class TypeProf::Core::MethodDeclBox
  def cpath(); end

  def initialize(node, genv, cpath, singleton, mid, method_types, overloading); end

  def match_arguments?(genv, changes, param_map, a_args, method_type); end

  def method_types(); end

  def mid(); end

  def node=(node); end

  def overloading(); end

  def resolve_overloads(changes, genv, node, param_map, a_args, ret); end

  def ret(); end

  def show(); end

  def singleton(); end
end

class TypeProf::Core::MethodDeclBox
end

class TypeProf::Core::MethodDefBox
  def call(changes, genv, a_args, ret); end

  def cpath(); end

  def f_args(); end

  def initialize(node, genv, cpath, singleton, mid, f_args, ret_boxes); end

  def mid(); end

  def node=(node); end

  def pass_arguments(changes, genv, a_args); end

  def ret(); end

  def run0(genv, changes); end

  def show(output_parameter_names); end

  def singleton(); end
end

class TypeProf::Core::MethodDefBox
end

class TypeProf::Core::MethodEntity
  def add_alias(node, old_mid); end

  def add_decl(decl); end

  def add_def(mdef); end

  def add_run_all_mdefs(genv); end

  def add_run_all_method_call_boxes(genv); end

  def aliases(); end

  def builtin(); end

  def builtin=(builtin); end

  def decls(); end

  def defs(); end

  def exist?(); end

  def method_call_boxes(); end

  def remove_alias(node); end

  def remove_decl(decl); end

  def remove_def(mdef); end
end

class TypeProf::Core::MethodEntity
end

class TypeProf::Core::ModuleEntity
  def add_include_decl(genv, node); end

  def add_include_def(genv, node); end

  def add_module_decl(genv, decl); end

  def add_module_def(genv, node); end

  def child_modules(); end

  def consts(); end

  def cpath(); end

  def cvar_reads(); end

  def cvars(); end

  def each_descendant(base_mod=T.unsafe(nil), &blk); end

  def exist?(); end

  def find_superclass_const_read(); end

  def get_cname(); end

  def get_const(cname); end

  def get_cvar(name); end

  def get_ivar(singleton, name); end

  def get_method(singleton, mid); end

  def get_type_alias(name); end

  def get_vertexes(vtxs); end

  def included_modules(); end

  def initialize(cpath, outer_module=T.unsafe(nil)); end

  def inner_modules(); end

  def interface?(); end

  def ivar_reads(); end

  def ivars(); end

  def methods(); end

  def module?(); end

  def module_decls(); end

  def module_defs(); end

  def on_ancestors_updated(genv, base_mod); end

  def on_inner_modules_changed(genv, changed_cname); end

  def on_module_added(genv); end

  def on_module_removed(genv); end

  def on_parent_modules_changed(genv); end

  def outer_module(); end

  def remove_include_decl(genv, node); end

  def remove_include_def(genv, node); end

  def remove_module_decl(genv, decl); end

  def remove_module_def(genv, node); end

  def self_types(); end

  def show_cpath(); end

  def static_reads(); end

  def subclass_checks(); end

  def superclass(); end

  def superclass_type_args(); end

  def type_aliases(); end

  def type_params(); end

  def update_parent(genv, origin, old_parent, new_parent_cpath); end

  def update_type_params(); end
end

class TypeProf::Core::ModuleEntity
end

class TypeProf::Core::NilFilter
  def allow_nil(); end

  def filter(types, nil_type); end

  def initialize(genv, node, prev_vtx, allow_nil); end

  def next_vtx(); end

  def on_type_added(genv, src_var, added_types); end

  def on_type_removed(genv, src_var, removed_types); end
end

class TypeProf::Core::NilFilter
end

class TypeProf::Core::RecordBlock
  def accept_args(genv, changes, caller_positionals, caller_ret, ret_check); end

  def f_args(); end

  def get_f_arg(i); end

  def initialize(node); end

  def node(); end

  def ret(); end

  def used(); end
end

class TypeProf::Core::RecordBlock
end

class TypeProf::Core::ScopedConstRead
  include ::TypeProf::Core::ConstRead
end

class TypeProf::Core::ScopedConstRead
end

class TypeProf::Core::ScopedStaticRead
  def initialize(name, cbase); end

  def on_cbase_updated(genv); end
end

class TypeProf::Core::ScopedStaticRead
end

class TypeProf::Core::ScopedTypeAliasRead
  include ::TypeProf::Core::TypeAliasRead
end

class TypeProf::Core::ScopedTypeAliasRead
end

class TypeProf::Core::Service
  def add_workspace(rb_folder, rbs_folder); end

  def batch(files, output); end

  def code_lens(path); end

  def completion(path, trigger, pos); end

  def definitions(path, pos); end

  def diagnostics(path, &blk); end

  def dump_declarations(path); end

  def genv(); end

  def get_method_sig(cpath, singleton, mid); end

  def hover(path, pos); end

  def initialize(options); end

  def load_rbs_declarations(rbs_collection); end

  def references(path, pos); end

  def rename(path, pos); end

  def reset!(); end

  def type_definitions(path, pos); end

  def update_file(path, code); end

  def update_rb_file(path, code); end

  def update_rbs_file(path, code); end
end

class TypeProf::Core::Service
end

class TypeProf::Core::Set
  def -(other); end

  def <<(elem); end

  def clear(); end

  def delete(elem); end

  def each(&blk); end

  def empty?(); end

  def include?(elem); end

  def initialize(hash); end

  def internal_hash(); end

  def merge(set); end

  def size(); end

  def to_a(); end
end

class TypeProf::Core::Set
  def self.[](*elems); end
end

class TypeProf::Core::Source
  def add_edge(genv, nvtx); end

  def initialize(*tys); end

  def new_vertex(genv, origin); end

  def on_type_added(genv, src_var, added_types); end

  def on_type_removed(genv, src_var, removed_types); end

  def remove_edge(genv, nvtx); end
end

class TypeProf::Core::Source
end

class TypeProf::Core::SplatBox
  def ary(); end

  def initialize(node, genv, ary); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::SplatBox
end

class TypeProf::Core::StaticRead
  def destroy(genv); end

  def followers(); end

  def initialize(name); end

  def name(); end

  def propagate(genv); end

  def resolve(genv, cref, break_object); end
end

class TypeProf::Core::StaticRead
end

class TypeProf::Core::Type
end

class TypeProf::Core::Type::Array
  def base_type(genv); end

  def check_match(genv, changes, vtx); end

  def elems(); end

  def get_elem(genv, idx=T.unsafe(nil)); end

  def initialize(genv, elems, base_type); end

  def show(); end

  def splat_assign(genv, lefts, rest_elem, rights); end
end

class TypeProf::Core::Type::Array
end

class TypeProf::Core::Type::Bot
  def base_type(genv); end

  def check_match(genv, changes, vtx); end

  def initialize(genv); end

  def show(); end
end

class TypeProf::Core::Type::Bot
end

class TypeProf::Core::Type::Hash
  def base_type(genv); end

  def check_match(genv, changes, vtx); end

  def get_key(); end

  def get_value(key=T.unsafe(nil)); end

  def initialize(genv, literal_pairs, base_type); end

  def show(); end
end

class TypeProf::Core::Type::Hash
end

class TypeProf::Core::Type::Instance
  def args(); end

  def base_type(_); end

  def check_match(genv, changes, vtx); end

  def check_match_included_modules(genv, changes, ty, other_ty); end

  def initialize(genv, mod, args); end

  def mod(); end

  def show(); end
end

class TypeProf::Core::Type::Instance
end

class TypeProf::Core::Type::Proc
  def base_type(genv); end

  def block(); end

  def check_match(genv, changes, vtx); end

  def initialize(genv, block); end

  def show(); end
end

class TypeProf::Core::Type::Proc
end

class TypeProf::Core::Type::Singleton
  def base_type(_); end

  def check_match(genv, changes, vtx); end

  def get_instance_type(genv); end

  def initialize(genv, mod); end

  def mod(); end

  def show(); end
end

class TypeProf::Core::Type::Singleton
end

class TypeProf::Core::Type::Symbol
  def base_type(genv); end

  def check_match(genv, changes, vtx); end

  def initialize(genv, sym); end

  def show(); end

  def sym(); end
end

class TypeProf::Core::Type::Symbol
end

class TypeProf::Core::Type::Var
  def base_type(genv); end

  def check_match(genv, changes, vtx); end

  def initialize(genv, name, vtx); end

  def name(); end

  def show(); end

  def vtx(); end
end

class TypeProf::Core::Type::Var
end

class TypeProf::Core::Type
  def self.default_param_map(genv, ty); end

  def self.new(genv, *args); end

  def self.strip_array(s); end

  def self.strip_parens(s); end
end

class TypeProf::Core::TypeAliasEntity
  def add_decl(decl); end

  def decls(); end

  def exist?(); end

  def remove_decl(decl); end

  def type(); end
end

class TypeProf::Core::TypeAliasEntity
end

module TypeProf::Core::TypeAliasRead
  def check_module(genv, mod); end

  def resolution_failed(genv); end

  def type_alias_entity(); end

  def update_type_alias(genv, tae); end
end

module TypeProf::Core::TypeAliasRead
end

class TypeProf::Core::TypeReadBox
  def initialize(node, genv, rbs_type); end

  def rbs_type(); end

  def ret(); end

  def run0(genv, changes); end
end

class TypeProf::Core::TypeReadBox
end

class TypeProf::Core::ValueEntity
  def add_decl(decl); end

  def add_def(def_); end

  def decls(); end

  def defs(); end

  def exist?(); end

  def read_boxes(); end

  def remove_decl(decl); end

  def remove_def(def_); end

  def vtx(); end
end

class TypeProf::Core::ValueEntity
end

class TypeProf::Core::Vertex
  def add_edge(genv, nvtx); end

  def initialize(origin); end

  def new_vertex(genv, origin); end

  def next_vtxs(); end

  def on_type_added(genv, src_var, added_types); end

  def on_type_removed(genv, src_var, removed_types); end

  def remove_edge(genv, nvtx); end
end

class TypeProf::Core::Vertex
end

module TypeProf::Core
end

class TypeProf::Diagnostic
  def code_range(); end

  def initialize(node, meth, msg); end

  def msg(); end

  def reuse(new_node); end

  def severity(); end

  def to_lsp(); end
  SEVERITY = ::T.let(nil, ::T.untyped)
  TAG = ::T.let(nil, ::T.untyped)
end

class TypeProf::Diagnostic
end

module TypeProf::LSP
end

module TypeProf::LSP::ErrorCodes
  InternalError = ::T.let(nil, ::T.untyped)
  InvalidParams = ::T.let(nil, ::T.untyped)
  InvalidRequest = ::T.let(nil, ::T.untyped)
  MethodNotFound = ::T.let(nil, ::T.untyped)
  ParseError = ::T.let(nil, ::T.untyped)
end

module TypeProf::LSP::ErrorCodes
end

class TypeProf::LSP::Message
  def initialize(server, json); end

  def log(msg); end

  def notify(method, **params); end

  def respond(result); end

  def respond_error(error); end

  def run(); end
  Classes = ::T.let(nil, ::T.untyped)
  Table = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::CancelRequest
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::CancelRequest
end

class TypeProf::LSP::Message::Exit
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::Exit
end

class TypeProf::LSP::Message::Initialize
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::Initialize
end

class TypeProf::LSP::Message::Initialized
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::Initialized
end

class TypeProf::LSP::Message::Shutdown
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::Shutdown
end

module TypeProf::LSP::Message::TextDocument
end

class TypeProf::LSP::Message::TextDocument::CodeLens
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::CodeLens
end

class TypeProf::LSP::Message::TextDocument::Completion
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::Completion
end

class TypeProf::LSP::Message::TextDocument::Definition
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::Definition
end

class TypeProf::LSP::Message::TextDocument::DidChange
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::DidChange
end

class TypeProf::LSP::Message::TextDocument::DidClose
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::DidClose
end

class TypeProf::LSP::Message::TextDocument::DidOpen
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::DidOpen
end

class TypeProf::LSP::Message::TextDocument::Hover
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::Hover
end

class TypeProf::LSP::Message::TextDocument::References
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::References
end

class TypeProf::LSP::Message::TextDocument::Rename
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::Rename
end

class TypeProf::LSP::Message::TextDocument::TypeDefinition
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::TextDocument::TypeDefinition
end

module TypeProf::LSP::Message::TextDocument
end

module TypeProf::LSP::Message::Workspace
end

class TypeProf::LSP::Message::Workspace::ExecuteCommand
  METHOD = ::T.let(nil, ::T.untyped)
end

class TypeProf::LSP::Message::Workspace::ExecuteCommand
end

module TypeProf::LSP::Message::Workspace
end

class TypeProf::LSP::Message
  def self.build_table(); end

  def self.find(method); end

  def self.inherited(klass); end
end

class TypeProf::LSP::Reader
  def initialize(io); end

  def read(); end
end

class TypeProf::LSP::Reader::ProtocolError
end

class TypeProf::LSP::Reader::ProtocolError
end

class TypeProf::LSP::Reader
end

class TypeProf::LSP::Server
  def add_workspaces(folders); end

  def cancel_request(id); end

  def core(); end

  def exit(); end

  def initialize(core, reader, writer, url_schema: T.unsafe(nil), publish_all_diagnostics: T.unsafe(nil)); end

  def open_texts(); end

  def path_to_uri(path); end

  def publish_diagnostics(uri); end

  def run(); end

  def send_notification(method, **params); end

  def send_request(method, **params, &blk); end

  def send_response(**msg); end

  def signature_enabled(); end

  def signature_enabled=(signature_enabled); end

  def target_path?(path); end

  def uri_to_path(url); end
end

class TypeProf::LSP::Server
  def self.start_socket(core); end

  def self.start_stdio(core); end
end

class TypeProf::LSP::Text
  def apply_changes(changes, version); end

  def initialize(path, text, version); end

  def lines(); end

  def modify_for_completion(changes, pos); end

  def path(); end

  def string(); end

  def validate(); end

  def version(); end
end

class TypeProf::LSP::Text
  def self.split(str); end
end

class TypeProf::LSP::Writer
  def initialize(io); end

  def write(**json); end
end

class TypeProf::LSP::Writer
end

module TypeProf::LSP
  def self.load_json_with_comments(path, **opts); end
end

module URI
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  def decoded_password(); end

  def decoded_user(); end
end

class URI::HTTP
  def authority(); end

  def origin(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil), &block); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WSS
end

module URI
  def self.const_missing(const); end

  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.parser=(parser=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end
end

class Unicode::DisplayWidth
  ASCII_NON_ZERO_REGEX = ::T.let(nil, ::T.untyped)
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  FIRST_4096 = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  INITIAL_DEPTH = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Unicode::DisplayWidth
  def self.decompress_index(index, level); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
